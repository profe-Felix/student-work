<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spanish Reading Game</title>
  
  <!-- Andika Font -->
  <link href="https://fonts.googleapis.com/css2?family=Andika&display=swap" rel="stylesheet">
  <!-- Supabase client -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <style>
    body {
      background-color: white;
      font-family: 'Andika', sans-serif;
      text-align: center;
      user-select: none;
      margin-top: 20px;
    }
    canvas {
      border: 1px solid #ddd;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      margin-bottom: 15px;
      display: inline-block;
      max-width: 100%;
      height: auto; /* responsive */
    }
    select, button {
      font-size: 18px;
      padding: 5px 10px;
      margin: 5px;
      font-family: 'Andika', sans-serif;
    }
    #controls { margin-top: 15px; }

    /* ===== Spelling mode UI ===== */
    .row {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 8px;
      margin-bottom: 6px;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 999px;
      background: #fafafa;
      color: #333;
      font-size: 16px;
    }
    #spellingPanel {
      max-width: 820px;
      margin: 0 auto;
      padding: 10px 12px;
      display: none; /* toggled on/off */
    }
    #spellingInput {
      width: min(520px, 92vw);
      max-width: 92vw;
      text-align: center;
      border: 2px solid #111;
      border-radius: 10px;
      outline: none;
      font-size: 20px;
      padding: 8px 10px;
      font-family: 'Andika', sans-serif;
    }
    #spellingInput:focus {
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37,99,235,.15);
    }
    #feedback {
      font-size: 18px;
      margin-top: 8px;
      min-height: 24px;
    }
    #correctReveal {
      font-size: 20px;
      margin-top: 6px;
      color: #111;
      min-height: 24px;
    }
    .muted {
      color: #666;
      font-size: 14px;
      margin-top: 6px;
    }
    .btnPrimary {
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
    }
    .btnPrimary:disabled { opacity: .55; cursor: not-allowed; }
    .btnGhost {
      background: white;
      border: 1px solid #ddd;
      border-radius: 10px;
      cursor: pointer;
      padding: 8px 12px;
    }
  </style>
</head>
<body>
  <h2>Spanish Reading Game</h2>
  <div id="syncStatus" style="margin-bottom: 10px; font-size: 16px; color:#555;"></div>

  <!-- spelling mode toggle -->
  <div class="row">
    <span class="pill">
      <input type="checkbox" id="spellingToggle" />
      <label for="spellingToggle" style="cursor:pointer;">Modo deletrear</label>
    </span>
    <span class="pill" id="autoplayHint">üîä Auto-audio despu√©s del primer toque</span>
  </div>

  <select id="wordListSelect">
    <option value="" selected disabled>Selecciona una lista</option>
    <option value="1. s√≠labas">1. s√≠labas</option>
    <option value="2. palabras">2. palabras</option>
    <option value="cvc">cvc</option>
    <option value="inversas">inversas</option>
    <option value="trabadas">trabadas</option>
  </select>

  <div id="controls">
    <button id="playAudio" disabled>üîä Play Audio</button>
    <button id="prevWord">‚üµ Prev</button>
    <button id="nextWord">Next ‚ü∂</button>
  </div>

  <canvas id="wordCanvas" width="768" height="432"></canvas>

  <!-- spelling panel -->
  <div id="spellingPanel">
    <div class="row">
      <input id="spellingInput"
             type="text"
             inputmode="text"
             autocomplete="off"
             autocorrect="off"
             autocapitalize="off"
             spellcheck="false"
             placeholder="Escribe la palabra aqu√≠‚Ä¶" />
      <button id="submitSpelling" class="btnPrimary">‚úÖ Submit</button>
      <button id="clearSpelling" class="btnGhost">‚Ü∫ Borrar</button>
    </div>
    <div id="feedback"></div>
    <div id="correctReveal"></div>
    <div class="muted">Se aceptan sin acentos (mam√° = mama). Despu√©s de Submit se muestra la forma correcta.</div>
  </div>

  <div id="recording-controls">
    <button id="startRecording">üéô Start Recording</button>
    <button id="stopRecording" disabled>‚èπ Stop Recording</button>
  </div>
  
  <div id="readyMessage" style="font-size: 24px; margin-top: 10px; color: #555;"></div>
  <div id="previewContainer"></div>

<script>
/* ==================== SUPABASE CONFIG (group sync) ==================== */
const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";

const sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// URL params: ?role=teacher&group=A or ?role=student&group=A
const qs = new URLSearchParams(location.search);
const ROLE = (qs.get('role') || '').toLowerCase();
const GROUP_CODE = (qs.get('group') || '').toUpperCase();
const isTeacher = ROLE === 'teacher' && !!GROUP_CODE;
const isStudent = ROLE === 'student' && !!GROUP_CODE;

const syncStatusEl = document.getElementById('syncStatus');
if (syncStatusEl) {
  if (!ROLE || !GROUP_CODE) {
    syncStatusEl.textContent = "Modo local: usa ?role=teacher&group=A o ?role=student&group=A en la URL para sincronizar.";
  } else if (isTeacher) {
    syncStatusEl.textContent = `Modo MAESTRO ‚Äî Grupo ${GROUP_CODE}. Usa Prev/Next para guiar.`;
  } else if (isStudent) {
    syncStatusEl.textContent = `Modo ESTUDIANTE ‚Äî Grupo ${GROUP_CODE}. Seguir√° al maestro.`;
  } else {
    syncStatusEl.textContent = "Modo local (role/group no v√°lidos).";
  }
}

async function ensureReadingGroup(groupCode) {
  if (!groupCode) return null;

  const { data, error } = await sbClient
    .from('reading_groups')
    .select('*')
    .eq('group_code', groupCode)
    .maybeSingle();

  if (error && error.code !== 'PGRST116') {
    console.warn('ensureReadingGroup error', error);
    return null;
  }

  if (!data) {
    const { data: inserted, error: insertErr } = await sbClient
      .from('reading_groups')
      .insert({ group_code: groupCode, current_index: 0 })
      .select()
      .single();
    if (insertErr) {
      console.warn('insert reading_group error', insertErr);
      return null;
    }
    return inserted;
  }

  return data;
}

async function setReadingIndex(groupCode, index) {
  if (!groupCode) return null;
  const { data, error } = await sbClient
    .from('reading_groups')
    .update({ current_index: index })
    .eq('group_code', groupCode)
    .select('current_index')
    .single();

  if (error) {
    console.warn('setReadingIndex error', error);
    return null;
  }
  console.log('[TEACHER] set index', groupCode, index);
  return data.current_index;
}

async function getReadingIndex(groupCode) {
  if (!groupCode) return null;
  const { data, error } = await sbClient
    .from('reading_groups')
    .select('current_index')
    .eq('group_code', groupCode)
    .single();

  if (error) {
    if (error.code !== 'PGRST116') {
      console.warn('getReadingIndex error', error);
    }
    return null;
  }
  return data.current_index;
}

/* ==================== Deterministic shuffle + session ==================== */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
function shuffleWithSeed(array, seedStr) {
  const seedFn = xmur3(seedStr);
  const rng = mulberry32(seedFn());
  const arr = array.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function makeSessionId() {
  if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
  return (Date.now().toString(36) + "-" + Math.random().toString(36).slice(2));
}

/* Ensure this exists before first draw */
if (window.allowSliderDraw === undefined) {
  window.allowSliderDraw = true;
}

/* ==================== Canvas + responsive scaling ==================== */
const canvas = document.getElementById("wordCanvas");
const ctx = canvas.getContext("2d");

let words = [], currentWordIndex = 0;
let sliderX = 0, isDragging = false, sliderStart, sliderEnd;
let letters = [];
let pollTimer = null;

const DPR = window.devicePixelRatio || 1;
const BASE_W = 768, BASE_H = 432, BASE_AR = BASE_H / BASE_W;

function resizeCanvas() {
  const maxWidth = 768;
  const width = Math.min(window.innerWidth * 0.95, maxWidth);
  const height = Math.round(width * BASE_AR);

  canvas.style.width = width + "px";
  canvas.style.height = height + "px";

  canvas.width = Math.round(width * DPR);
  canvas.height = Math.round(height * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  if (words.length) {
    setupWord(words[currentWordIndex]);
  } else {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}

window.addEventListener("resize", () => requestAnimationFrame(resizeCanvas));
window.addEventListener("orientationchange", () => requestAnimationFrame(resizeCanvas));
document.addEventListener("DOMContentLoaded", resizeCanvas);

/* ==================== UI & Data ==================== */
const playBtn = document.getElementById("playAudio");

document.getElementById("wordListSelect").addEventListener("change", loadWordList);
document.getElementById("nextWord").addEventListener("click", () => changeWord(1));
document.getElementById("prevWord").addEventListener("click", () => changeWord(-1));

playBtn.addEventListener("click", () => {
  if (!words.length) return;
  playWordAudio(words[currentWordIndex]);
});

/* ==================== Spelling mode wiring ==================== */
const spellingToggle = document.getElementById('spellingToggle');
const spellingPanel  = document.getElementById('spellingPanel');
const spellingInput  = document.getElementById('spellingInput');
const submitSpelling = document.getElementById('submitSpelling');
const clearSpelling  = document.getElementById('clearSpelling');
const feedbackEl     = document.getElementById('feedback');
const correctReveal  = document.getElementById('correctReveal');
const autoplayHint   = document.getElementById('autoplayHint');

let spellingMode = false;
let spellingSubmitted = false;
let userPrimedForAudio = false;

/* NEW: store last typed (so canvas can render letters) */
let spellingLastTypedRaw = "";     // what student typed
let spellingLastTypedSyl = [];     // syllabified typed

function primeAudioOnce() {
  if (userPrimedForAudio) return;
  userPrimedForAudio = true;
  if (autoplayHint) autoplayHint.textContent = "üîä Auto-audio activado";
}
window.addEventListener('pointerdown', primeAudioOnce, { passive: true });
window.addEventListener('keydown', primeAudioOnce);

function resetSpellingUI() {
  spellingSubmitted = false;
  spellingLastTypedRaw = "";
  spellingLastTypedSyl = [];
  if (feedbackEl) { feedbackEl.textContent = ""; feedbackEl.style.color = "#111"; }
  if (correctReveal) correctReveal.textContent = "";
  if (spellingInput) spellingInput.value = "";
}

function setSpellingMode(on) {
  spellingMode = !!on;
  if (spellingPanel) spellingPanel.style.display = spellingMode ? "block" : "none";
  resetSpellingUI();
  drawCanvas();
  if (spellingMode && spellingInput) spellingInput.focus();
}
if (spellingToggle) spellingToggle.addEventListener('change', () => setSpellingMode(spellingToggle.checked));

if (submitSpelling) submitSpelling.addEventListener('click', () => gradeSpelling());
if (clearSpelling) clearSpelling.addEventListener('click', () => { if (spellingInput) { spellingInput.value=""; spellingInput.focus(); drawCanvas(); } });

if (spellingInput) {
  spellingInput.addEventListener('input', () => {
    spellingLastTypedRaw = (spellingInput.value || "");
    spellingLastTypedSyl = syllabify(spellingLastTypedRaw.trim());
    drawCanvas();
  });
  spellingInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      gradeSpelling();
    }
  });
}

/* Accent-insensitive compare */
function normalizeForCompare(s) {
  return (s || "")
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z√±√º]+/g, '');
}

/* Helper: compare one character accent-insensitively */
function normChar(ch) {
  return (ch || "")
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '');
}

/* Auto syllabify (heuristic; tune later) */
const STRONG = new Set(['a','e','o','√°','√©','√≥']);
const WEAK   = new Set(['i','u','√º','√≠','√∫']);
function isVowelChar(ch){ return /[aeiou√°√©√≠√≥√∫√º]/i.test(ch); }
function isAccentedWeak(ch){ return ch === '√≠' || ch === '√∫'; }
function isStrong(ch){ return STRONG.has(ch); }
function tokenizeSpanish(word) {
  const w = (word || "").toLowerCase();
  const tokens = [];
  for (let i=0;i<w.length;) {
    const two = w.slice(i,i+2);
    if (two === 'ch' || two === 'll' || two === 'rr') { tokens.push(two); i+=2; continue; }
    if (two === 'qu') { tokens.push(two); i+=2; continue; }
    if (two === 'gu') { tokens.push(two); i+=2; continue; }
    tokens.push(w[i]); i++;
  }
  return tokens;
}
function isVowelToken(tok){
  if (tok === 'qu' || tok === 'gu') return false;
  if (tok === 'ch' || tok === 'll' || tok === 'rr') return false;
  return tok.length === 1 && isVowelChar(tok);
}
function vowelGroup(tokens, start) {
  let i = start;
  let group = [];
  while (i < tokens.length && isVowelToken(tokens[i])) { group.push(tokens[i]); i++; }
  if (group.length <= 1) return { nucleus: group, next: start + group.length };

  const nuc = [group[0]];
  for (let k=1;k<group.length;k++){
    const prev = nuc[nuc.length-1];
    const curr = group[k];
    if (isStrong(prev) && isStrong(curr)) break;
    if (isAccentedWeak(prev) || isAccentedWeak(curr)) break;
    nuc.push(curr);
  }
  return { nucleus: nuc, next: start + nuc.length };
}
const ONSET_PAIRS = new Set(['pr','pl','br','bl','fr','fl','tr','dr','cr','cl','gr','gl']);
function syllabify(word) {
  const original = (word || "").toLowerCase().trim();
  if (!original) return [];
  const tokens = tokenizeSpanish(original);

  let hasVowel = false;
  for (const t of tokens) if (isVowelToken(t)) { hasVowel = true; break; }
  if (!hasVowel) return [original];

  const syllables = [];
  let i = 0;

  while (i < tokens.length) {
    let onsetStart = i;
    while (i < tokens.length && !isVowelToken(tokens[i])) i++;
    if (i >= tokens.length) {
      if (syllables.length) syllables[syllables.length-1] += tokens.slice(onsetStart).join('');
      else syllables.push(tokens.slice(onsetStart).join(''));
      break;
    }
    const onset = tokens.slice(onsetStart, i);

    const vg = vowelGroup(tokens, i);
    const nucleus = vg.nucleus;
    i = vg.next;

    let consStart = i;
    while (i < tokens.length && !isVowelToken(tokens[i])) i++;
    const cons = tokens.slice(consStart, i);

    let coda = [];
    let nextOnset = cons;

    if (cons.length === 0) { coda = []; nextOnset = []; }
    else if (cons.length === 1) { coda = []; nextOnset = cons; }
    else if (cons.length === 2) {
      const pair = (cons[0] + cons[1]).replace(/[^a-z√±√º]/g,'');
      if (ONSET_PAIRS.has(pair)) { coda = []; nextOnset = cons; }
      else { coda = [cons[0]]; nextOnset = [cons[1]]; }
    } else if (cons.length === 3) {
      const last2 = (cons[1] + cons[2]).replace(/[^a-z√±√º]/g,'');
      if (ONSET_PAIRS.has(last2)) { coda = [cons[0]]; nextOnset = [cons[1], cons[2]]; }
      else { coda = [cons[0], cons[1]]; nextOnset = [cons[2]]; }
    } else {
      const last2 = (cons[cons.length-2] + cons[cons.length-1]).replace(/[^a-z√±√º]/g,'');
      if (ONSET_PAIRS.has(last2)) {
        coda = cons.slice(0, cons.length-2);
        nextOnset = cons.slice(cons.length-2);
      } else {
        coda = cons.slice(0, cons.length-1);
        nextOnset = cons.slice(cons.length-1);
      }
    }

    const syl = onset.join('') + nucleus.join('') + coda.join('');
    syllables.push(syl);

    i = i - nextOnset.length;
  }

  return syllables.filter(Boolean);
}

function gradeSpelling() {
  if (!spellingMode) return;
  if (!words.length) return;

  const correct = words[currentWordIndex] || "";
  const typed = (spellingInput ? spellingInput.value : "").trim();

  if (!typed) {
    if (feedbackEl) { feedbackEl.textContent = "Escribe algo primero üôÇ"; feedbackEl.style.color = "#666"; }
    if (correctReveal) correctReveal.textContent = "";
    return;
  }

  spellingLastTypedRaw = typed;
  spellingLastTypedSyl = syllabify(typed);

  const ok = normalizeForCompare(typed) === normalizeForCompare(correct);
  spellingSubmitted = true;

  if (feedbackEl) {
    feedbackEl.textContent = ok ? "‚úÖ ¬°Correcto!" : "‚ùå Intenta otra vez.";
    feedbackEl.style.color = ok ? "#16a34a" : "#dc2626";
  }
  if (correctReveal) {
    correctReveal.textContent = `Correcto: ${correct}`;
  }
  drawCanvas();
}

/* ==================== loadWordList / sync stays same ==================== */
async function loadWordList() {
  const listName = document.getElementById("wordListSelect").value;
  const url = `wordlists/${encodeURIComponent(listName)}.txt`;

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`No encontrado: ${url}`);
    const data = await response.text();
    let baseWords = data.trim().split("\n").map(w => w.trim()).filter(Boolean);

    if (GROUP_CODE && (isTeacher || isStudent)) {
      await ensureReadingGroup(GROUP_CODE);

      if (isTeacher) {
        const sessionId = makeSessionId();
        const { error: sessErr } = await sbClient
          .from('reading_groups')
          .update({ session_id: sessionId, current_index: 0 })
          .eq('group_code', GROUP_CODE);
        if (sessErr) {
          console.warn('update session_id error', sessErr);
        }
        const seedStr = `${GROUP_CODE}::${listName}::${sessionId}`;
        words = shuffleWithSeed(baseWords, seedStr);
        currentWordIndex = 0;
        console.log('[SYNC] teacher session', GROUP_CODE, listName, sessionId, words);
      } else if (isStudent) {
        const { data: row, error: rowErr } = await sbClient
          .from('reading_groups')
          .select('session_id, current_index')
          .eq('group_code', GROUP_CODE)
          .maybeSingle();

        if (!rowErr && row && row.session_id) {
          const seedStr = `${GROUP_CODE}::${listName}::${row.session_id}`;
          words = shuffleWithSeed(baseWords, seedStr);
          currentWordIndex = row.current_index ?? 0;
          console.log('[SYNC] student using session', GROUP_CODE, listName, row.session_id, 'index', currentWordIndex);
        } else {
          words = baseWords.sort(() => Math.random() - 0.5);
          currentWordIndex = 0;
          console.log('[SYNC] student fallback random (no session_id yet)');
        }
      }
    } else {
      words = baseWords.sort(() => Math.random() - 0.5);
      currentWordIndex = 0;
    }

    document.fonts.ready.then(async () => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;

      if (isTeacher && GROUP_CODE) {
        await setReadingIndex(GROUP_CODE, currentWordIndex);
      }

      if (isStudent && GROUP_CODE) {
        startStudentPolling();
      }

      if (spellingMode && spellingInput) spellingInput.focus();
    });
  } catch (err) {
    console.warn(err);
    alert(`No pude cargar "${url}". Verifica el nombre y las may√∫sculas/min√∫sculas en GitHub Pages.`);
  }
}

async function startStudentPolling() {
  if (!isStudent || !GROUP_CODE) return;
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }

  const doPoll = async () => {
    const idx = await getReadingIndex(GROUP_CODE);
    if (idx == null) return;
    if (!words.length) return;
    if (idx === currentWordIndex) return;
    if (idx < 0 || idx >= words.length) return;

    console.log('[STUDENT] applying index from teacher', idx);
    currentWordIndex = idx;
    document.fonts.ready.then(() => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;
      if (spellingMode && spellingInput) spellingInput.focus();
    });
  };

  await doPoll();
  pollTimer = setInterval(doPoll, 2000);
}

function changeWord(direction) {
  if (!words.length) return;
  currentWordIndex = (currentWordIndex + direction + words.length) % words.length;
  document.fonts.ready.then(() => {
    setupWord(words[currentWordIndex]);
    playBtn.disabled = false;
    if (spellingMode && spellingInput) spellingInput.focus();
  });

  if (isTeacher && GROUP_CODE) {
    setReadingIndex(GROUP_CODE, currentWordIndex);
  }
}

/* ==================== Layout & Drawing ==================== */
function setupWord(word) {
  if (spellingMode) resetSpellingUI();

  const baseFont = 80;
  const scaledFont = Math.round(baseFont * (canvas.clientWidth / 768));
  const fontPx = Math.max(36, Math.min(96, scaledFont));
  ctx.font = `bold ${fontPx}px Andika`;

  letters = parseWord(word);

  const padding = 10;
  const em = fontPx;
  const minPill = Math.max(18, em * 0.55);
  const innerPad = Math.max(4, Math.round(em * 0.06));

  letters.forEach(l => {
    const gw = ctx.measureText(l.text).width;
    l.gw = gw;
    l.w  = Math.max(gw + innerPad * 2, minPill);
  });

  const totalWidth = letters.reduce((s, l) => s + l.w, 0) + padding * (letters.length - 1);

  sliderStart = (canvas.clientWidth - totalWidth) / 2;
  sliderEnd   = sliderStart + totalWidth;

  sliderX = sliderStart;
  drawCanvas();

  if (spellingMode && userPrimedForAudio) {
    setTimeout(() => {
      if (words.length) playWordAudio(words[currentWordIndex]);
    }, 150);
  }
}

function parseWord(word) {
  const digraphs = ["ch", "ll", "rr", "qu"];
  const out = [];
  for (let i = 0; i < word.length;) {
    let digraph = digraphs.find(d => word.startsWith(d, i));
    if (digraph) {
      out.push({text: digraph, soundType: getSoundType(digraph)});
      i += digraph.length;
    } else {
      out.push({text: word[i], soundType: getSoundType(word[i], word[i+1])});
      i++;
    }
  }
  return out;
}

function getSoundType(letter, nextLetter = "") {
  if (letter === "c") return /[ei]/.test(nextLetter) ? "continuous" : "stop";
  if (["p","t","k","b","d","g","ch"].includes(letter)) return "stop";
  if (letter === "h") return "silent";
  return "continuous";
}

function drawCanvas() {
  if (!window.allowSliderDraw) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const baseFont = 80;
  const scaledFont = Math.round(baseFont * (canvas.clientWidth / 768));
  const fontPx = Math.max(36, Math.min(96, scaledFont));
  ctx.font = `bold ${fontPx}px Andika`;
  ctx.textAlign = "center";

  const padding = 10;
  const pillH = Math.max(16, Math.round(fontPx * 0.25));
  const textY = Math.round(fontPx * 1.25);
  const pillY = textY + Math.max(16, Math.round(fontPx * 0.5));

  function pillRadius(w, h) {
    return Math.max(2, Math.min(10, h / 2, w / 2 - 1));
  }

  /* ===== spelling-mode drawing: letters above underlines + per-letter coloring ===== */
  if (spellingMode && words.length) {
    const correctWord = words[currentWordIndex] || "";
    const correctSyl = syllabify(correctWord);

    const typedSyl = spellingLastTypedSyl && spellingLastTypedSyl.length
      ? spellingLastTypedSyl
      : (spellingInput ? syllabify((spellingInput.value || "").trim()) : []);

    const gap = Math.max(10, Math.round(fontPx * 0.18));
    const boxH = Math.max(60, Math.round(fontPx * 1.05));
    const boxY = Math.round(canvas.clientHeight * 0.18);

    ctx.textBaseline = "alphabetic";

    const syllWidths = correctSyl.map(s => {
      const n = Math.max(1, s.length);
      const w = Math.max(100, Math.min(320, n * Math.round(fontPx * 0.62)));
      return w;
    });

    const totalW = syllWidths.reduce((a,b)=>a+b,0) + gap * (syllWidths.length - 1);
    let x = (canvas.clientWidth - totalW) / 2;

    for (let si = 0; si < correctSyl.length; si++) {
      const correctS = correctSyl[si] || "";
      const typedS = (typedSyl[si] || "");

      const w = syllWidths[si];

      // box
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#111";
      ctx.fillStyle = "#fff";
      roundRect(x, boxY, w, boxH, 14, true, true);

      // letter slots
      const slots = Math.max(1, correctS.length);
      const blankGap = Math.max(10, Math.round(fontPx * 0.14));
      const blankW = Math.max(14, Math.round(fontPx * 0.30));
      const totalBlankW = slots * blankW + (slots - 1) * blankGap;
      const start = x + (w - totalBlankW) / 2;

      const underlineY = boxY + Math.round(boxH * 0.72);
      const letterY = boxY + Math.round(boxH * 0.55);

      // draw each slot
      for (let li = 0; li < slots; li++) {
        const bx = start + li * (blankW + blankGap);

        const typedCh = typedS[li] || "";          // what student typed for that position
        const correctCh = correctS[li] || "";      // correct at that position

        const isFilled = !!typedCh;
        const isCorrect = isFilled && (normChar(typedCh) === normChar(correctCh));

        // choose color
        let col = "#111";
        if (spellingSubmitted) {
          col = isCorrect ? "#16a34a" : "#dc2626";
        }

        // underline (colored after submit)
        ctx.lineWidth = 5;
        ctx.strokeStyle = spellingSubmitted ? col : "#111";
        ctx.beginPath();
        ctx.moveTo(bx, underlineY);
        ctx.lineTo(bx + blankW, underlineY);
        ctx.stroke();

        // typed letter above underline
        if (typedCh) {
          ctx.fillStyle = spellingSubmitted ? col : "#111";
          ctx.font = `bold ${Math.round(fontPx * 0.62)}px Andika`;
          ctx.fillText(typedCh, bx + blankW/2, letterY);
          ctx.font = `bold ${fontPx}px Andika`;
        }
      }

      x += w + gap;
    }

    // faint rail below (keeps visual layout stable)
    const lineY = pillY + pillH + Math.max(16, Math.round(fontPx * 0.25));
    ctx.lineCap = "round";
    ctx.strokeStyle = "#eee";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(sliderStart, lineY);
    ctx.lineTo(sliderEnd, lineY);
    ctx.stroke();

    return;
  }

  /* ===== original reading-mode drawing ===== */
  let x = sliderStart;

  letters.forEach(letter => {
    const pillW = letter.w;

    ctx.fillStyle = (sliderX >= x + 1) ? "black" : "lightgrey";
    if (letter.text === "h" && letter.soundType === "silent") ctx.fillStyle = "#ccc";

    ctx.fillText(letter.text, x + pillW / 2, textY);

    ctx.strokeStyle = letter.soundType === "silent" ? "#aaa"
                     : letter.soundType === "stop" ? "red" : "green";
    ctx.lineWidth = 3;
    ctx.fillStyle = (sliderX >= x + 1) ? ctx.strokeStyle : "white";

    const r = pillRadius(pillW, pillH);
    roundRect(x, pillY, pillW, pillH, r, true, true);

    x += pillW + padding;
  });

  const lineY = pillY + pillH + Math.max(16, Math.round(fontPx * 0.25));
  ctx.lineCap = "round";
  ctx.strokeStyle = "#ccc";
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(sliderStart, lineY);
  ctx.lineTo(sliderEnd, lineY);
  ctx.stroke();

  ctx.strokeStyle = "#007bff";
  ctx.beginPath();
  ctx.moveTo(sliderStart, lineY);
  ctx.lineTo(sliderX, lineY);
  ctx.stroke();

  ctx.beginPath();
  ctx.fillStyle = "#007bff";
  ctx.arc(sliderX, lineY, 10, 0, Math.PI * 2);
  ctx.fill();
}

canvas.addEventListener("pointerdown", (e)=> {isDragging=true; moveSlider(e);});
canvas.addEventListener("pointermove", (e)=> {if(isDragging){moveSlider(e);}});
canvas.addEventListener("pointerup", ()=>isDragging=false);
canvas.addEventListener("pointerleave", ()=>isDragging=false);

function moveSlider(e){
  const rect = canvas.getBoundingClientRect();
  sliderX = Math.min(Math.max(e.clientX - rect.left, sliderStart), sliderEnd);
  drawCanvas();
}

function roundRect(x, y, w, h, r, fill, stroke) {
  r = Math.max(0, Math.min(r, w/2, h/2));
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* ==================== AUDIO: use /audio, fallback to first syllable ==================== */
function normalizeName(s) {
  return s
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z√±√º]+/g, '');
}
function isVowel(ch) { return /[aeiou√°√©√≠√≥√∫]/i.test(ch); }
function firstSyllable(word) {
  const w = (word || "").toLowerCase();
  if (!w) return "";
  const digraphs = ["ch","ll","rr","qu"];
  for (const d of digraphs) {
    if (w.startsWith(d)) {
      const next = w[d.length] || "";
      if (isVowel(next)) return d + next;
      return d;
    }
  }
  const a = w[0] || "", b = w[1] || "";
  if (isVowel(a)) return a;
  if (a && b && !isVowel(a) && isVowel(b)) return a + b;
  return w.slice(0, Math.min(2, w.length));
}

function playWordAudio(word) {
  const raw = (word || "").toLowerCase().trim();
  const wordNorm = normalizeName(word);
  const syllNorm = normalizeName(firstSyllable(word));

  const candidates = [
    `audio/${encodeURIComponent(raw)}.mp3`,
    `audio/${encodeURIComponent(raw)}.wav`,
    `audio/${wordNorm}.mp3`,
    `audio/${wordNorm}.wav`,
    `audio/${syllNorm}.mp3`,
    `audio/${syllNorm}.wav`,
  ];

  const btn = playBtn;
  const label = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'üîä Reproduciendo‚Ä¶';

  let i = 0;
  const tryNext = () => {
    if (i >= candidates.length) {
      btn.disabled = false;
      btn.textContent = label;
      console.warn('No audio found for:', word, candidates);
      return;
    }
    const src = candidates[i++];
    const a = new Audio(src);
    a.playsInline = true;
    a.onended = () => { btn.disabled = false; btn.textContent = label; };
    a.onerror = () => tryNext();
    const p = a.play();
    if (p && typeof p.then === 'function') p.catch(() => tryNext());
  };
  tryNext();
}
</script>

<script src="https://cdn.webrtc-experiment.com/RecordRTC.js"></script>

<script>
let recorder, stream;
window.allowSliderDraw = true;

const startBtn = document.getElementById("startRecording");
const stopBtn = document.getElementById("stopRecording");
const previewContainer = document.getElementById("previewContainer");

startBtn.onclick = async () => {
  startBtn.disabled = true;
  stopBtn.disabled = false;
  previewContainer.innerHTML = "";

  const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const canvasStream = canvas.captureStream(30);
  const combinedStream = new MediaStream([
    ...canvasStream.getVideoTracks(),
    ...audioStream.getAudioTracks()
  ]);

  recorder = RecordRTC(combinedStream, {
    type: 'video',
    mimeType: 'video/webm',
    disableLogs: true
  });

  const readyText = document.getElementById("readyMessage");
  readyText.textContent = "üé¨ Get ready...";

  setTimeout(() => {
    recorder.startRecording();
    readyText.textContent = "";
    window.allowSliderDraw = false;
    setTimeout(() => { window.allowSliderDraw = true; drawCanvas(); }, 200);
  }, 600);
};

stopBtn.onclick = () => {
  stopBtn.disabled = true;
  startBtn.disabled = false;
  recorder.stopRecording(() => {
    const blob = recorder.getBlob();
    const videoURL = URL.createObjectURL(blob);
    const video = document.createElement("video");
    video.src = videoURL;
    video.controls = true;
    video.style.maxWidth = "100%";
    previewContainer.innerHTML = "";
    previewContainer.appendChild(video);
    stream?.getTracks().forEach(t => t.stop());
  });
};
</script>

<script>
let recorder2, stream2;

const startBtn2 = document.getElementById("startRecording");
const stopBtn2 = document.getElementById("stopRecording");
const previewContainer2 = document.getElementById("previewContainer");

startBtn2.onclick = async () => {
  startBtn2.disabled = true;
  stopBtn2.disabled = false;
  previewContainer2.innerHTML = "";

  const audio = await navigator.mediaDevices.getUserMedia({ audio: true });
  const canvasStream = canvas.captureStream(30);
  stream2 = new MediaStream([...canvasStream.getVideoTracks(), ...audio.getAudioTracks()]);

  recorder2 = RecordRTC(stream2, {
    type: 'video',
    mimeType: 'video/webm',
    disableLogs: true
  });
  
  const readyText = document.getElementById("readyMessage");
  readyText.textContent = "üé¨ Get ready...";

  setTimeout(() => {
    recorder2.startRecording();
    readyText.textContent = "";
    window.allowSliderDraw = false;
    setTimeout(() => { window.allowSliderDraw = true; drawCanvas(); }, 200);
  }, 600);
};

stopBtn2.onclick = () => {
  stopBtn2.disabled = true;
  startBtn2.disabled = false;
  recorder2.stopRecording(() => {
    const blob = recorder2.getBlob();
    const videoURL = URL.createObjectURL(blob);
    const video = document.createElement("video");
    video.src = videoURL;
    video.controls = true;
    video.style.maxWidth = "100%";
    previewContainer2.innerHTML = "";
    previewContainer2.appendChild(video);
    stream2.getTracks().forEach(t => t.stop());
  });
};
</script>

<script>
/* connect toggle to UI */
function setSpellingMode(on) {
  spellingMode = !!on;
  if (spellingPanel) spellingPanel.style.display = spellingMode ? "block" : "none";
  resetSpellingUI();
  drawCanvas();
  if (spellingMode && spellingInput) spellingInput.focus();
}
</script>

</body>
</html>
