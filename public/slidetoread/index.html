
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spanish Reading Game</title>

  <!-- Andika Font -->
  <link href="https://fonts.googleapis.com/css2?family=Andika&display=swap" rel="stylesheet">
  <!-- Supabase client -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <style>
    body {
      background-color: white;
      font-family: 'Andika', sans-serif;
      text-align: center;
      user-select: none;
      margin: 6px;
    }

    canvas {
      border: 1px solid #ddd;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      margin-bottom: 10px;
      display: inline-block;
      max-width: 100%;
      height: auto; /* responsive */
    }
    select, button {
      font-size: 15px;
      padding: 4px 8px;
      margin: 2px;
    }

    #controls { margin: 4px 0; }

    #modeBar{
      margin: 4px auto;
      display:flex;
      justify-content:center;
      align-items:center;
      flex-wrap:nowrap;
      gap:6px;
    }

    #tileRack{
      display:none;
      max-width: 900px;
      margin: 0 auto 10px;
      padding: 6px;
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:8px;
    }
    .tileBtn{
      font-family:'Andika', sans-serif;
      font-size:22px;
      padding:10px 14px;
      border:2px solid #111;
      background:#fff;
      border-radius:14px;
      cursor:pointer;
      min-width:54px;
    }
    .tileBtn:disabled{
      opacity:.35;
      cursor:not-allowed;
    }
    #hintLine{
      font-size:14px;
      color:#666;
      margin-top:4px;
    }
  </style>
</head>
<body>
  <h2>Spanish Reading Game</h2>
  <div id="syncStatus" style="display:none"></div>

  <select id="wordListSelect">
    <option value="" selected disabled>Selecciona una lista</option>
  </select>
  
  <select id="moduleSelect">
    <option value="M1">M√≥dulo 1</option>
    <option value="M2">M√≥dulo 2</option>
    <option value="M3">M√≥dulo 3</option>
    <option value="M4">M√≥dulo 4</option>
    <option value="M5">M√≥dulo 5</option>
    <option value="M6">M√≥dulo 6</option>
    <option value="M7">M√≥dulo 7</option>
    <option value="M8">M√≥dulo 8</option>
  </select>


  <div id="controls">
    <button id="playAudio" disabled>üîä Play Audio</button>
    <button id="prevWord">‚üµ Prev</button>
    <button id="nextWord">Next ‚ü∂</button>
  </div>

  <!-- NEW: mode bar (does not affect sync / reading) -->
  <div id="modeBar">
    <label style="font-size:18px;">Modo:</label>
    <select id="gameModeSelect">
      <option value="read" selected>üìñ Leer (Slider)</option>
      <option value="spell_kb">‚å®Ô∏è Deletrear (Teclado)</option>
      <option value="spell_tiles">üß© Deletrear (Fichas)</option>
    </select>

    <select id="tileModeSelect" style="display:none;">
      <option value="exact" selected>Fichas: Exactas</option>
      <option value="vowels">Fichas: Consonantes + Vocales</option>
      <option value="distractors">Fichas: + Distractores</option>
    </select>

    <button id="submitSpell" disabled>‚úÖ Submit</button>
    <button id="backspaceSpell" disabled>‚å´</button>
    <button id="clearSpell" disabled>üßΩ Clear</button>
  </div>
  <div id="hintLine"></div>

  <div id="tileRack"></div>

  <canvas id="wordCanvas" width="768" height="432"></canvas>

  <div id="recording-controls">
    <button id="startRecording">üéô Start Recording</button>
    <button id="stopRecording" disabled>‚èπ Stop Recording</button>
  </div>

  <div id="readyMessage" style="font-size: 24px; margin-top: 10px; color: #555;"></div>
  <div id="previewContainer"></div>

  <!-- hidden input to capture keyboard typing in spelling mode -->
  <input id="spellInput" autocomplete="off" autocapitalize="none" spellcheck="false"
         style="position:absolute; left:-9999px; top:-9999px;" />

<script>
/* ==================== SUPABASE CONFIG (group sync) ==================== */
/* Same project as student-work / lettersort */
const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";

const sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
// ==================== Supabase lists + presets ====================
let ALL_LISTS = {};
let ALL_PRESETS = {};

// ---- LOCAL FALLBACK LISTS (used if Supabase fails) ----
const LOCAL_FALLBACK_LISTS = {
  "1. s√≠labas": [],
  "2. palabras": [],
  "CVC": []
};

  
async function loadAppData() {
  const base = SUPABASE_URL + "/storage/v1/object/public/app-presets/slidetoread";

  const [listsRes, presetsRes] = await Promise.all([
    fetch(`${base}/lists.json`),
    fetch(`${base}/presets.json`)
  ]);

  ALL_LISTS = await listsRes.json();
  ALL_PRESETS = await presetsRes.json();
}

// URL params: ?role=teacher&group=A or ?role=student&group=A
const qs = new URLSearchParams(location.search);
// Optional inline word override: ?words=ma,me,mi,mo,mu
const WORDS_OVERRIDE =
  (qs.get('words') || '')
    .split(',')
    .map(w => w.trim())
    .filter(Boolean);

const ROLE = (qs.get('role') || '').toLowerCase();     // 'teacher' or 'student'
const GROUP_CODE = (qs.get('group') || '').toUpperCase();
const isTeacher = ROLE === 'teacher' && !!GROUP_CODE;
const isStudent = ROLE === 'student' && !!GROUP_CODE;

const syncStatusEl = document.getElementById('syncStatus');
if (syncStatusEl) {
  if (!ROLE || !GROUP_CODE) {
    syncStatusEl.textContent = "Modo local: usa ?role=teacher&group=A o ?role=student&group=A en la URL para sincronizar.";
  } else if (isTeacher) {
    syncStatusEl.textContent = `Modo MAESTRO ‚Äî Grupo ${GROUP_CODE}. Usa Prev/Next para guiar.`;
  } else if (isStudent) {
    syncStatusEl.textContent = `Modo ESTUDIANTE ‚Äî Grupo ${GROUP_CODE}. Seguir√° al maestro.`;
  } else {
    syncStatusEl.textContent = "Modo local (role/group no v√°lidos).";
  }
}

/** Make sure a reading_groups row exists for this group_code. */
async function ensureReadingGroup(groupCode) {
  if (!groupCode) return null;

  const { data, error } = await sbClient
    .from('reading_groups')
    .select('*')
    .eq('group_code', groupCode)
    .maybeSingle();

  // PGRST116 = no rows
  if (error && error.code !== 'PGRST116') {
    console.warn('ensureReadingGroup error', error);
    return null;
  }

  if (!data) {
    const { data: inserted, error: insertErr } = await sbClient
      .from('reading_groups')
      .insert({ group_code: groupCode, current_index: 0 })
      .select()
      .single();
    if (insertErr) {
      console.warn('insert reading_group error', insertErr);
      return null;
    }
    return inserted;
  }

  return data;
}

/** Teacher: set the current word index for a group. */
async function setReadingIndex(groupCode, index) {
  if (!groupCode) return null;
  const { data, error } = await sbClient
    .from('reading_groups')
    .update({ current_index: index })
    .eq('group_code', groupCode)
    .select('current_index')
    .single();

  if (error) {
    console.warn('setReadingIndex error', error);
    return null;
  }
  console.log('[TEACHER] set index', groupCode, index);
  return data.current_index;
}

/** Student: get current word index for a group. */
async function getReadingIndex(groupCode) {
  if (!groupCode) return null;
  const { data, error } = await sbClient
    .from('reading_groups')
    .select('current_index')
    .eq('group_code', groupCode)
    .single();

  if (error) {
    if (error.code !== 'PGRST116') {
      console.warn('getReadingIndex error', error);
    }
    return null;
  }
  return data.current_index;
}

/* ==================== Deterministic shuffle + session ==================== */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
function shuffleWithSeed(array, seedStr) {
  const seedFn = xmur3(seedStr);
  const rng = mulberry32(seedFn());
  const arr = array.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function makeSessionId() {
  if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
  return (Date.now().toString(36) + "-" + Math.random().toString(36).slice(2));
}
async function fetchSupabaseLists() {
  try {
    const { data, error } = await sbClient
      .storage
      .from("app-presets")
      .download("slidetoread/lists.json");

    if (error || !data) return null;

    const text = await data.text();
    return JSON.parse(text);
  } catch {
    return null;
  }
}

/* Ensure this exists before first draw */
if (window.allowSliderDraw === undefined) {
  window.allowSliderDraw = true;
}

/* ==================== Canvas + responsive scaling ==================== */
const canvas = document.getElementById("wordCanvas");
const ctx = canvas.getContext("2d");

let words = [], currentWordIndex = 0;
let sliderX = 0, isDragging = false, sliderStart, sliderEnd;
let freshWord = false;

let letters = [];
let pollTimer = null; // for student polling
let activeRow = 0;
let rowCount = 1;
let rowWidths = [];



const DPR = window.devicePixelRatio || 1;
const BASE_W = 768, BASE_H = 432, BASE_AR = BASE_H / BASE_W;
let isDesktop = window.innerWidth >= 1100;


function resizeCanvas() {
  const maxWidth = isDesktop ? 1200 : 768;
  const width = Math.min(window.innerWidth * 0.95, maxWidth);


  // allow taller canvas on phones
  const maxHeight = window.innerHeight * 0.72;

  let height = width * 0.6; // desktop-ish default

  if (window.innerHeight > window.innerWidth) {
    // portrait phones: much taller
    height = Math.min(window.innerHeight * 0.5, width * 1.1);
  }

  height = Math.min(height, maxHeight);

  canvas.style.width = width + "px";
  canvas.style.height = height + "px";

  canvas.width = Math.round(width * DPR);
  canvas.height = Math.round(height * DPR);

  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  if (words.length) setupWord(words[currentWordIndex]);
  else ctx.clearRect(0, 0, canvas.width, canvas.height);
}


window.addEventListener("resize", () => {
  isDesktop = window.innerWidth >= 1100;
  requestAnimationFrame(resizeCanvas);
});

window.addEventListener("orientationchange", () => requestAnimationFrame(resizeCanvas));
document.addEventListener("DOMContentLoaded", resizeCanvas);

/* ==================== UI & Data ==================== */
const playBtn = document.getElementById("playAudio");
const modeSel = document.getElementById("gameModeSelect");
const tileModeSel = document.getElementById("tileModeSelect");
const tileRack = document.getElementById("tileRack");
const submitSpellBtn = document.getElementById("submitSpell");
const clearSpellBtn = document.getElementById("clearSpell");
const backspaceSpellBtn = document.getElementById("backspaceSpell");
const hintLine = document.getElementById("hintLine");
const spellInput = document.getElementById("spellInput");

// Hide list + navigation when using inline words
// Hide list selector when using inline words
if (WORDS_OVERRIDE.length) {
  const listSel = document.getElementById("wordListSelect");
  if (listSel) listSel.style.display = "none";
}



document.getElementById("wordListSelect").addEventListener("change", loadWordList);
document.getElementById("moduleSelect").addEventListener("change", loadWordList);
document.getElementById("nextWord").addEventListener("click", () => changeWord(1));
document.getElementById("prevWord").addEventListener("click", () => changeWord(-1));

playBtn.addEventListener("click", () => {
  if (!words.length) return;
  playWordAudio(words[currentWordIndex]);
});

modeSel.addEventListener("change", () => {
  gameMode = modeSel.value; // 'read'|'spell_kb'|'spell_tiles'
  configureModeUI();
  resetSpellingState(true);
  drawCanvas();
});

tileModeSel.addEventListener("change", () => {
  if (gameMode === 'spell_tiles') {
    resetSpellingState(true);
    buildTilesForCurrentWord();
    drawCanvas();
  }
});

submitSpellBtn.addEventListener("click", () => submitSpelling());
clearSpellBtn.addEventListener("click", () => resetSpellingState(false));
backspaceSpellBtn.addEventListener("click", () => spellingBackspace());

/* ==================== NEW: Game mode state ==================== */
let gameMode = 'read';

/* spelling state */
let targetWordRaw = "";
let targetGraphemes = [];      // correct graphemes (digraphs as 1)
let userGraphemes = [];        // filled graphemes (same length as target)
let cursorSlot = 0;
let spellingSubmitted = false;
let perSlotCorrect = [];       // booleans after submit
let pendingDigraph = null;     // { expected: 'ch', first:'c' } etc

/* tiles */
let tiles = [];                // array of tile strings displayed
let tilesUsed = [];            // boolean per tile

function configureModeUI(){
  
  if (gameMode !== 'read' && pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }
  
  const inSpelling = (gameMode !== 'read');
  tileModeSel.style.display = (gameMode === 'spell_tiles') ? 'inline-block' : 'none';
  tileRack.style.display = (gameMode === 'spell_tiles') ? 'flex' : 'none';

  submitSpellBtn.disabled = !inSpelling;
  clearSpellBtn.disabled = !inSpelling;
  backspaceSpellBtn.disabled = !inSpelling;

  hintLine.textContent = (gameMode === 'read')
    ? ""
    : (isStudent && GROUP_CODE)
      ? "Modo pr√°ctica: el maestro controla Prev/Next. T√∫ puedes deletrear aqu√≠."
      : "Deletrea la palabra. No hay pistas.";

  // focus keyboard input when in kb mode
  if (gameMode === 'spell_kb') {
    setTimeout(() => spellInput.focus(), 50);
  }
}

/* ==================== Load list (unchanged behavior) ==================== */
/* ==================== Module auto-builder ==================== */

function buildModuleAll(modules) {
  const ordered = Object.keys(modules).sort(); // M1,M2,M3...
  let running = [];

  ordered.forEach(k => {
    const entry = modules[k];

    let fresh = [];

    if (Array.isArray(entry)) fresh = entry;
    else if (entry.new) fresh = entry.new;

    running = running.concat(fresh);

    modules[k].all = Array.from(new Set(running));
  });

  return modules;
}


  let baseWordsForDistractors = []; // keep raw list for mode 3 distractors

async function loadWordList() {
    // --- Step 1: inline words override ---
  if (WORDS_OVERRIDE.length) {
  const doShuffle = qs.get('shuffle');
  const seed = qs.get('seed') || '';

  if (doShuffle) {
    if (seed) {
      words = shuffleWithSeed(WORDS_OVERRIDE, seed);
    } else {
      words = WORDS_OVERRIDE.slice().sort(() => Math.random() - 0.5);
    }
  } else {
    words = WORDS_OVERRIDE.slice();
  }


  currentWordIndex = 0;


    document.fonts.ready.then(async () => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;

      if (isTeacher && GROUP_CODE) {
        await setReadingIndex(GROUP_CODE, currentWordIndex);
      }
      if (isStudent && GROUP_CODE) {
        startStudentPolling();
      }
    });

    return; // skip normal txt loading
  }
  // --- Step 2: Supabase preset support ---
  const presetId = qs.get('preset');
  if (presetId && ALL_PRESETS[presetId]) {

    const P = ALL_PRESETS[presetId];

    if (P.words) {
      words = P.words.split(",").map(w => w.trim()).filter(Boolean);
    } else if (P.list) {
      words = (ALL_LISTS[P.list] || []).slice();
    }

    if (P.shuffle) {
      words.sort(() => Math.random() - 0.5);
    }

    currentWordIndex = 0;

    document.fonts.ready.then(() => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;
    });

    const listSel = document.getElementById("wordListSelect");
    if (listSel) listSel.style.display = "none";

    return;
  }

  const listName = document.getElementById("wordListSelect").value;
  // ---- try Supabase first ----
const supaLists = await fetchSupabaseLists();
if (supaLists && Array.isArray(supaLists[listName])) {

  words = supaLists[listName].slice();
  currentWordIndex = 0;

  document.fonts.ready.then(async () => {
    setupWord(words[currentWordIndex]);
    playBtn.disabled = false;

    if (isTeacher && GROUP_CODE) {
      await setReadingIndex(GROUP_CODE, currentWordIndex);
    }
    if (isStudent && GROUP_CODE) {
      startStudentPolling();
    }
  });

  return;
}

if (supaLists?.[listName]) {


  // If you later add modules, you can build "all" arrays here.
  // For now this line is harmless if buildModuleAll doesn't exist yet.
  Object.keys(supaLists).forEach(k => {
    if (supaLists[k] && !Array.isArray(supaLists[k])) {
      buildModuleAll(supaLists[k]);
    }
  });



  const entry = supaLists[listName];

  // If S√≠labas chosen, default to Module M1
  let resolvedEntry = entry;
  
  if (listName === "S√≠labas") {
    const moduleSel = document.getElementById("moduleSelect");
    const mod = moduleSel ? moduleSel.value : "M1";
    resolvedEntry = entry[mod] || entry["M1"];
  }


  
  if (Array.isArray(resolvedEntry)) {
    words = resolvedEntry.slice();
  } else if (resolvedEntry.all) {
    words = resolvedEntry.all.slice();
  } else if (resolvedEntry.new) {
    words = resolvedEntry.new.slice();
  } else {
    words = [];
  }


  currentWordIndex = 0;

  document.fonts.ready.then(async () => {
    setupWord(words[currentWordIndex]);
    playBtn.disabled = false;

    if (isTeacher && GROUP_CODE) {
      await setReadingIndex(GROUP_CODE, currentWordIndex);
    }
    if (isStudent && GROUP_CODE) {
      startStudentPolling();
    }
  });

  return; // stop here if Supabase succeeded
}

  const url = `wordlists/${encodeURIComponent(listName)}.txt`;

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`No encontrado: ${url}`);
    const data = await response.text();
    let baseWords = data.trim().split("\n").map(w => w.trim()).filter(Boolean);
    baseWordsForDistractors = baseWords.slice();

    if (GROUP_CODE && (isTeacher || isStudent)) {
      await ensureReadingGroup(GROUP_CODE);

      if (isTeacher) {
        const sessionId = makeSessionId();
        const { error: sessErr } = await sbClient
          .from('reading_groups')
          .update({ session_id: sessionId, current_index: 0 })
          .eq('group_code', GROUP_CODE);
        if (sessErr) console.warn('update session_id error', sessErr);

        const seedStr = `${GROUP_CODE}::${listName}::${sessionId}`;
        words = shuffleWithSeed(baseWords, seedStr);
        currentWordIndex = 0;
        console.log('[SYNC] teacher session', GROUP_CODE, listName, sessionId, words);
      } else if (isStudent) {
        const { data: row, error: rowErr } = await sbClient
          .from('reading_groups')
          .select('session_id, current_index')
          .eq('group_code', GROUP_CODE)
          .maybeSingle();

        if (!rowErr && row && row.session_id) {
          const seedStr = `${GROUP_CODE}::${listName}::${row.session_id}`;
          words = shuffleWithSeed(baseWords, seedStr);
          currentWordIndex = row.current_index ?? 0;
          console.log('[SYNC] student using session', GROUP_CODE, listName, row.session_id, 'index', currentWordIndex);
        } else {
          words = baseWords.sort(() => Math.random() - 0.5);
          currentWordIndex = 0;
          console.log('[SYNC] student fallback random (no session_id yet)');
        }
      }
    } else {
      words = baseWords.sort(() => Math.random() - 0.5);
      currentWordIndex = 0;
    }

    document.fonts.ready.then(async () => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;

      if (isTeacher && GROUP_CODE) {
        await setReadingIndex(GROUP_CODE, currentWordIndex);
      }
      if (isStudent && GROUP_CODE) {
        startStudentPolling();
      }
    });
  } catch (err) {
    console.warn(err);
    alert(`No pude cargar "${url}". Verifica el nombre y las may√∫sculas/min√∫sculas en GitHub Pages.`);
  }
}

async function startStudentPolling() {
  if (!isStudent || !GROUP_CODE) return;
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }

  const doPoll = async () => {
    const idx = await getReadingIndex(GROUP_CODE);
    if (idx == null) return;
    if (!words.length) return;
    if (idx === currentWordIndex) return;
    if (idx < 0 || idx >= words.length) return;

    console.log('[STUDENT] applying index from teacher', idx);
    currentWordIndex = idx;
    document.fonts.ready.then(() => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;
    });
  };

  await doPoll();
  pollTimer = setInterval(doPoll, 2000);
}

function changeWord(direction) {
  if (!words.length) return;

  // keep teacher-only guidance in sync mode
  if (isStudent && GROUP_CODE) return;

  currentWordIndex = (currentWordIndex + direction + words.length) % words.length;
  document.fonts.ready.then(() => {
    setupWord(words[currentWordIndex]);
    playBtn.disabled = false;
  });

  if (isTeacher && GROUP_CODE) {
    setReadingIndex(GROUP_CODE, currentWordIndex);
  }
}

/* ==================== Grapheme parsing (digraphs are ONE) ==================== */
function parseWord(word) {
  const digraphs = ["ch", "ll", "rr", "qu"];
  const out = [];
  const w = (word || "");

  for (let i = 0; i < w.length;) {
    const ch = w[i];

    // ‚úÖ treat spaces as layout separators (not letters)
    if (ch === " ") {
      out.push({ text: " ", isSpace: true });
      i++;
      continue;
    }
    // ‚úÖ skip punctuation entirely (no pills, no width)
    if (/[.,!?;]/.test(ch)) {
      out.push({ text: ch, isPunctuation: true });
      i++;
      continue;
    }


    const lower = w.toLowerCase();
    const dg = digraphs.find(d => lower.startsWith(d, i));

    if (dg) {
      out.push({ text: dg, soundType: getSoundType(dg) });
      i += dg.length;
    } else {
      out.push({ text: w[i], soundType: getSoundType(lower[i], lower[i+1]) });
      i++;
    }
  }

  return out;
}
function groupIntoWords(letters){
  const out = [];
  let current = [];

  letters.forEach(l => {
    if (l.isSpace){
      if (current.length) out.push(current);
      current = [];
    } else {
      current.push(l);
    }
  });

  if (current.length) out.push(current);
  return out;
}


function getSoundType(letter, nextLetter = "") {
  if (letter === "c") return /[ei]/.test(nextLetter) ? "continuous" : "stop";
  if (["p","t","k","b","d","g","ch"].includes(letter)) return "stop";
  if (letter === "h") return "silent";
  return "continuous";
}

/* ==================== Word setup (keeps original reading behavior) ==================== */
function setupWord(word) {
  const baseFont = 80;
  const scaledFont = Math.round(baseFont * (canvas.clientWidth / 768));
  const fontPx = Math.max(36, scaledFont); // remove upper clamp
  ctx.font = `bold ${fontPx}px Andika`;


  letters = parseWord(word);

  const padding = 6; // tighter between letters
  const em = fontPx;
  
  // much smaller minimum + much smaller side padding
  const minPill = Math.max(8, Math.round(em * 0.22));
  const innerPad = Math.max(2, Math.round(em * 0.03));


  letters.forEach(l => {

    // punctuation gets ZERO width
    if (l.isPunctuation) {
      l.gw = 0;
      l.w = 0;
      return;
    }
  
    let gw = ctx.measureText(l.text).width;
    
    // iPhone / small screens: compress glyph width
    if (window.innerWidth < 700) {
      gw *= 0.65;
    }
    
    l.gw = gw;
    l.w = Math.max(gw + innerPad * 2, minPill);

  });


  const totalWidth = letters.reduce((s, l) => s + l.w, 0) + padding * (letters.length - 1);

  sliderStart = (canvas.clientWidth - totalWidth) / 2;
  sliderEnd   = sliderStart + totalWidth;

  sliderX = sliderStart;
  activeRow = 0;
  freshWord = true;



  // NEW: reset spelling state when word changes
  resetSpellingState(true);
  if (gameMode === 'spell_tiles') buildTilesForCurrentWord();

  drawCanvas();
}

/* ==================== Reading draw (UNCHANGED visuals) ==================== */
function drawReading() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

const usableW = canvas.clientWidth;
const usableH = canvas.clientHeight;

// scale from the smaller dimension (phone safe)
const scale = Math.min(usableW / 768, usableH / 432);

let baseFont = isDesktop ? 64 : 52;

let fontPx = Math.round(baseFont * scale * (isDesktop ? 1.5 : 1));


// hard safety clamps
const maxFont = isDesktop ? 130 : 72;
fontPx = Math.max(26, Math.min(maxFont, fontPx));



ctx.textAlign = "center";

// auto-shrink until rows fit vertically
while (!isDesktop && fontPx > 28) {
  ctx.font = `bold ${fontPx}px Andika`;
  // recompute glyph + pill widths with FINAL font size
  const em = fontPx;
  const minPill = Math.max(8, Math.round(em * 0.22));
  const innerPad = Math.max(2, Math.round(em * 0.03));


  
  letters.forEach(l => {
    if (l.isPunctuation) {
      l.gw = 0;
      l.w = 0;
      return;
    }
    if (l.isSpace) return;
  
    let gw = ctx.measureText(l.text).width;

    if (window.innerWidth < 700) {
      gw *= 0.65;
    }
    
    l.gw = gw;
    l.w = Math.max(gw + innerPad * 2, minPill);

  });

  const testRowStep = fontPx * 1.9;
  const maxRowsGuess = Math.ceil(letters.length / 4); // safe upper bound
  const needed = maxRowsGuess * testRowStep;

  if (needed < canvas.clientHeight * 0.8) break;
  fontPx -= 2;
}

ctx.font = `bold ${fontPx}px Andika`;
// ===== DESKTOP: shrink sentences + recompute widths =====
if (isDesktop) {

  const maxRowWidth = canvas.clientWidth * 0.9;

  let xTest = 0;
  let rows = 1;

  letters.forEach(l => {
    if (l.isSpace) {
      xTest += fontPx * 0.4;
      return;
    }
    xTest += l.w;
    if (xTest > maxRowWidth) {
      rows++;
      xTest = l.w;
    }
  });

  if (rows > 1) {

    // shrink sentence
    fontPx = Math.round(fontPx * 0.55);
    ctx.font = `bold ${fontPx}px Andika`;

    // üîë recompute glyph + pill widths using NEW font
    const em = fontPx;
    const minPill = Math.max(8, Math.round(em * 0.22));
    const innerPad = Math.max(2, Math.round(em * 0.03));

    letters.forEach(l => {
      if (l.isPunctuation) {
        l.gw = 0;
        l.w = 0;
        return;
      }
      if (l.isSpace) return;

      let gw = ctx.measureText(l.text).width;
      l.gw = gw;
      l.w = Math.max(gw + innerPad * 2, minPill);
    });
  }
}



  const padding = Math.max(2, Math.round(fontPx * 0.005));   // tighter letters
  const wordGap = padding * 12;                             // clearer word breaks

  const pillH = Math.max(8, Math.round(fontPx * 0.10));


  const textY = 0; // no-op, keeps your file stable
  const realTextY = Math.round(fontPx * 1.25);
  const pillY = realTextY + Math.max(16, Math.round(fontPx * 0.5));

  function pillRadius(w, h) {
    return Math.max(2, Math.min(10, h / 2, w / 2 - 1));
  }

  const maxRowWidth = canvas.clientWidth * 0.9;
  const rowLeft = (canvas.clientWidth - maxRowWidth) / 2;
  let x = rowLeft;

  let row = 0;
  const baseRowStep = fontPx * 1.6;   // tighter normal spacing
  const sliderClearance = pillH + fontPx * 0.9; // space needed for slider
  
  function rowY(r){
    // rows below active get pushed down
    const push = r > activeRow ? sliderClearance : 0;
    return startY + r * baseRowStep + push;
  }


  rowWidths = [];
  rowWidths[0] = 0;


  const wordsBlocks = groupIntoWords(letters);





  // ================= CENTER WRAPPED ROWS =================
const totalRows = row + 1;
rowCount = totalRows;
const blockHeight = totalRows * baseRowStep + sliderClearance;


const isPortrait = window.innerHeight > window.innerWidth;

// phones anchor near top, desktop gently centered
const startY = isPortrait
  ? Math.round(fontPx * 0.4)
  : Math.max(Math.round(fontPx * 0.25), (canvas.clientHeight - blockHeight) / 3.5);

ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = "white";
ctx.fillRect(0, 0, canvas.width, canvas.height);

x = rowLeft;

row = 0;

rowWidths = [];
x = rowLeft;
row = 0;

wordsBlocks.forEach(block => {

  const blockWidth =
    block.reduce((s,l)=>s+l.w,0) +
    padding * (block.length-1);

  if (x + blockWidth > rowLeft + maxRowWidth && rowWidths[row] > 0){
    row++;
    x = rowLeft;
  }

  block.forEach(letter => {

    if (letter.isPunctuation) {
      const yText = rowY(row) + realTextY;
    
      // tiny visual width so slider can pass it
      const pw = Math.max(10, ctx.measureText(letter.text).width);
    
      ctx.fillStyle = (row === activeRow && sliderX >= x + 1) ? "black" : "lightgrey";
      ctx.fillText(letter.text, x + pw / 2, yText);
    
      x += pw + padding;
      return;
    }




    const yText = rowY(row) + realTextY;
    const yPill = rowY(row) + pillY;
    const pillW = letter.w;

    ctx.fillStyle = (row === activeRow && sliderX >= x + 1) ? "black" : "lightgrey";
    if (letter.text === "h" && letter.soundType === "silent") ctx.fillStyle = "#ccc";

    ctx.fillText(letter.text, x + pillW / 2, yText);

    if (row === activeRow) {

      // draw pills ONLY on active row
    if (row === activeRow) {
    
      ctx.strokeStyle =
        letter.soundType === "silent" ? "#aaa" :
        letter.soundType === "stop" ? "red" : "green";
    
      ctx.lineWidth = 3;
      ctx.fillStyle = (sliderX >= x + 1) ? ctx.strokeStyle : "white";
    
      const r = pillRadius(pillW, pillH);
      roundRect(x, yPill, pillW, pillH, r, true, true);
    }

    }


    x += pillW + padding;
  });

  // RECORD ACTUAL ROW WIDTH HERE
  rowWidths[row] = Math.max(rowWidths[row] || 0, x - rowLeft);
  
  // only add gap if NOT last block
  if (block !== wordsBlocks[wordsBlocks.length - 1]) {
    x += wordGap;
  }

});

  
  rowCount = row + 1;   // üëà total wrapped rows
  activeRow = Math.min(activeRow, rowCount - 1);




  const sliderGap = Math.round(fontPx * 0.9);
  
  const lineY =
    rowY(activeRow) +
    pillY +
    pillH +
    sliderGap;



  const thisRowWidth = rowWidths[activeRow] || maxRowWidth;
  
  ctx.lineCap = "round";
  ctx.strokeStyle = "#ccc";
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(rowLeft, lineY);
  ctx.lineTo(rowLeft + thisRowWidth, lineY);
  ctx.stroke();


  ctx.strokeStyle = "#007bff";
  ctx.beginPath();
  ctx.moveTo(rowLeft, lineY);
  ctx.lineTo(sliderX, lineY);
  ctx.stroke();

  ctx.beginPath();
  ctx.fillStyle = "#007bff";
  ctx.arc(sliderX, lineY, 10, 0, Math.PI * 2);
  ctx.fill();
 
  sliderStart = rowLeft;
  sliderEnd = rowLeft + thisRowWidth;
  
  sliderX = Math.min(Math.max(sliderX, sliderStart), sliderEnd);



}

/* ==================== NEW: Spelling renderer (syllable boxes + underlines) ==================== */
function isVowelChar(ch){
  return /[aeiou√°√©√≠√≥√∫√º]/i.test(ch || "");
}
function normalizeForGrade(s){
  // accept accents but preserve √± as distinct (important)
  let x = (s || "").toLowerCase();
  x = x.replace(/√±/g, "__ENYE__");
  x = x.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  x = x.replace(/__ENYE__/g, "√±");
  return x;
}

function graphemeIsVowel(g){
  if (!g) return false;
  // digraphs are consonants
  if (g === 'ch' || g === 'll' || g === 'rr' || g === 'qu') return false;
  return isVowelChar(g);
}

function splitIntoSyllables(graphemes){
  // Spanish-ish heuristic: split consonant clusters between vowel nuclei.
  const allowedOnset2 = new Set([
    "bl","br","cl","cr","dr","fl","fr","gl","gr","pl","pr","tr"
  ]);

  const syls = [];
  let i = 0;
  while (i < graphemes.length) {
    // onset
    let onset = [];
    while (i < graphemes.length && !graphemeIsVowel(graphemes[i])) {
      onset.push(graphemes[i]);
      i++;
    }

    // nucleus (at least one vowel grapheme)
    let nucleus = [];
    if (i < graphemes.length && graphemeIsVowel(graphemes[i])) {
      nucleus.push(graphemes[i]);
      i++;
      // keep simple: don't merge diphthongs deeply; one vowel grapheme is enough for now
      // (you can refine later)
      if (i < graphemes.length && graphemeIsVowel(graphemes[i])) {
        nucleus.push(graphemes[i]);
        i++;
      }
    }

    // collect consonants until next vowel to decide split
    let cons = [];
    let j = i;
    while (j < graphemes.length && !graphemeIsVowel(graphemes[j])) {
      cons.push(graphemes[j]);
      j++;
    }

    if (j >= graphemes.length) {
      // end: everything goes to coda
      syls.push(onset.concat(nucleus).concat(cons));
      break;
    }

    // there is another vowel later; decide split of consonant cluster
    if (cons.length === 0) {
      syls.push(onset.concat(nucleus));
      // i stays
    } else if (cons.length === 1) {
      syls.push(onset.concat(nucleus)); // single consonant goes to next onset
    } else if (cons.length === 2) {
      const c1 = (cons[0] || "");
      const c2 = (cons[1] || "");
      const pair = (c1 + c2).replace(/[^a-z√±]/g,'');
      if (allowedOnset2.has(pair)) {
        syls.push(onset.concat(nucleus)); // both to next onset
      } else {
        syls.push(onset.concat(nucleus).concat([cons[0]])); // split
        i += 1; // move one consonant into coda
      }
    } else {
      // 3+ consonants: if last two can be onset, keep them for next syllable
      const last2 = (cons[cons.length-2] + cons[cons.length-1]).replace(/[^a-z√±]/g,'');
      if (allowedOnset2.has(last2)) {
        syls.push(onset.concat(nucleus).concat([cons[0]]));
        i += 1;
      } else {
        syls.push(onset.concat(nucleus).concat(cons.slice(0,2)));
        i += 2;
      }
    }
  }
  return syls;
}

function drawSpelling(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  const graphemes = targetGraphemes.length ? targetGraphemes : letters.map(x=>x.text);
  if (!graphemes.length) return;

  const syls = splitIntoSyllables(graphemes);

  // ---------- FIT LOOP (prevents bottom clipping) ----------
  const baseFont = 64;
  let fontPx = Math.max(24, Math.min(72, Math.round(baseFont * (w / 768))));
  const rows = spellingSubmitted ? 2 : 1;

  function computeLayout(fp){
    ctx.font = `700 ${fp}px Andika`;
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";

    const slotGap = Math.max(10, Math.round(fp * 0.22));   // space between letters
    const sylGap  = Math.max(18, Math.round(fp * 0.55));   // extra space between syllables
    const slotMinW = Math.max(34, Math.round(fp * 0.95));
    const slotInnerPad = Math.max(8, Math.round(fp * 0.20));

    const slotWidths = graphemes.map(g => {
      const display = tileDisplayFor(g);
      const tw = ctx.measureText(display).width;
      return Math.max(slotMinW, Math.round(tw + slotInnerPad*2));
    });

    // syllable boundaries (start/end indices over grapheme slots)
    let idx = 0;
    const sylMeta = syls.map(sg => {
      const start = idx;
      const end = start + sg.length;
      idx = end;
      return { start, end };
    });

    // compute total width with letter gaps + extra syllable gaps
    let totalW = 0;
    for (let i = 0; i < graphemes.length; i++) {
      totalW += slotWidths[i];
      if (i < graphemes.length - 1) totalW += slotGap;
    }
    // add extra syll gaps where syll boundaries occur
    for (let s = 0; s < sylMeta.length - 1; s++) {
      const boundaryIndex = sylMeta[s].end - 1; // after this slot we already counted slotGap
      // replace normal gap with a bigger syll gap by adding the difference
      totalW += (sylGap - slotGap);
    }

    const startX = Math.round((w - totalW) / 2);

    const rowH = Math.round(fp * 2.15);            // enough for letters + underlines
    const gapY = Math.round(fp * 0.70);            // space between attempt row and copy row

    const neededH = (rows * rowH) + ((rows - 1) * gapY) + Math.round(fp * 0.9);
    return { fp, slotGap, sylGap, slotWidths, sylMeta, startX, rowH, gapY, neededH };
  }

  let L = computeLayout(fontPx);
  while (L.neededH > h * 0.92 && fontPx > 22) {
    fontPx -= 2;
    L = computeLayout(fontPx);
  }

  // vertical placement
  const topY = spellingSubmitted ? Math.round(h * 0.10) : Math.round(h * 0.18);

  // Y positions within a row
  const textY = topY + Math.round(L.fp * 0.95);
  const underlineY = textY + Math.round(L.fp * 0.35);          // letter underline
  const sylUnderlineY = underlineY + Math.round(L.fp * 0.28);  // syllable underline BELOW

  function gradeSyllables(){
    // syllable correct if ALL letters in that syll are correct
    const sylCorrect = new Array(L.sylMeta.length).fill(false);
    for (let s = 0; s < L.sylMeta.length; s++){
      const {start, end} = L.sylMeta[s];
      let ok = true;
      for (let i = start; i < end; i++){
        if (!perSlotCorrect[i]) { ok = false; break; }
      }
      sylCorrect[s] = ok;
    }
    return sylCorrect;
  }

  function drawRow(rowTopY, rowLetters, mode){
    // mode:
    // "attempt" = student row (black until submit, then per-slot green/red + syll green/red)
    // "correct" = correct copy (always green)
    ctx.font = `700 ${L.fp}px Andika`;
    ctx.textAlign = "center";

    // precompute x positions per slot, respecting syll gaps
    const slotX = new Array(graphemes.length).fill(0);
    let x = L.startX;
    let sylIndex = 0;
    let nextSylEnd = L.sylMeta[0]?.end ?? graphemes.length;

    for (let i = 0; i < graphemes.length; i++){
      slotX[i] = x;

      x += L.slotWidths[i];

      // decide what gap to add after this slot
      if (i < graphemes.length - 1) {
        if (i === nextSylEnd - 1) {
          // move to next syllable
          sylIndex++;
          nextSylEnd = L.sylMeta[sylIndex]?.end ?? graphemes.length;
          x += L.sylGap;
        } else {
          x += L.slotGap;
        }
      }
    }

    // syllable correctness colors (attempt row after submit)
    const sylCorrect = (mode === "attempt" && spellingSubmitted) ? gradeSyllables() : null;

    // draw letters + letter underlines
    for (let i = 0; i < graphemes.length; i++){
      const sw = L.slotWidths[i];
      const sx = slotX[i];

      const raw = rowLetters[i] || "";
      const display = tileDisplayFor(raw);

      let letterColor = "#111";
      let ulineColor = "#111";

      if (mode === "correct") {
        letterColor = "#16a34a";
        ulineColor = "#16a34a";
      } else {
        // attempt row
        if (!spellingSubmitted) {
          // BEFORE submit: black letters + black underline
          letterColor = (display ? "#111" : "#111");
          ulineColor = "#111";
        } else {
          // AFTER submit: green/red per slot
          const ok = !!perSlotCorrect[i];
          letterColor = ok ? "#16a34a" : "#dc2626";
          ulineColor  = ok ? "#16a34a" : "#dc2626";
        }
      }

      // letter
      ctx.fillStyle = letterColor;
      ctx.fillText(display, sx + sw/2, rowTopY + (textY - topY));

      // letter underline
      ctx.strokeStyle = ulineColor;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(sx + 10, rowTopY + (underlineY - topY));
      ctx.lineTo(sx + sw - 10, rowTopY + (underlineY - topY));
      ctx.stroke();

      // cursor highlight (before submit, attempt row only)
      if (mode === "attempt" && !spellingSubmitted && i === cursorSlot){
        ctx.strokeStyle = "#2563eb";
        ctx.lineWidth = 3;
        roundRect(sx+4, rowTopY + 6, sw-8, Math.round(L.fp*1.45), 12, false, true);
      }
    }

    // draw syllable underlines (spans groups)
    for (let s = 0; s < L.sylMeta.length; s++){
      const {start, end} = L.sylMeta[s];
      const left = slotX[start] + 8;
      const right = slotX[end-1] + L.slotWidths[end-1] - 8;

      let color = "#111";
      if (mode === "correct") {
        color = "#16a34a";
      } else {
        if (!spellingSubmitted) {
          color = "#111";
        } else {
          color = (sylCorrect[s] ? "#16a34a" : "#dc2626");
        }
      }

      ctx.strokeStyle = color;
      ctx.lineWidth = 8;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(left, rowTopY + (sylUnderlineY - topY));
      ctx.lineTo(right, rowTopY + (sylUnderlineY - topY));
      ctx.stroke();
    }
  }

  // TOP row: student attempt
  drawRow(topY, userGraphemes, "attempt");

  if (spellingSubmitted){
    // BOTTOM row: correct copy (same size)
    const correctRaw = (targetWordRaw || words[currentWordIndex] || "").toLowerCase().trim();
    const correctG = parseWord(correctRaw).map(o => o.text);

    const copyTopY = topY + L.rowH + L.gapY;
    drawRow(copyTopY, correctG, "correct");
  } else {
    // instruction line below single row
    ctx.font = `700 ${Math.max(18, Math.round(L.fp*0.50))}px Andika`;
    ctx.fillStyle = "#666";
    const lineY = topY + L.rowH + Math.round(L.fp*0.70);
    ctx.fillText("Escucha y escribe la palabra.", w/2, lineY);
  }
}



/* unified canvas draw */
function drawCanvas() {
  if (!window.allowSliderDraw) return;
  if (gameMode === 'read') drawReading();
  else drawSpelling();
}

/* ==================== Pointer handling (only slider in read mode) ==================== */
canvas.addEventListener("pointerdown", (e)=> {
  if (gameMode !== 'read') return;
  isDragging=true; moveSlider(e);
});
canvas.addEventListener("pointermove", (e)=> {
  if (gameMode !== 'read') return;
  if(isDragging){moveSlider(e);}
});
canvas.addEventListener("pointerup", ()=>{

  isDragging = false;
  drawCanvas();      // recompute rows
  tryAdvanceRow();  // now advance

});


canvas.addEventListener("pointercancel", ()=> {
  isDragging = false;
  drawCanvas();      // recompute rows
  tryAdvanceRow();  // now advance
});



canvas.addEventListener("pointerleave", ()=>isDragging=false);
function tryAdvanceRow() {
  const SNAP = 60;

  if (sliderX >= sliderEnd - SNAP) {

    if (activeRow < rowCount - 1) {
      activeRow++;

      // jump to start of next row
      sliderX = sliderStart;

      // break drag so finger doesn't carry over
      isDragging = false;
    }

    drawCanvas();
  }
}


function moveSlider(e){
  const rect = canvas.getBoundingClientRect();

  sliderX = e.clientX - rect.left;

  // clamp to current row
  sliderX = Math.min(Math.max(sliderX, sliderStart), sliderEnd);

  drawCanvas();      // first: compute rows + sliderEnd
}





function roundRect(x, y, w, h, r, fill, stroke) {
  r = Math.max(0, Math.min(r, w/2, h/2));
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* ==================== AUDIO: use /audio, fallback to first syllable ==================== */
function normalizeName(s) {
  return (s || "")
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z√±√º]+/g, '');
}
function isVowel(ch) { return /[aeiou√°√©√≠√≥√∫]/i.test(ch); }
function firstSyllable(word) {
  const w = (word || "").toLowerCase();
  if (!w) return "";
  const digraphs = ["ch","ll","rr","qu"];
  for (const d of digraphs) {
    if (w.startsWith(d)) {
      const next = w[d.length] || "";
      if (isVowel(next)) return d + next;
      return d;
    }
  }
  const a = w[0] || "", b = w[1] || "";
  if (isVowel(a)) return a;
  if (a && b && !isVowel(a) && isVowel(b)) return a + b;
  return w.slice(0, Math.min(2, w.length));
}

function playWordAudio(word) {
  const raw = (word || "").toLowerCase().trim();
  const wordNorm = normalizeName(word);
  const syllNorm = normalizeName(firstSyllable(word));

  const candidates = [
    `audio/${encodeURIComponent(raw)}.mp3`,
    `audio/${encodeURIComponent(raw)}.wav`,
    `audio/${wordNorm}.mp3`,
    `audio/${wordNorm}.wav`,
    `audio/${syllNorm}.mp3`,
    `audio/${syllNorm}.wav`,
  ];

  const btn = playBtn;
  const label = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'üîä Reproduciendo‚Ä¶';

  let i = 0;
  const tryNext = () => {
    if (i >= candidates.length) {
      btn.disabled = false;
      btn.textContent = label;
      console.warn('No audio found for:', word, candidates);
      return;
    }
    const src = candidates[i++];
    const a = new Audio(src);
    a.playsInline = true;
    a.onended = () => { btn.disabled = false; btn.textContent = label; };
    a.onerror = () => tryNext();
    const p = a.play();
    if (p && typeof p.then === 'function') p.catch(() => tryNext());
  };
  tryNext();
}

/* ==================== NEW: Spelling mechanics (keyboard + tiles) ==================== */
function tileDisplayFor(g){
  // For display in slots, show without accents except √±
  if (!g) return "";
  let x = (g || "").toLowerCase();
  x = x.replace(/√°/g,'a').replace(/√©/g,'e').replace(/√≠/g,'i').replace(/√≥/g,'o').replace(/√∫/g,'u');
  return x;
}

function resetSpellingState(hard){
  spellingSubmitted = false;
  perSlotCorrect = [];
  pendingDigraph = null;

  if (!words.length) return;

  targetWordRaw = (words[currentWordIndex] || "").toLowerCase().trim();
  const g = parseWord(targetWordRaw).map(o=>o.text);

  targetGraphemes = g.slice();
  userGraphemes = new Array(targetGraphemes.length).fill("");
  cursorSlot = 0;

  if (hard){
    tiles = [];
    tilesUsed = [];
    if (gameMode === 'spell_tiles') buildTilesForCurrentWord();
  } else {
    if (gameMode === 'spell_tiles') {
      tilesUsed = new Array(tiles.length).fill(false);
      buildTileRackUI();
    }
  }

  updateSpellButtons();
  drawCanvas();
}

function updateSpellButtons(){
  const inSpell = (gameMode !== 'read');
  submitSpellBtn.disabled = !inSpell;
  clearSpellBtn.disabled = !inSpell;
  backspaceSpellBtn.disabled = !inSpell;

  if (!inSpell) return;

  const allFilled = userGraphemes.every(x => (x || "").length > 0) && !pendingDigraph;
  submitSpellBtn.disabled = !allFilled || spellingSubmitted;

  if (gameMode === 'spell_kb') {
    setTimeout(() => spellInput.focus(), 50);
  }
}

function expectedAtCursor(){
  return targetGraphemes[cursorSlot] || "";
}

function canTypeMore(){
  const allFilled = userGraphemes.every(x => (x || "").length > 0);
  return !spellingSubmitted && (!allFilled || pendingDigraph);
}

function spellingBackspace(){
  if (spellingSubmitted) return;

  if (pendingDigraph){
    userGraphemes[cursorSlot] = "";
    pendingDigraph = null;
    updateSpellButtons();
    drawCanvas();
    return;
  }

  let i = cursorSlot;
  if (i >= targetGraphemes.length) i = targetGraphemes.length - 1;

  if (userGraphemes[i]) {
    userGraphemes[i] = "";
    cursorSlot = i;
    if (gameMode === 'spell_tiles') rebuildTilesFromUser();
  } else {
    for (let j = i-1; j >= 0; j--){
      if (userGraphemes[j]) {
        userGraphemes[j] = "";
        cursorSlot = j;
        if (gameMode === 'spell_tiles') rebuildTilesFromUser();
        break;
      }
    }
  }
  updateSpellButtons();
  drawCanvas();
}

function advanceCursor(){
  let i = cursorSlot;
  while (i < userGraphemes.length && (userGraphemes[i] || "").length > 0) i++;
  cursorSlot = Math.min(i, userGraphemes.length - 1);
}

function submitSpelling(){
  if (spellingSubmitted) return;

  perSlotCorrect = targetGraphemes.map((tg, i) => {
    const u = userGraphemes[i] || "";
    return normalizeForGrade(u) === normalizeForGrade(tg);
  });

  spellingSubmitted = true;
  updateSpellButtons();
  drawCanvas();
}

/* ---------------- keyboard handling (digraphs in ONE slot) ---------------- */
function isAllowedKeyChar(k){
  return /^[a-z√±√°√©√≠√≥√∫√º]$/i.test(k || "");
}

spellInput.addEventListener("keydown", (e) => {
  if (gameMode !== 'spell_kb') return;
  if (!canTypeMore()) { e.preventDefault(); return; }

  const key = e.key;

  if (key === "Backspace") {
    e.preventDefault();
    spellingBackspace();
    return;
  }
  if (key === "Enter") {
    e.preventDefault();
    if (!submitSpellBtn.disabled) submitSpelling();
    return;
  }

  if (!isAllowedKeyChar(key)) return;

  e.preventDefault();

  const ch = key.toLowerCase();
  const expected = expectedAtCursor();

  const digraphs = ["ch","ll","rr","qu"];

  if (digraphs.includes(expected)) {
    if (!pendingDigraph) {
      if (ch === expected[0]) {
        userGraphemes[cursorSlot] = ch;     // temp
        pendingDigraph = { expected, first: ch };
      } else {
        userGraphemes[cursorSlot] = ch;
      }
    } else {
      const wantSecond = expected[1];
      if (ch === wantSecond && userGraphemes[cursorSlot] === pendingDigraph.first) {
        userGraphemes[cursorSlot] = expected;
        pendingDigraph = null;
        cursorSlot = Math.min(cursorSlot + 1, userGraphemes.length - 1);
        advanceCursor();
      } else {
        userGraphemes[cursorSlot] = (userGraphemes[cursorSlot] || "") + ch;
        userGraphemes[cursorSlot] = userGraphemes[cursorSlot].slice(0, 2);
      }
    }
    updateSpellButtons();
    drawCanvas();
    return;
  }

  if (!userGraphemes[cursorSlot]) {
    userGraphemes[cursorSlot] = ch;
    cursorSlot = Math.min(cursorSlot + 1, userGraphemes.length - 1);
    advanceCursor();
  } else {
    advanceCursor();
    if (!userGraphemes[cursorSlot]) {
      userGraphemes[cursorSlot] = ch;
      cursorSlot = Math.min(cursorSlot + 1, userGraphemes.length - 1);
      advanceCursor();
    }
  }

  updateSpellButtons();
  drawCanvas();
});

/* allow tapping canvas to focus keyboard input in kb mode */
canvas.addEventListener("click", () => {
  if (gameMode === 'spell_kb') spellInput.focus();
});

/* ---------------- tile mode ---------------- */
function buildTilesForCurrentWord(){
  if (gameMode !== 'spell_tiles') return;
  const tileMode = tileModeSel.value; // exact | vowels | distractors

  const correct = targetGraphemes.slice();
  const required = correct.map(g => tileDisplayFor(g));

  const vowels = ["a","e","i","o","u"];
  const consonantsFromWord = required.filter(g => !vowels.includes(g) && !graphemeIsVowel(g));

  let pool = [];

  if (tileMode === "exact") {
    pool = required.slice();
  } else if (tileMode === "vowels") {
    pool = consonantsFromWord.slice();
    pool.push(...vowels);
    required.forEach(g => { if (vowels.includes(g)) pool.push(g); });
  } else {
    pool = consonantsFromWord.slice();
    pool.push(...vowels);
    required.forEach(g => { if (vowels.includes(g)) pool.push(g); });

    const distractors = pickDistractorConsonantsFromList(8, new Set(pool));
    pool.push(...distractors);
  }

  pool = pool.filter(Boolean);
  pool = pool.sort(() => Math.random() - 0.5);

  tiles = pool;
  tilesUsed = new Array(tiles.length).fill(false);

  buildTileRackUI();
}

function pickDistractorConsonantsFromList(n, already){
  const vowels = new Set(["a","e","i","o","u"]);
  const set = new Set();

  for (const w of baseWordsForDistractors){
    const gs = parseWord((w||"").toLowerCase().trim()).map(o=>tileDisplayFor(o.text));
    for (const g of gs){
      if (!g) continue;
      if (vowels.has(g)) continue;
      if (!already.has(g)) set.add(g);
    }
  }

  const arr = Array.from(set).sort(() => Math.random() - 0.5);
  return arr.slice(0, n);
}

function buildTileRackUI(){
  if (gameMode !== 'spell_tiles') return;
  tileRack.innerHTML = "";
  tiles.forEach((t, i) => {
    const btn = document.createElement("button");
    btn.className = "tileBtn";
    btn.textContent = t;
    btn.disabled = !!tilesUsed[i] || spellingSubmitted;

    btn.addEventListener("click", () => {
      if (spellingSubmitted) return;
      if (!placeTile(t, i)) return;
      btn.disabled = true;
    });

    tileRack.appendChild(btn);
  });
}

function placeTile(tile, tileIndex){
  if (!canTypeMore()) return false;
  if (pendingDigraph) return false;

  let slot = userGraphemes.findIndex(x => !x);
  if (slot === -1) return false;

  userGraphemes[slot] = tile;
  tilesUsed[tileIndex] = true;

  cursorSlot = slot;
  advanceCursor();

  updateSpellButtons();
  drawCanvas();
  return true;
}

function rebuildTilesFromUser(){
  const placed = userGraphemes.map(g => (g||"").toLowerCase()).filter(Boolean);

  tilesUsed = new Array(tiles.length).fill(false);
  placed.forEach(g => {
    const idx = tiles.findIndex((t, i) => !tilesUsed[i] && t === tileDisplayFor(g));
    if (idx >= 0) tilesUsed[idx] = true;
  });

  buildTileRackUI();
}

/* ==================== Startup ==================== */
(async () => {

  await loadAppData();
  // populate list dropdown (Supabase first, fallback if empty)
  const listSel = document.getElementById("wordListSelect");
  if (listSel) {
  
    const source =
      Object.keys(ALL_LISTS || {}).length
        ? ALL_LISTS
        : LOCAL_FALLBACK_LISTS;
  
    Object.keys(source).forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      listSel.appendChild(opt);
    });
  }


  configureModeUI();

  // Auto-start if inline words are provided
  if (WORDS_OVERRIDE.length) {
    loadWordList();
  }

})();

  



/* ==================== Recording scripts (UNCHANGED) ==================== */
</script>

<script src="https://cdn.webrtc-experiment.com/RecordRTC.js"></script>

<script>
let recorder, stream;
window.allowSliderDraw = true;

const startBtn = document.getElementById("startRecording");
const stopBtn = document.getElementById("stopRecording");
const previewContainer = document.getElementById("previewContainer");

startBtn.onclick = async () => {
  startBtn.disabled = true;
  stopBtn.disabled = false;
  previewContainer.innerHTML = "";

  const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const canvasStream = canvas.captureStream(30);
  stream = new MediaStream([
    ...canvasStream.getVideoTracks(),
    ...audioStream.getAudioTracks()
  ]);

  recorder = RecordRTC(stream, {
    type: 'video',
    mimeType: 'video/webm',
    disableLogs: true
  });

  const readyText = document.getElementById("readyMessage");
  readyText.textContent = "üé¨ Get ready...";

  setTimeout(() => {
    recorder.startRecording();
    readyText.textContent = "";
    window.allowSliderDraw = false;
    setTimeout(() => { window.allowSliderDraw = true; drawCanvas(); }, 200);
  }, 600);
};

stopBtn.onclick = () => {
  stopBtn.disabled = true;
  startBtn.disabled = false;
  recorder.stopRecording(() => {
    const blob = recorder.getBlob();
    const videoURL = URL.createObjectURL(blob);
    const video = document.createElement("video");
    video.src = videoURL;
    video.controls = true;
    video.style.maxWidth = "100%";
    previewContainer.innerHTML = "";
    previewContainer.appendChild(video);
    stream?.getTracks().forEach(t => t.stop());
  });
};
</script>
</body>
</html>
