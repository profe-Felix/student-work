<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spanish Reading Game</title>

  <!-- Andika Font -->
  <link href="https://fonts.googleapis.com/css2?family=Andika&display=swap" rel="stylesheet">
  <!-- Supabase client -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <style>
    body {
      background-color: white;
      font-family: 'Andika', sans-serif;
      text-align: center;
      user-select: none;
      margin-top: 20px;
    }
    canvas {
      border: 1px solid #ddd;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      margin-bottom: 10px;
      display: inline-block;
      max-width: 100%;
      height: auto; /* responsive */
    }
    select, button {
      font-size: 18px;
      padding: 5px 10px;
      margin: 5px;
    }
    #controls { margin-top: 10px; }

    #modeBar{
      margin: 10px auto 8px;
      display:flex;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      gap:8px;
    }
    #tileRack{
      display:none;
      max-width: 900px;
      margin: 0 auto 10px;
      padding: 6px;
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:8px;
    }
    .tileBtn{
      font-family:'Andika', sans-serif;
      font-size:22px;
      padding:10px 14px;
      border:2px solid #111;
      background:#fff;
      border-radius:14px;
      cursor:pointer;
      min-width:54px;
    }
    .tileBtn:disabled{
      opacity:.35;
      cursor:not-allowed;
    }
    #hintLine{
      font-size:14px;
      color:#666;
      margin-top:4px;
    }
  </style>
</head>
<body>
  <h2>Spanish Reading Game</h2>
  <div id="syncStatus" style="margin-bottom: 10px; font-size: 16px; color:#555;"></div>

  <select id="wordListSelect">
    <option value="" selected disabled>Selecciona una lista</option>
    <option value="1. s√≠labas">1. s√≠labas</option>
    <option value="2. palabras">2. palabras</option>
    <option value="cvc">cvc</option>
    <option value="inversas">inversas</option>
    <option value="trabadas">trabadas</option>
  </select>

  <div id="controls">
    <button id="playAudio" disabled>üîä Play Audio</button>
    <button id="prevWord">‚üµ Prev</button>
    <button id="nextWord">Next ‚ü∂</button>
  </div>

  <!-- NEW: mode bar (does not affect sync / reading) -->
  <div id="modeBar">
    <label style="font-size:18px;">Modo:</label>
    <select id="gameModeSelect">
      <option value="read" selected>üìñ Leer (Slider)</option>
      <option value="spell_kb">‚å®Ô∏è Deletrear (Teclado)</option>
      <option value="spell_tiles">üß© Deletrear (Fichas)</option>
    </select>

    <select id="tileModeSelect" style="display:none;">
      <option value="exact" selected>Fichas: Exactas</option>
      <option value="vowels">Fichas: Consonantes + Vocales</option>
      <option value="distractors">Fichas: + Distractores</option>
    </select>

    <button id="submitSpell" disabled>‚úÖ Submit</button>
    <button id="backspaceSpell" disabled>‚å´</button>
    <button id="clearSpell" disabled>üßΩ Clear</button>
  </div>
  <div id="hintLine"></div>

  <div id="tileRack"></div>

  <canvas id="wordCanvas" width="768" height="432"></canvas>

  <div id="recording-controls">
    <button id="startRecording">üéô Start Recording</button>
    <button id="stopRecording" disabled>‚èπ Stop Recording</button>
  </div>

  <div id="readyMessage" style="font-size: 24px; margin-top: 10px; color: #555;"></div>
  <div id="previewContainer"></div>

  <!-- hidden input to capture keyboard typing in spelling mode -->
  <input id="spellInput" autocomplete="off" autocapitalize="none" spellcheck="false"
         style="position:absolute; left:-9999px; top:-9999px;" />

<script>
/* ==================== SUPABASE CONFIG (group sync) ==================== */
/* Same project as student-work / lettersort */
const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";

const sbClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// URL params: ?role=teacher&group=A or ?role=student&group=A
const qs = new URLSearchParams(location.search);
const ROLE = (qs.get('role') || '').toLowerCase();     // 'teacher' or 'student'
const GROUP_CODE = (qs.get('group') || '').toUpperCase();
const isTeacher = ROLE === 'teacher' && !!GROUP_CODE;
const isStudent = ROLE === 'student' && !!GROUP_CODE;

const syncStatusEl = document.getElementById('syncStatus');
if (syncStatusEl) {
  if (!ROLE || !GROUP_CODE) {
    syncStatusEl.textContent = "Modo local: usa ?role=teacher&group=A o ?role=student&group=A en la URL para sincronizar.";
  } else if (isTeacher) {
    syncStatusEl.textContent = `Modo MAESTRO ‚Äî Grupo ${GROUP_CODE}. Usa Prev/Next para guiar.`;
  } else if (isStudent) {
    syncStatusEl.textContent = `Modo ESTUDIANTE ‚Äî Grupo ${GROUP_CODE}. Seguir√° al maestro.`;
  } else {
    syncStatusEl.textContent = "Modo local (role/group no v√°lidos).";
  }
}

/** Make sure a reading_groups row exists for this group_code. */
async function ensureReadingGroup(groupCode) {
  if (!groupCode) return null;

  const { data, error } = await sbClient
    .from('reading_groups')
    .select('*')
    .eq('group_code', groupCode)
    .maybeSingle();

  // PGRST116 = no rows
  if (error && error.code !== 'PGRST116') {
    console.warn('ensureReadingGroup error', error);
    return null;
  }

  if (!data) {
    const { data: inserted, error: insertErr } = await sbClient
      .from('reading_groups')
      .insert({ group_code: groupCode, current_index: 0 })
      .select()
      .single();
    if (insertErr) {
      console.warn('insert reading_group error', insertErr);
      return null;
    }
    return inserted;
  }

  return data;
}

/** Teacher: set the current word index for a group. */
async function setReadingIndex(groupCode, index) {
  if (!groupCode) return null;
  const { data, error } = await sbClient
    .from('reading_groups')
    .update({ current_index: index })
    .eq('group_code', groupCode)
    .select('current_index')
    .single();

  if (error) {
    console.warn('setReadingIndex error', error);
    return null;
  }
  console.log('[TEACHER] set index', groupCode, index);
  return data.current_index;
}

/** Student: get current word index for a group. */
async function getReadingIndex(groupCode) {
  if (!groupCode) return null;
  const { data, error } = await sbClient
    .from('reading_groups')
    .select('current_index')
    .eq('group_code', groupCode)
    .single();

  if (error) {
    if (error.code !== 'PGRST116') {
      console.warn('getReadingIndex error', error);
    }
    return null;
  }
  return data.current_index;
}

/* ==================== Deterministic shuffle + session ==================== */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
function shuffleWithSeed(array, seedStr) {
  const seedFn = xmur3(seedStr);
  const rng = mulberry32(seedFn());
  const arr = array.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function makeSessionId() {
  if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
  return (Date.now().toString(36) + "-" + Math.random().toString(36).slice(2));
}

/* Ensure this exists before first draw */
if (window.allowSliderDraw === undefined) {
  window.allowSliderDraw = true;
}

/* ==================== Canvas + responsive scaling ==================== */
const canvas = document.getElementById("wordCanvas");
const ctx = canvas.getContext("2d");

let words = [], currentWordIndex = 0;
let sliderX = 0, isDragging = false, sliderStart, sliderEnd;
let letters = [];
let pollTimer = null; // for student polling

const DPR = window.devicePixelRatio || 1;
const BASE_W = 768, BASE_H = 432, BASE_AR = BASE_H / BASE_W;

function resizeCanvas() {
  const maxWidth = 768;
  const width = Math.min(window.innerWidth * 0.95, maxWidth);
  const height = Math.round(width * BASE_AR);

  canvas.style.width = width + "px";
  canvas.style.height = height + "px";

  canvas.width = Math.round(width * DPR);
  canvas.height = Math.round(height * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  if (words.length) {
    setupWord(words[currentWordIndex]);
  } else {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}

window.addEventListener("resize", () => requestAnimationFrame(resizeCanvas));
window.addEventListener("orientationchange", () => requestAnimationFrame(resizeCanvas));
document.addEventListener("DOMContentLoaded", resizeCanvas);

/* ==================== UI & Data ==================== */
const playBtn = document.getElementById("playAudio");
const modeSel = document.getElementById("gameModeSelect");
const tileModeSel = document.getElementById("tileModeSelect");
const tileRack = document.getElementById("tileRack");
const submitSpellBtn = document.getElementById("submitSpell");
const clearSpellBtn = document.getElementById("clearSpell");
const backspaceSpellBtn = document.getElementById("backspaceSpell");
const hintLine = document.getElementById("hintLine");
const spellInput = document.getElementById("spellInput");

document.getElementById("wordListSelect").addEventListener("change", loadWordList);
document.getElementById("nextWord").addEventListener("click", () => changeWord(1));
document.getElementById("prevWord").addEventListener("click", () => changeWord(-1));

playBtn.addEventListener("click", () => {
  if (!words.length) return;
  playWordAudio(words[currentWordIndex]);
});

modeSel.addEventListener("change", () => {
  gameMode = modeSel.value; // 'read'|'spell_kb'|'spell_tiles'
  configureModeUI();
  resetSpellingState(true);
  drawCanvas();
});

tileModeSel.addEventListener("change", () => {
  if (gameMode === 'spell_tiles') {
    resetSpellingState(true);
    buildTilesForCurrentWord();
    drawCanvas();
  }
});

submitSpellBtn.addEventListener("click", () => submitSpelling());
clearSpellBtn.addEventListener("click", () => resetSpellingState(false));
backspaceSpellBtn.addEventListener("click", () => spellingBackspace());

/* ==================== NEW: Game mode state ==================== */
let gameMode = 'read';

/* spelling state */
let targetWordRaw = "";
let targetGraphemes = [];      // correct graphemes (digraphs as 1)
let userGraphemes = [];        // filled graphemes (same length as target)
let cursorSlot = 0;
let spellingSubmitted = false;
let perSlotCorrect = [];       // booleans after submit
let pendingDigraph = null;     // { expected: 'ch', first:'c' } etc

/* tiles */
let tiles = [];                // array of tile strings displayed
let tilesUsed = [];            // boolean per tile

function configureModeUI(){
  const inSpelling = (gameMode !== 'read');
  tileModeSel.style.display = (gameMode === 'spell_tiles') ? 'inline-block' : 'none';
  tileRack.style.display = (gameMode === 'spell_tiles') ? 'flex' : 'none';

  submitSpellBtn.disabled = !inSpelling;
  clearSpellBtn.disabled = !inSpelling;
  backspaceSpellBtn.disabled = !inSpelling;

  hintLine.textContent = (gameMode === 'read')
    ? ""
    : (isStudent && GROUP_CODE)
      ? "Modo pr√°ctica: el maestro controla Prev/Next. T√∫ puedes deletrear aqu√≠."
      : "Deletrea la palabra. No hay pistas.";

  // focus keyboard input when in kb mode
  if (gameMode === 'spell_kb') {
    setTimeout(() => spellInput.focus(), 50);
  }
}

/* ==================== Load list (unchanged behavior) ==================== */
let baseWordsForDistractors = []; // keep raw list for mode 3 distractors

async function loadWordList() {
  const listName = document.getElementById("wordListSelect").value;
  const url = `wordlists/${encodeURIComponent(listName)}.txt`;

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`No encontrado: ${url}`);
    const data = await response.text();
    let baseWords = data.trim().split("\n").map(w => w.trim()).filter(Boolean);
    baseWordsForDistractors = baseWords.slice();

    if (GROUP_CODE && (isTeacher || isStudent)) {
      await ensureReadingGroup(GROUP_CODE);

      if (isTeacher) {
        const sessionId = makeSessionId();
        const { error: sessErr } = await sbClient
          .from('reading_groups')
          .update({ session_id: sessionId, current_index: 0 })
          .eq('group_code', GROUP_CODE);
        if (sessErr) console.warn('update session_id error', sessErr);

        const seedStr = `${GROUP_CODE}::${listName}::${sessionId}`;
        words = shuffleWithSeed(baseWords, seedStr);
        currentWordIndex = 0;
        console.log('[SYNC] teacher session', GROUP_CODE, listName, sessionId, words);
      } else if (isStudent) {
        const { data: row, error: rowErr } = await sbClient
          .from('reading_groups')
          .select('session_id, current_index')
          .eq('group_code', GROUP_CODE)
          .maybeSingle();

        if (!rowErr && row && row.session_id) {
          const seedStr = `${GROUP_CODE}::${listName}::${row.session_id}`;
          words = shuffleWithSeed(baseWords, seedStr);
          currentWordIndex = row.current_index ?? 0;
          console.log('[SYNC] student using session', GROUP_CODE, listName, row.session_id, 'index', currentWordIndex);
        } else {
          words = baseWords.sort(() => Math.random() - 0.5);
          currentWordIndex = 0;
          console.log('[SYNC] student fallback random (no session_id yet)');
        }
      }
    } else {
      words = baseWords.sort(() => Math.random() - 0.5);
      currentWordIndex = 0;
    }

    document.fonts.ready.then(async () => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;

      if (isTeacher && GROUP_CODE) {
        await setReadingIndex(GROUP_CODE, currentWordIndex);
      }
      if (isStudent && GROUP_CODE) {
        startStudentPolling();
      }
    });
  } catch (err) {
    console.warn(err);
    alert(`No pude cargar "${url}". Verifica el nombre y las may√∫sculas/min√∫sculas en GitHub Pages.`);
  }
}

async function startStudentPolling() {
  if (!isStudent || !GROUP_CODE) return;
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }

  const doPoll = async () => {
    const idx = await getReadingIndex(GROUP_CODE);
    if (idx == null) return;
    if (!words.length) return;
    if (idx === currentWordIndex) return;
    if (idx < 0 || idx >= words.length) return;

    console.log('[STUDENT] applying index from teacher', idx);
    currentWordIndex = idx;
    document.fonts.ready.then(() => {
      setupWord(words[currentWordIndex]);
      playBtn.disabled = false;
    });
  };

  await doPoll();
  pollTimer = setInterval(doPoll, 2000);
}

function changeWord(direction) {
  if (!words.length) return;

  // keep teacher-only guidance in sync mode
  if (isStudent && GROUP_CODE) return;

  currentWordIndex = (currentWordIndex + direction + words.length) % words.length;
  document.fonts.ready.then(() => {
    setupWord(words[currentWordIndex]);
    playBtn.disabled = false;
  });

  if (isTeacher && GROUP_CODE) {
    setReadingIndex(GROUP_CODE, currentWordIndex);
  }
}

/* ==================== Grapheme parsing (digraphs are ONE) ==================== */
function parseWord(word) {
  const digraphs = ["ch", "ll", "rr", "qu"];
  const out = [];
  const w = (word || "").toLowerCase();
  for (let i = 0; i < w.length;) {
    const dg = digraphs.find(d => w.startsWith(d, i));
    if (dg) {
      out.push({ text: dg, soundType: getSoundType(dg) });
      i += dg.length;
    } else {
      out.push({ text: w[i], soundType: getSoundType(w[i], w[i+1]) });
      i++;
    }
  }
  return out;
}

function getSoundType(letter, nextLetter = "") {
  if (letter === "c") return /[ei]/.test(nextLetter) ? "continuous" : "stop";
  if (["p","t","k","b","d","g","ch"].includes(letter)) return "stop";
  if (letter === "h") return "silent";
  return "continuous";
}

/* ==================== Word setup (keeps original reading behavior) ==================== */
function setupWord(word) {
  const baseFont = 80;
  const scaledFont = Math.round(baseFont * (canvas.clientWidth / 768));
  const fontPx = Math.max(36, Math.min(96, scaledFont));
  ctx.font = `bold ${fontPx}px Andika`;

  letters = parseWord(word);

  const padding = 10;
  const em = fontPx;
  const minPill = Math.max(18, em * 0.55);
  const innerPad = Math.max(4, Math.round(em * 0.06));

  letters.forEach(l => {
    const gw = ctx.measureText(l.text).width;
    l.gw = gw;
    l.w  = Math.max(gw + innerPad * 2, minPill);
  });

  const totalWidth = letters.reduce((s, l) => s + l.w, 0) + padding * (letters.length - 1);

  sliderStart = (canvas.clientWidth - totalWidth) / 2;
  sliderEnd   = sliderStart + totalWidth;

  sliderX = sliderStart;

  // NEW: reset spelling state when word changes
  resetSpellingState(true);
  if (gameMode === 'spell_tiles') buildTilesForCurrentWord();

  drawCanvas();
}

/* ==================== Reading draw (UNCHANGED visuals) ==================== */
function drawReading() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const baseFont = 80;
  const scaledFont = Math.round(baseFont * (canvas.clientWidth / 768));
  const fontPx = Math.max(36, Math.min(96, scaledFont));
  ctx.font = `bold ${fontPx}px Andika`;
  ctx.textAlign = "center";

  const padding = 10;
  const pillH = Math.max(16, Math.round(fontPx * 0.25));
  const textY = Math.confirm = 0; // no-op, keeps your file stable
  const realTextY = Math.round(fontPx * 1.25);
  const pillY = realTextY + Math.max(16, Math.round(fontPx * 0.5));

  function pillRadius(w, h) {
    return Math.max(2, Math.min(10, h / 2, w / 2 - 1));
  }

  let x = sliderStart;

  letters.forEach(letter => {
    const pillW = letter.w;

    ctx.fillStyle = (sliderX >= x + 1) ? "black" : "lightgrey";
    if (letter.text === "h" && letter.soundType === "silent") ctx.fillStyle = "#ccc";

    ctx.fillText(letter.text, x + pillW / 2, realTextY);

    ctx.strokeStyle = letter.soundType === "silent" ? "#aaa"
                     : letter.soundType === "stop" ? "red" : "green";
    ctx.lineWidth = 3;
    ctx.fillStyle = (sliderX >= x + 1) ? ctx.strokeStyle : "white";

    const r = pillRadius(pillW, pillH);
    roundRect(x, pillY, pillW, pillH, r, true, true);

    x += pillW + padding;
  });

  const lineY = pillY + pillH + Math.max(16, Math.round(fontPx * 0.25));
  ctx.lineCap = "round";
  ctx.strokeStyle = "#ccc";
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(sliderStart, lineY);
  ctx.lineTo(sliderEnd, lineY);
  ctx.stroke();

  ctx.strokeStyle = "#007bff";
  ctx.beginPath();
  ctx.moveTo(sliderStart, lineY);
  ctx.lineTo(sliderX, lineY);
  ctx.stroke();

  ctx.beginPath();
  ctx.fillStyle = "#007bff";
  ctx.arc(sliderX, lineY, 10, 0, Math.PI * 2);
  ctx.fill();
}

/* ==================== NEW: Spelling renderer (syllable boxes + underlines) ==================== */
function isVowelChar(ch){
  return /[aeiou√°√©√≠√≥√∫√º]/i.test(ch || "");
}
function normalizeForGrade(s){
  // accept accents but preserve √± as distinct (important)
  let x = (s || "").toLowerCase();
  x = x.replace(/√±/g, "__ENYE__");
  x = x.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  x = x.replace(/__ENYE__/g, "√±");
  return x;
}

function graphemeIsVowel(g){
  if (!g) return false;
  // digraphs are consonants
  if (g === 'ch' || g === 'll' || g === 'rr' || g === 'qu') return false;
  return isVowelChar(g);
}

function splitIntoSyllables(graphemes){
  // Spanish-ish heuristic: split consonant clusters between vowel nuclei.
  const allowedOnset2 = new Set([
    "bl","br","cl","cr","dr","fl","fr","gl","gr","pl","pr","tr"
  ]);

  const syls = [];
  let i = 0;
  while (i < graphemes.length) {
    // onset
    let onset = [];
    while (i < graphemes.length && !graphemeIsVowel(graphemes[i])) {
      onset.push(graphemes[i]);
      i++;
    }

    // nucleus (at least one vowel grapheme)
    let nucleus = [];
    if (i < graphemes.length && graphemeIsVowel(graphemes[i])) {
      nucleus.push(graphemes[i]);
      i++;
      // keep simple: don't merge diphthongs deeply; one vowel grapheme is enough for now
      // (you can refine later)
      if (i < graphemes.length && graphemeIsVowel(graphemes[i])) {
        nucleus.push(graphemes[i]);
        i++;
      }
    }

    // collect consonants until next vowel to decide split
    let cons = [];
    let j = i;
    while (j < graphemes.length && !graphemeIsVowel(graphemes[j])) {
      cons.push(graphemes[j]);
      j++;
    }

    if (j >= graphemes.length) {
      // end: everything goes to coda
      syls.push(onset.concat(nucleus).concat(cons));
      break;
    }

    // there is another vowel later; decide split of consonant cluster
    if (cons.length === 0) {
      syls.push(onset.concat(nucleus));
      // i stays
    } else if (cons.length === 1) {
      syls.push(onset.concat(nucleus)); // single consonant goes to next onset
    } else if (cons.length === 2) {
      const c1 = (cons[0] || "");
      const c2 = (cons[1] || "");
      const pair = (c1 + c2).replace(/[^a-z√±]/g,'');
      if (allowedOnset2.has(pair)) {
        syls.push(onset.concat(nucleus)); // both to next onset
      } else {
        syls.push(onset.concat(nucleus).concat([cons[0]])); // split
        i += 1; // move one consonant into coda, keep next consonant for next syllable onset
      }
    } else {
      // 3+ consonants: if last two can be onset, keep them for next syllable
      const last2 = (cons[cons.length-2] + cons[cons.length-1]).replace(/[^a-z√±]/g,'');
      if (allowedOnset2.has(last2)) {
        // move first consonant to coda
        syls.push(onset.concat(nucleus).concat([cons[0]]));
        i += 1;
      } else {
        // move first 2 to coda
        syls.push(onset.concat(nucleus).concat(cons.slice(0,2)));
        i += 2;
      }
    }

    // advance i to start of cluster (we already advanced j), but keep i where it is:
    // i currently points after nucleus. We'll set i to i (after nucleus) for next loop,
    // but we adjusted i above to consume some consonants into coda.
    // If no adjustment happened, i remains after nucleus.
    // In all cases we should set i to (original after nucleus) and then subtract? Easier:
    // We'll recompute i as: i = i (after nucleus) + (number of consonants we consumed into coda).
    // We already did i += consumed in branch, so we're good.
  }
  return syls;
}

function drawSpelling(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  const baseFont = 64;
  const scaledFont = Math.round(baseFont * (w / 768));
  const fontPx = Math.max(28, Math.min(72, scaledFont));
  ctx.font = `700 ${fontPx}px Andika`;
  ctx.textAlign = "center";
  ctx.textBaseline = "alphabetic";

  const graphemes = targetGraphemes.length ? targetGraphemes : letters.map(x=>x.text);
  if (!graphemes.length) return;

  // syllables from graphemes
  const syls = splitIntoSyllables(graphemes);

  // layout
  const boxPadX = Math.max(10, Math.round(fontPx * 0.35));
  const boxPadY = Math.max(10, Math.round(fontPx * 0.25));
  const slotGap = Math.max(8, Math.round(fontPx * 0.22));
  const sylGap  = Math.max(14, Math.round(fontPx * 0.55));

  // measure slot widths
  const slotMinW = Math.max(38, Math.round(fontPx * 0.95));
  const slotInnerPad = Math.max(8, Math.round(fontPx * 0.20));

  const slotWidths = graphemes.map(g => {
    // show digraph wider
    const display = tileDisplayFor(g);
    const tw = ctx.measureText(display).width;
    return Math.max(slotMinW, Math.round(tw + slotInnerPad*2));
  });

  // build syllable width sums
  let idx = 0;
  const sylMeta = syls.map(sg => {
    const start = idx;
    const len = sg.length;
    const end = start + len;
    const slotsW = slotWidths.slice(start, end).reduce((a,b)=>a+b,0) + slotGap*(len-1);
    const boxW = slotsW + boxPadX*2;
    idx = end;
    return { start, end, len, slotsW, boxW };
  });

  const totalW = sylMeta.reduce((a,m)=>a+m.boxW,0) + sylGap*(sylMeta.length-1);
  const startX = Math.round((w - totalW)/2);
  const topY = Math.round(h*0.18);

  // draw
  const underlineY = topY + boxPadY + Math.round(fontPx*1.05);
  const textY = topY + boxPadY + Math.round(fontPx*0.92);
  const boxH = Math.round(fontPx*1.65 + boxPadY*2);

  // slot index tracker
  let curX = startX;
  idx = 0;

  // box style
  const r = Math.min(18, Math.round(fontPx*0.35));
  ctx.lineWidth = 4;
  ctx.strokeStyle = "#111";

  sylMeta.forEach((m) => {
    // box
    roundRect(curX, topY, m.boxW, boxH, r, false, true);

    // slots inside
    let sx = curX + boxPadX;
    for (let k=m.start; k<m.end; k++){
      const sw = slotWidths[k];
      // underline
      ctx.strokeStyle = "#16a34a"; // green underline like your screenshot vibe
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(sx + 10, underlineY);
      ctx.lineTo(sx + sw - 10, underlineY);
      ctx.stroke();

      // typed letter above underline
      const u = userGraphemes[k] || "";
      const display = tileDisplayFor(u);

      // coloring after submit
      let color = "#16a34a";
      if (!spellingSubmitted){
        color = "#111";
      } else {
        color = (perSlotCorrect[k] ? "#16a34a" : "#dc2626");
      }

      ctx.fillStyle = color;
      ctx.font = `700 ${fontPx}px Andika`;
      ctx.fillText(display, sx + sw/2, textY);

      // cursor highlight (before submit)
      if (!spellingSubmitted && k === cursorSlot){
        ctx.strokeStyle = "#2563eb";
        ctx.lineWidth = 3;
        roundRect(sx+4, topY+6, sw-8, boxH-12, 12, false, true);
      }

      sx += sw + slotGap;
      idx++;
    }

    curX += m.boxW + sylGap;
  });

  // Correct word below (inside canvas)
  if (spellingSubmitted){
    const correct = (targetWordRaw || words[currentWordIndex] || "").toLowerCase().trim();
    const show = correct; // show accented original
    ctx.font = `700 ${Math.max(22, Math.round(fontPx*0.55))}px Andika`;
    ctx.fillStyle = "#111";
    const lineY = topY + boxH + Math.round(fontPx*0.95);
    ctx.fillText("Correcto: " + show, w/2, lineY);
  } else {
    // instruction line
    ctx.font = `700 ${Math.max(20, Math.round(fontPx*0.50))}px Andika`;
    ctx.fillStyle = "#666";
    const lineY = topY + boxH + Math.round(fontPx*0.95);
    ctx.fillText("Escucha y escribe la palabra.", w/2, lineY);
  }
}

/* unified canvas draw */
function drawCanvas() {
  if (!window.allowSliderDraw) return;
  if (gameMode === 'read') drawReading();
  else drawSpelling();
}

/* ==================== Pointer handling (only slider in read mode) ==================== */
canvas.addEventListener("pointerdown", (e)=> {
  if (gameMode !== 'read') return;
  isDragging=true; moveSlider(e);
});
canvas.addEventListener("pointermove", (e)=> {
  if (gameMode !== 'read') return;
  if(isDragging){moveSlider(e);}
});
canvas.addEventListener("pointerup", ()=>isDragging=false);
canvas.addEventListener("pointerleave", ()=>isDragging=false);

function moveSlider(e){
  const rect = canvas.getBoundingClientRect();
  sliderX = Math.min(Math.max(e.clientX - rect.left, sliderStart), sliderEnd);
  drawCanvas();
}

function roundRect(x, y, w, h, r, fill, stroke) {
  r = Math.max(0, Math.min(r, w/2, h/2));
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* ==================== AUDIO: use /audio, fallback to first syllable ==================== */
function normalizeName(s) {
  return (s || "")
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z√±√º]+/g, '');
}
function isVowel(ch) { return /[aeiou√°√©√≠√≥√∫]/i.test(ch); }
function firstSyllable(word) {
  const w = (word || "").toLowerCase();
  if (!w) return "";
  const digraphs = ["ch","ll","rr","qu"];
  for (const d of digraphs) {
    if (w.startsWith(d)) {
      const next = w[d.length] || "";
      if (isVowel(next)) return d + next;
      return d;
    }
  }
  const a = w[0] || "", b = w[1] || "";
  if (isVowel(a)) return a;
  if (a && b && !isVowel(a) && isVowel(b)) return a + b;
  return w.slice(0, Math.min(2, w.length));
}

function playWordAudio(word) {
  const raw = (word || "").toLowerCase().trim();
  const wordNorm = normalizeName(word);
  const syllNorm = normalizeName(firstSyllable(word));

  const candidates = [
    `audio/${encodeURIComponent(raw)}.mp3`,
    `audio/${encodeURIComponent(raw)}.wav`,
    `audio/${wordNorm}.mp3`,
    `audio/${wordNorm}.wav`,
    `audio/${syllNorm}.mp3`,
    `audio/${syllNorm}.wav`,
  ];

  const btn = playBtn;
  const label = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'üîä Reproduciendo‚Ä¶';

  let i = 0;
  const tryNext = () => {
    if (i >= candidates.length) {
      btn.disabled = false;
      btn.textContent = label;
      console.warn('No audio found for:', word, candidates);
      return;
    }
    const src = candidates[i++];
    const a = new Audio(src);
    a.playsInline = true;
    a.onended = () => { btn.disabled = false; btn.textContent = label; };
    a.onerror = () => tryNext();
    const p = a.play();
    if (p && typeof p.then === 'function') p.catch(() => tryNext());
  };
  tryNext();
}

/* ==================== NEW: Spelling mechanics (keyboard + tiles) ==================== */
function tileDisplayFor(g){
  // show accented target in "Correcto", but tiles/typing are unaccented-friendly
  // For display in slots, show without accents except √±
  if (!g) return "";
  let x = (g || "").toLowerCase();
  x = x.replace(/√°/g,'a').replace(/√©/g,'e').replace(/√≠/g,'i').replace(/√≥/g,'o').replace(/√∫/g,'u');
  return x;
}

function resetSpellingState(hard){
  spellingSubmitted = false;
  perSlotCorrect = [];
  pendingDigraph = null;

  if (!words.length) return;

  targetWordRaw = (words[currentWordIndex] || "").toLowerCase().trim();
  const g = parseWord(targetWordRaw).map(o=>o.text);

  targetGraphemes = g.slice();
  userGraphemes = new Array(targetGraphemes.length).fill("");
  cursorSlot = 0;

  if (hard){
    // rebuild tiles if needed
    tiles = [];
    tilesUsed = [];
    if (gameMode === 'spell_tiles') buildTilesForCurrentWord();
  } else {
    // keep tiles but return used
    if (gameMode === 'spell_tiles') {
      tilesUsed = new Array(tiles.length).fill(false);
      buildTileRackUI();
    }
  }

  updateSpellButtons();
  drawCanvas();
}

function updateSpellButtons(){
  const inSpell = (gameMode !== 'read');
  submitSpellBtn.disabled = !inSpell;
  clearSpellBtn.disabled = !inSpell;
  backspaceSpellBtn.disabled = !inSpell;

  if (!inSpell) return;

  const allFilled = userGraphemes.every(x => (x || "").length > 0) && !pendingDigraph;
  submitSpellBtn.disabled = !allFilled || spellingSubmitted;

  if (gameMode === 'spell_kb') {
    setTimeout(() => spellInput.focus(), 50);
  }
}

function expectedAtCursor(){
  return targetGraphemes[cursorSlot] || "";
}

function canTypeMore(){
  // prevent extra letters
  const allFilled = userGraphemes.every(x => (x || "").length > 0);
  return !spellingSubmitted && (!allFilled || pendingDigraph);
}

function spellingBackspace(){
  if (spellingSubmitted) return;

  if (pendingDigraph){
    // clear partial
    userGraphemes[cursorSlot] = "";
    pendingDigraph = null;
    updateSpellButtons();
    drawCanvas();
    return;
  }

  // find last filled slot before cursor
  let i = cursorSlot;
  if (i >= targetGraphemes.length) i = targetGraphemes.length - 1;

  // if current slot has something, remove it
  if (userGraphemes[i]) {
    userGraphemes[i] = "";
    cursorSlot = i;
    if (gameMode === 'spell_tiles') rebuildTilesFromUser(); // return tile
  } else {
    // go left
    for (let j = i-1; j >= 0; j--){
      if (userGraphemes[j]) {
        userGraphemes[j] = "";
        cursorSlot = j;
        if (gameMode === 'spell_tiles') rebuildTilesFromUser();
        break;
      }
    }
  }
  updateSpellButtons();
  drawCanvas();
}

function advanceCursor(){
  let i = cursorSlot;
  while (i < userGraphemes.length && (userGraphemes[i] || "").length > 0) i++;
  cursorSlot = Math.min(i, userGraphemes.length - 1);
}

function submitSpelling(){
  if (spellingSubmitted) return;

  // grade (accent-insensitive, digraphs are one slot)
  perSlotCorrect = targetGraphemes.map((tg, i) => {
    const u = userGraphemes[i] || "";
    return normalizeForGrade(u) === normalizeForGrade(tg);
  });

  spellingSubmitted = true;
  updateSpellButtons();
  drawCanvas();
}

/* ---------------- keyboard handling (digraphs in ONE slot) ---------------- */
function isAllowedKeyChar(k){
  return /^[a-z√±√°√©√≠√≥√∫√º]$/i.test(k || "");
}

spellInput.addEventListener("keydown", (e) => {
  if (gameMode !== 'spell_kb') return;
  if (!canTypeMore()) { e.preventDefault(); return; }

  const key = e.key;

  if (key === "Backspace") {
    e.preventDefault();
    spellingBackspace();
    return;
  }
  if (key === "Enter") {
    e.preventDefault();
    if (!submitSpellBtn.disabled) submitSpelling();
    return;
  }

  if (!isAllowedKeyChar(key)) return;

  e.preventDefault();

  const ch = key.toLowerCase();
  const expected = expectedAtCursor();

  // if expected is a digraph, support two-keystroke entry
  const digraphs = ["ch","ll","rr","qu"];

  if (digraphs.includes(expected)) {
    if (!pendingDigraph) {
      // first char must match expected[0]
      if (ch === expected[0]) {
        userGraphemes[cursorSlot] = ch;     // show first letter (temporary)
        pendingDigraph = { expected, first: ch };
      } else {
        // wrong first letter: still record it but do not advance (so they can't overflow)
        userGraphemes[cursorSlot] = ch;
        // keep cursor here; allow them to backspace
      }
    } else {
      // complete attempt
      const wantSecond = expected[1];
      if (ch === wantSecond && userGraphemes[cursorSlot] === pendingDigraph.first) {
        userGraphemes[cursorSlot] = expected; // replace with full digraph
        pendingDigraph = null;
        cursorSlot = Math.min(cursorSlot + 1, userGraphemes.length - 1);
        advanceCursor();
      } else {
        // if second doesn't match, keep what they typed (still in same slot)
        userGraphemes[cursorSlot] = (userGraphemes[cursorSlot] || "") + ch;
        // but cap display to 2 chars in slot to prevent overflow visuals
        userGraphemes[cursorSlot] = userGraphemes[cursorSlot].slice(0, 2);
      }
    }
    updateSpellButtons();
    drawCanvas();
    return;
  }

  // normal single-slot entry
  if (!userGraphemes[cursorSlot]) {
    userGraphemes[cursorSlot] = ch;
    cursorSlot = Math.min(cursorSlot + 1, userGraphemes.length - 1);
    advanceCursor();
  } else {
    // find next empty
    advanceCursor();
    if (!userGraphemes[cursorSlot]) {
      userGraphemes[cursorSlot] = ch;
      cursorSlot = Math.min(cursorSlot + 1, userGraphemes.length - 1);
      advanceCursor();
    }
  }

  updateSpellButtons();
  drawCanvas();
});

/* allow tapping canvas to focus keyboard input in kb mode */
canvas.addEventListener("click", () => {
  if (gameMode === 'spell_kb') spellInput.focus();
});

/* ---------------- tile mode ---------------- */
function buildTilesForCurrentWord(){
  if (gameMode !== 'spell_tiles') return;
  const tileMode = tileModeSel.value; // exact | vowels | distractors

  const correct = targetGraphemes.slice();

  // required tiles based on correct graphemes (but remove accents for vowel tiles)
  const required = correct.map(g => tileDisplayFor(g));

  // helper sets
  const vowels = ["a","e","i","o","u"];
  const consonantsFromWord = required.filter(g => !vowels.includes(g) && !graphemeIsVowel(g));

  let pool = [];

  if (tileMode === "exact") {
    pool = required.slice();
  } else if (tileMode === "vowels") {
    pool = consonantsFromWord.slice();
    pool.push(...vowels);
    // ensure required vowel duplicates exist to allow building (ex: mam√° needs 2 a)
    required.forEach(g => {
      if (vowels.includes(g)) pool.push(g);
    });
  } else {
    // distractors from loaded wordlist (relevant)
    pool = consonantsFromWord.slice();
    pool.push(...vowels);
    required.forEach(g => { if (vowels.includes(g)) pool.push(g); });

    const distractors = pickDistractorConsonantsFromList(8, new Set(pool));
    pool.push(...distractors);
  }

  // shuffle pool
  pool = pool.filter(Boolean);
  pool = pool.sort(() => Math.random() - 0.5);

  tiles = pool;
  tilesUsed = new Array(tiles.length).fill(false);

  buildTileRackUI();
}

function pickDistractorConsonantsFromList(n, already){
  const vowels = new Set(["a","e","i","o","u"]);
  const set = new Set();

  // collect graphemes from the loaded list (parsed with digraphs)
  for (const w of baseWordsForDistractors){
    const gs = parseWord((w||"").toLowerCase().trim()).map(o=>tileDisplayFor(o.text));
    for (const g of gs){
      if (!g) continue;
      if (vowels.has(g)) continue;
      // keep digraphs too (ch/ll/rr/qu) if they exist in the unit list
      if (!already.has(g)) set.add(g);
    }
  }

  const arr = Array.from(set).sort(() => Math.random() - 0.5);
  return arr.slice(0, n);
}

function buildTileRackUI(){
  if (gameMode !== 'spell_tiles') return;
  tileRack.innerHTML = "";
  tiles.forEach((t, i) => {
    const btn = document.createElement("button");
    btn.className = "tileBtn";
    btn.textContent = t;
    btn.disabled = !!tilesUsed[i] || spellingSubmitted;

    btn.addEventListener("click", () => {
      if (spellingSubmitted) return;
      if (!placeTile(t, i)) return;
      btn.disabled = true;
    });

    tileRack.appendChild(btn);
  });
}

function placeTile(tile, tileIndex){
  // find next empty slot
  if (!canTypeMore()) return false;
  if (pendingDigraph) return false; // tiles are already whole graphemes, no partial digraph

  let slot = userGraphemes.findIndex(x => !x);
  if (slot === -1) return false;

  userGraphemes[slot] = tile; // tiles are already accentless
  tilesUsed[tileIndex] = true;

  cursorSlot = slot;
  advanceCursor();

  updateSpellButtons();
  drawCanvas();
  return true;
}

function rebuildTilesFromUser(){
  // Re-enable tiles according to what is currently placed
  const placed = userGraphemes.map(g => (g||"").toLowerCase()).filter(Boolean);

  tilesUsed = new Array(tiles.length).fill(false);
  // for each placed grapheme, mark one matching tile as used
  placed.forEach(g => {
    const idx = tiles.findIndex((t, i) => !tilesUsed[i] && t === tileDisplayFor(g));
    if (idx >= 0) tilesUsed[idx] = true;
  });

  buildTileRackUI();
}

/* ==================== Startup ==================== */
configureModeUI();

/* ==================== Recording scripts (UNCHANGED) ==================== */
</script>

<script src="https://cdn.webrtc-experiment.com/RecordRTC.js"></script>

<script>
let recorder, stream;
window.allowSliderDraw = true;

const startBtn = document.getElementById("startRecording");
const stopBtn = document.getElementById("stopRecording");
const previewContainer = document.getElementById("previewContainer");

startBtn.onclick = async () => {
  startBtn.disabled = true;
  stopBtn.disabled = false;
  previewContainer.innerHTML = "";

  const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const canvasStream = canvas.captureStream(30);
  const combinedStream = new MediaStream([
    ...canvasStream.getVideoTracks(),
    ...audioStream.getAudioTracks()
  ]);

  recorder = RecordRTC(combinedStream, {
    type: 'video',
    mimeType: 'video/webm',
    disableLogs: true
  });

  const readyText = document.getElementById("readyMessage");
  readyText.textContent = "üé¨ Get ready...";

  setTimeout(() => {
    recorder.startRecording();
    readyText.textContent = "";
    window.allowSliderDraw = false;
    setTimeout(() => { window.allowSliderDraw = true; drawCanvas(); }, 200);
  }, 600);
};

stopBtn.onclick = () => {
  stopBtn.disabled = true;
  startBtn.disabled = false;
  recorder.stopRecording(() => {
    const blob = recorder.getBlob();
    const videoURL = URL.createObjectURL(blob);
    const video = document.createElement("video");
    video.src = videoURL;
    video.controls = true;
    video.style.maxWidth = "100%";
    previewContainer.innerHTML = "";
    previewContainer.appendChild(video);
    stream?.getTracks().forEach(t => t.stop());
  });
};
</script>

<script>
let recorder2, stream2;

const startBtn2 = document.getElementById("startRecording");
const stopBtn2 = document.getElementById("stopRecording");
const previewContainer2 = document.getElementById("previewContainer");

startBtn2.onclick = async () => {
  startBtn2.disabled = true;
  stopBtn2.disabled = false;
  previewContainer2.innerHTML = "";

  const audio = await navigator.mediaDevices.getUserMedia({ audio: true });
  const canvasStream = canvas.captureStream(30);
  stream2 = new MediaStream([...canvasStream.getVideoTracks(), ...audio.getAudioTracks()]);

  recorder2 = RecordRTC(stream2, {
    type: 'video',
    mimeType: 'video/webm',
    disableLogs: true
  });

  const readyText = document.getElementById("readyMessage");
  readyText.textContent = "üé¨ Get ready...";

  setTimeout(() => {
    recorder2.startRecording();
    readyText.textContent = "";
    window.allowSliderDraw = false;
    setTimeout(() => { window.allowSliderDraw = true; drawCanvas(); }, 200);
  }, 600);
};

stopBtn2.onclick = () => {
  stopBtn2.disabled = true;
  startBtn2.disabled = false;
  recorder2.stopRecording(() => {
    const blob = recorder2.getBlob();
    const videoURL = URL.createObjectURL(blob);
    const video = document.createElement("video");
    video.src = videoURL;
    video.controls = true;
    video.style.maxWidth = "100%";
    previewContainer2.innerHTML = "";
    previewContainer2.appendChild(video);
    stream2.getTracks().forEach(t => t.stop());
  });
};
</script>
</body>
</html>
