<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cajas de Elkonin — Sílabas con audio</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

<style>
  *{box-sizing:border-box}
  :root{
    --bg:#f7f8fc; --grid:#eef1f7; --ink:#111; --muted:#6b7280; --brand:#2563eb;
    --box:#fff; --box-b:#111827; --cover:#e5e7eb; --ok:#16a34a
  }
  html,body{height:100%}
  body{
    margin:0; font:18px/1.35 Andika, system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--ink); background:
      linear-gradient(0deg, transparent calc(100% - 1px), var(--grid) 1px),
      linear-gradient(90deg, transparent calc(100% - 1px), var(--grid) 1px),
      var(--bg);
    background-size:40px 40px, 40px 40px, auto;
  }
  header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e7eb}
  .wrap{max-width:1100px;margin:0 auto;padding:12px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .spacer{flex:1}
  h1{font-size:20px;margin:0}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  select,button{font:inherit}
  select{border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;background:#fff}
  .btn{border:1px solid #d1d5db;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.primary{background:var(--brand);color:#fff;border-color:transparent}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.wide{width:100%;padding:12px 14px;font-size:20px;border-radius:12px}

  main{max-width:1100px;margin:16px auto;padding:0 12px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.05)}

  .imageWrap{position:relative;border:2px solid var(--box-b);border-radius:12px;overflow:hidden}
  .imageWrap img{display:block;width:100%;height:270px;object-fit:contain;background:#fafafa}
  .coverLayer{position:absolute;inset:0;background:var(--cover);opacity:1}
  .coverLayer.revealed{opacity:0;pointer-events:none;transition:opacity .25s ease}

  .wordTitle{margin:8px 0 0;font-size:22px;text-align:center}

  .underButtons{margin-top:10px;display:grid;grid-template-columns:1fr;gap:10px}

  .boxes{margin-top:14px;display:grid;gap:10px}
  .slots{display:grid;gap:12px}
  .slot{min-height:84px;background:var(--box);border:2px solid var(--box-b);border-radius:8px;display:flex;align-items:center;justify-content:center}

  .counter{
    width:44px;height:44px;border:2px solid var(--box-b);border-radius:999px;
    background:#111827; cursor:pointer; user-select:none;
    transition: transform .05s ease, box-shadow .15s ease;
  }
  .counter:active{ transform: scale(.97) }
  .counter.heard{ background:#10b981; border-color:#0f9a72 }
  .counter.missing{ opacity:.55; cursor:default }

  .arrowWrap{display:flex;justify-content:center}
  .arrow{width:82%;height:26px}
  small.note{color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1>Cajas de Elkonin</h1>
      <div class="spacer"></div>
      <div class="toolbar">
        <label>Palabra:
          <select id="wordSelect"></select>
        </label>
        <button id="prevBtn" class="btn">◀</button>
        <button id="nextBtn" class="btn">▶</button>
        <button id="rebuildBtn" class="btn">Reiniciar</button>
        <button id="revealBtn" class="btn primary" disabled>Destapar y escuchar palabra</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="card">
    <div class="imageWrap">
      <img id="pic" alt="Imagen"/>
      <div id="coverLayer" class="coverLayer"></div>
    </div>
    <h2 id="wordTitle" class="wordTitle"></h2>

    <div class="underButtons">
      <button id="revealBtn2" class="btn primary wide" disabled>Destapar y escuchar</button>
    </div>

    <div class="boxes">
      <div class="elkonin">
        <div id="slots" class="slots"></div>
        <div class="arrowWrap">
          <svg class="arrow" viewBox="0 0 100 6" preserveAspectRatio="none" aria-hidden="true">
            <defs><marker id="arrowHead" markerWidth="8" markerHeight="6" refX="6" refY="3" orient="auto">
              <polygon points="0 0, 6 3, 0 6" fill="#111827"/>
            </marker></defs>
            <line x1="0" y1="3" x2="100" y2="3" stroke="#111827" stroke-width="1.2" marker-end="url(#arrowHead)"/>
          </svg>
        </div>
      </div>
      <small class="note">Pulsa cada círculo para escuchar las sílabas. Cuando todos estén escuchados, podrás destapar y oír la palabra completa.</small>
    </div>
  </div>
</main>

<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
/*** URL options ***/
let qs = new URLSearchParams(location.search);

/*** PRESET INJECTOR (Syllable Blender) ***/
const PRESET_ID = qs.get('preset');

async function applyPresetIfAny() {
  if (!PRESET_ID) return;

  try {
    const res = await fetch(
      'https://dmlsiyyqpcupbizpxwhp.supabase.co/storage/v1/object/public/app-presets/syllableblender/presets.json',
      { cache: 'no-store' }
    );
    const allPresets = await res.json();
    const preset = allPresets[PRESET_ID];
    if (!preset) return;

    /* ---- CONTENT ---- */
    if (preset.content?.words) {
      qs.set('words', preset.content.words.join(','));
    }

    /* ---- BEHAVIOR ---- */
    if (preset.behavior?.hideWord) qs.set('hideWord', '1');
    if (preset.behavior?.shuffle) qs.set('shuffle', '1');
    if (preset.behavior?.seed) qs.set('seed', preset.behavior.seed);

    /* ---- MEDIA (buckets + prefixes) ---- */
    if (preset.media?.images?.bucket) qs.set('ib', preset.media.images.bucket);
    if (preset.media?.images?.prefix) qs.set('ip', preset.media.images.prefix);

    if (preset.media?.syllableAudio?.bucket) qs.set('ab', preset.media.syllableAudio.bucket);
    if (preset.media?.syllableAudio?.prefix) qs.set('sap', preset.media.syllableAudio.prefix);

    if (preset.media?.wordAudio?.bucket) qs.set('wab', preset.media.wordAudio.bucket);
    if (preset.media?.wordAudio?.prefix) qs.set('wap', preset.media.wordAudio.prefix);

    /* IMPORTANT:
       Do NOT clean the URL yet here.
       We want the app to read the injected qs first.
    */
  } catch (err) {
    console.error('[preset] Failed to apply preset:', err);
  }
}

/* ========= marker helpers ========= */
function normalizeName(s){
  return (s||'').toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/ñ/g,'n').replace(/ü/g,'u')
    .replace(/[^a-z]/g,'');
}
function markersToPretty(s){
  return (s||'')
    .replace(/a\.\./g,'á').replace(/e\.\./g,'é').replace(/i\.\./g,'í').replace(/o\.\./g,'ó').replace(/u\.\./g,'ú')
    .replace(/n\.\./g,'ñ')
    .replace(/u,,/g,'ü');
}
function prettyToMarkers(s){
  return (s||'')
    .replace(/á/g,'a..').replace(/é/g,'e..').replace(/í/g,'i..').replace(/ó/g,'o..').replace(/ú/g,'u..')
    .replace(/ñ/g,'n..').replace(/ü/g,'u,,');
}

/* ========= seeded shuffle helpers ========= */
function cyrb128(str){
  let h1=1779033703,h2=3144134277,h3=1013904242,h4=2773480762;
  for(let i=0;i<str.length;i++){
    let k=str.charCodeAt(i);
    h1=h2^Math.imul(h1^k,597399067);
    h2=h3^Math.imul(h2^k,2869860233);
    h3=h4^Math.imul(h3^k,951274213);
    h4=h1^Math.imul(h4^k,2716044179);
  }
  h1=Math.imul(h3^(h1>>>18),597399067);
  h2=Math.imul(h4^(h2>>>22),2869860233);
  h3=Math.imul(h1^(h3>>>17),951274213);
  h4=Math.imul(h2^(h4>>>19),2716044179);
  return [(h1^h2^h3^h4)>>>0,(h2^h1)>>>0,(h3^h1)>>>0,(h4^h1)>>>0];
}
function sfc32(a,b,c,d){
  return function(){
    a|=0;b|=0;c|=0;d|=0;
    let t=(a+b|0)+d|0;
    d=d+1|0;
    a=b^b>>>9;
    b=c+(c<<3)|0;
    c=(c<<21|c>>>11);
    c=c+t|0;
    return (t>>>0)/4294967296;
  };
}
function shuffleInPlace(arr, seedStr){
  let rand = Math.random;
  if (seedStr){
    const s = cyrb128(seedStr);
    rand = sfc32(s[0],s[1],s[2],s[3]);
    for(let i=0;i<15;i++) rand();
  }
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(rand()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

/*** Supabase (images + audio) ***/
const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
const SUPABASE_ANON_KEY =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";

/*** DOM refs ***/
const wordSelect   = document.getElementById('wordSelect');
const prevBtn      = document.getElementById('prevBtn');
const nextBtn      = document.getElementById('nextBtn');
const rebuildBtn   = document.getElementById('rebuildBtn');
const revealBtn    = document.getElementById('revealBtn');
const revealBtn2   = document.getElementById('revealBtn2');
const wordTitle    = document.getElementById('wordTitle');
const pic          = document.getElementById('pic');
const coverLayer   = document.getElementById('coverLayer');
const slotsEl      = document.getElementById('slots');
const wordSelectLabel = wordSelect.closest('label');

/*** Filename helpers ***/
const IMG_EXTS = new Set(['jpg']);
function extOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(i+1).toLowerCase() : ''; }
function stemOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(0,i) : name; }
function stripImageSuffix(t){ return t.replace(/_(pic|img|image|foto)$/i,''); }

/*** Create supabase client LATER (after preset), but functions need access — keep as let ***/
let supa = null;

/*** Config derived from qs (must be built after preset) ***/
let WORDS_OVERRIDE = [];
let SOLO = false;
let HIDE_WORD = false;

let SHUFFLE_PARAM = '';
let SEED_PARAM = '';
let SHUFFLE = false;
let SHUFFLE_SEED_STR = '';

let IMAGES_BUCKET = "lettersort-images";
let IMAGES_PREFIX = "";

let SYLLABLE_AUDIO_BUCKET = "syllable-audio";
let SYLLABLE_AUDIO_PREFIX = "";

let WORD_AUDIO_BUCKET = "lettersort-audio";
let WORD_AUDIO_PREFIX = "";

/*** List all images (skip in SOLO mode) ***/
async function listAll(bucket, prefix){
  const out = [];
  async function walk(dir){
    let offset=0, limit=100;
    while(true){
      const { data, error } = await supa.storage.from(bucket).list(dir || '', {
        limit, offset, sortBy:{column:'name', order:'asc'}
      });
      if(error) throw error;
      const items = data || [];
      for(const it of items){
        const fullpath = dir ? `${dir.replace(/\/$/,'')}/${it.name}` : it.name;
        if (it.metadata) { out.push({ ...it, fullpath }); }
        else { await walk(fullpath); }
      }
      if(items.length < limit) break;
      offset += limit;
    }
  }
  await walk(prefix || '');
  return out;
}

const imageUrlByWord = new Map();
async function loadWordsFromImages(){
  imageUrlByWord.clear();
  const files = await listAll(IMAGES_BUCKET, IMAGES_PREFIX);
  for(const f of files){
    const base = f.fullpath.split('/').pop() || f.fullpath;
    const ext = extOf(base);
    if(!IMG_EXTS.has(ext)) continue;
    const stem = stripImageSuffix(stemOf(base));
    const pretty = markersToPretty(stem).toLowerCase();
    const { data } = supa.storage.from(IMAGES_BUCKET).getPublicUrl(f.fullpath);
    if (data?.publicUrl && !imageUrlByWord.has(pretty)) {
      imageUrlByWord.set(pretty, data.publicUrl);
    }
  }
  return Array.from(imageUrlByWord.keys()).sort((a,b)=>a.localeCompare(b,'es'));
}

/*** Image fallback (for explicit WORDS) — try MARKER first, then PRETTY ***/
function imgCandidates(wordRaw){
  const prefix = IMAGES_PREFIX ? IMAGES_PREFIX.replace(/\/$/,'')+'/' : '';
  const prettyLower = markersToPretty(wordRaw || '').toLowerCase();
  const markerLower = prettyToMarkers(wordRaw || '').toLowerCase();
  const stems = Array.from(new Set([markerLower, prettyLower]));

  const names = [];
  for (const stem of stems){
    for (const ext of IMG_EXTS){
      names.push(`${stem}_pic.${ext}`);
      names.push(`${stem}.${ext}`);
    }
  }
  return names.map(n => prefix ? `${prefix}${n}` : n);
}

async function getPublicUrlIfExists(bucket, path){
  const { data } = supa.storage.from(bucket).getPublicUrl(path);
  if(!data?.publicUrl) return null;
  try{ const r = await fetch(data.publicUrl, { method:'HEAD' }); if(r.ok) return data.publicUrl; }catch{}
  return null;
}

async function getImageUrl(wordRaw){
  const prettyKey = markersToPretty(wordRaw || '').toLowerCase();
  const markerKey = prettyToMarkers(wordRaw || '').toLowerCase();

  if (imageUrlByWord.has(markerKey)) return imageUrlByWord.get(markerKey);
  if (imageUrlByWord.has(prettyKey)) return imageUrlByWord.get(prettyKey);

  for(const path of imgCandidates(wordRaw)){
    const url = await getPublicUrlIfExists(IMAGES_BUCKET, path);
    if(url) return url;
  }
  return null;
}

/*** Syllabifier ***/
function syllabifyEs(wordRaw){
  const word = (wordRaw || '').toLowerCase();
  const isV = ch => /[aeiouáéíóúü]/.test((ch||'')[0] || '');
  const isWeakUnaccented = ch => /^(i|u|ü)$/.test((ch||'')[0] || '');
  const isAccWeak = ch => /[íú]/.test((ch||'')[0] || '');
  const onsetPairs = ['pl','pr','bl','br','tr','dr','cl','cr','gl','gr','fl','fr','ch','ll','rr'];

  const chars = [];
  for (let i=0;i<word.length;i++){
    const two = word.slice(i, i+2);
    if (['ch','ll','rr'].includes(two)) { chars.push(two); i++; continue; }
    if (word[i]==='q' && word[i+1]==='u' && /[eiéí]/.test(word[i+2]||'')) { chars.push('qu'); i++; continue; }
    if (word[i]==='g' && word[i+1]==='u' && /[eiéí]/.test(word[i+2]||'') && word[i+1]!=='ü'){ chars.push('gu'); i++; continue; }
    chars.push(word[i]);
  }

  const syl = [];
  let i = 0;

  while (i < chars.length){
    let onset = [];
    while (i < chars.length && !isV(chars[i])) onset.push(chars[i++]);

    if (i >= chars.length){
      if (syl.length) syl[syl.length-1] += onset.join('');
      else syl.push(onset.join(''));
      break;
    }

    let nuc = [chars[i++]];
    for (let k = 0; k < 2 && i < chars.length && isV(chars[i]); k++){
      const prev = nuc[nuc.length-1], next = chars[i];
      const canJoin =
        ((isWeakUnaccented(prev) && !isAccWeak(prev)) && !isAccWeak(next)) ||
        ((isWeakUnaccented(next) && !isAccWeak(next)) && !isAccWeak(prev)) ||
        (isWeakUnaccented(prev) && isWeakUnaccented(next));
      if (canJoin) { nuc.push(next); i++; } else break;
    }

    let after = [];
    while (i < chars.length && !isV(chars[i])) after.push(chars[i++]);

    let coda = [], nextOnset = after.slice();
    if (nextOnset.length){
      let m = 0;
      while (nextOnset.length - m >= 2){
        const a = nextOnset[m], b = nextOnset[m+1];
        const pair = (a + b).replace(/[^a-zñ]/g,'');
        if (onsetPairs.includes(pair)) break;
        m++;
      }
      coda = nextOnset.slice(0, m);
      nextOnset = nextOnset.slice(m);
      while (nextOnset.length > 2) coda.push(nextOnset.shift());
    }

    syl.push(onset.join('') + nuc.join('') + coda.join(''));
    if (nextOnset.length) i -= nextOnset.length;
  }

  return syl.filter(Boolean).map(s => s.trim());
}

/*** AUDIO: syllables = .webm only; words = .mp3 only ***/
const SYLLABLE_EXTS = ['webm'];
const WORD_EXTS     = ['mp3'];

function isSoftRContext(syll, idx){
  return idx > 0 && /^r/i.test(syll) && !/^rr/i.test(syll);
}

function audioPathsFor(wordPretty, syll, idx){
  const wPlain   = normalizeName(wordPretty);
  const sPlain   = normalizeName(syll);
  const sMarker  = prettyToMarkers(syll).toLowerCase();
  const prefix   = SYLLABLE_AUDIO_PREFIX ? SYLLABLE_AUDIO_PREFIX.replace(/\/$/,'')+'/' : '';

  const baseList = [];

  if (isSoftRContext(syll, idx)){
    baseList.push(
      `${prefix}-${sMarker}`,
      `${prefix}${wPlain}/-${sMarker}`,
      `${prefix}${wPlain}__-${sPlain}`,
      `${prefix}-${sPlain}`
    );
  }

  baseList.push(
    `${prefix}${sMarker}`,
    `${prefix}${wPlain}/${sMarker}`,
    `${prefix}${wPlain}_${idx+1}`,
    `${prefix}${wPlain}/${idx+1}`,
    `${prefix}${wPlain}__${sPlain}`,
    `${prefix}${sPlain}`
  );

  const paths = [];
  for (const b of baseList) for (const ext of SYLLABLE_EXTS) paths.push(`${b}.${ext}`);
  return paths;
}
async function resolveSyllableAudioUrl(wordPretty, syll, idx){
  const paths = audioPathsFor(wordPretty, syll, idx);
  for(const p of paths){
    const url = await getPublicUrlIfExists(SYLLABLE_AUDIO_BUCKET, p);
    if(url) return url;
  }
  return null;
}

function wordAudioPaths(wordPretty){
  const wPlain   = normalizeName(wordPretty);
  const wMarker  = prettyToMarkers(wordPretty).toLowerCase();
  const prefix   = WORD_AUDIO_PREFIX ? WORD_AUDIO_PREFIX.replace(/\/$/,'')+'/' : '';
  const bases = [
    `${prefix}${wMarker}`,
    `${prefix}${wPlain}`,
    `${prefix}${wPlain}/word`,
    `${prefix}${wPlain}/${wPlain}`,
  ];
  const paths = [];
  for (const b of bases) for (const ext of WORD_EXTS) paths.push(`${b}.${ext}`);
  return paths;
}
async function resolveWordAudioUrl(wordPretty){
  const paths = wordAudioPaths(wordPretty);
  for(const p of paths){
    const url = await getPublicUrlIfExists(WORD_AUDIO_BUCKET, p);
    if(url) return url;
  }
  return null;
}

/*** State ***/
let WORDS = [];
let index = 0;
let currentSyllables = [];
let heard = [];
let audioCache = [];
let wordAudio = null;

/*** UI Handlers ***/
prevBtn.addEventListener('click', ()=>{ index=(index-1+WORDS.length)%WORDS.length; wordSelect.value=String(index); buildForWord(WORDS[index]); });
nextBtn.addEventListener('click', ()=>{ index=(index+1)%WORDS.length; wordSelect.value=String(index); buildForWord(WORDS[index]); });
rebuildBtn.addEventListener('click', ()=> buildForWord(WORDS[index]));
revealBtn.addEventListener('click', ()=> revealAndPlay());
revealBtn2.addEventListener('click', ()=> revealAndPlay());

function setRevealEnabled(yes){
  revealBtn.disabled = !yes;
  revealBtn2.disabled = !yes;
}

async function buildForWord(wordPretty){
  wordTitle.textContent = wordPretty;
  wordTitle.style.display = HIDE_WORD ? 'none' : '';

  const syllablesSource = wordPretty;
  currentSyllables = syllabifyEs(syllablesSource);
  heard = currentSyllables.map(()=>false);
  audioCache = new Array(currentSyllables.length).fill(null);
  setRevealEnabled(false);
  coverLayer.classList.remove('revealed');

  const imgUrl = await getImageUrl(wordPretty);
  pic.src = imgUrl || 'data:image/svg+xml;utf8,' + encodeURIComponent(
    `<svg xmlns="http://www.w3.org/2000/svg" width="800" height="400"><rect width="100%" height="100%" fill="#fafafa"/></svg>`
  );

  resolveWordAudioUrl(wordPretty).then(url=>{
    if(url){
      const a = new Audio();
      a.preload = 'auto';
      a.src = url;
      try{ a.load(); }catch{}
      wordAudio = a;
    } else {
      wordAudio = null;
    }
  });

  slotsEl.innerHTML = '';
  slotsEl.style.gridTemplateColumns = `repeat(${currentSyllables.length}, 1fr)`;
  for(let i=0;i<currentSyllables.length;i++){
    const syll = currentSyllables[i];
    const slot = document.createElement('div');
    slot.className = 'slot';

    const c = document.createElement('div');
    c.className = 'counter';
    c.title = `Escuchar: ${syll}`;

    resolveSyllableAudioUrl(wordPretty, syll, i).then(url=>{
      if(url){
        const a = new Audio();
        a.preload = 'auto';
        a.src = url;
        try{ a.load(); }catch{}
        audioCache[i] = a;

        c.addEventListener('click', ()=>{
          const au = audioCache[i];
          if(!au) return;
          try{ au.currentTime = 0; }catch{}
          au.play().catch(()=>{});
          if(!heard[i]){
            heard[i] = true;
            c.classList.add('heard');
            checkAllHeard();
          }
        });
      } else {
        c.classList.add('missing');
        heard[i] = true;
        checkAllHeard();
      }
    });

    slot.appendChild(c);
    slotsEl.appendChild(slot);
  }
}

function checkAllHeard(){
  const all = heard.every(Boolean);
  setRevealEnabled(all);
}

function revealAndPlay(){
  coverLayer.classList.add('revealed');
  if(wordAudio){
    try{ wordAudio.currentTime = 0; }catch{}
    wordAudio.play().catch(()=>{});
  }
}

/*** BOOT ***/
(async function boot(){
  await applyPresetIfAny();

  /* NOW it is safe to read qs and lock values */
  WORDS_OVERRIDE = (qs.get('words')||'').split(',').map(s=>s.trim()).filter(Boolean);
  SOLO = WORDS_OVERRIDE.length > 0;
  HIDE_WORD = /^(1|true|yes)$/i.test((qs.get('hideWord')||'').trim());

  SHUFFLE_PARAM = (qs.get('shuffle') || '').trim();
  SEED_PARAM = (qs.get('seed') || '').trim();
  SHUFFLE =
    /^(1|true|yes|rand|random)$/i.test(SHUFFLE_PARAM) ||
    !!SEED_PARAM ||
    (!!SHUFFLE_PARAM && !/^(0|false|no)$/i.test(SHUFFLE_PARAM));
  SHUFFLE_SEED_STR =
    SEED_PARAM ||
    ( /^(1|true|yes|rand|random)$/i.test(SHUFFLE_PARAM) ? '' : SHUFFLE_PARAM );

  IMAGES_BUCKET = qs.get('ib') || "lettersort-images";
  IMAGES_PREFIX = (qs.get('ip') || "").replace(/^\//,'');

  SYLLABLE_AUDIO_BUCKET = qs.get('ab')  || "syllable-audio";
  SYLLABLE_AUDIO_PREFIX = (qs.get('sap') || "").replace(/^\//,'');

  WORD_AUDIO_BUCKET  = qs.get('wab') || "lettersort-audio";
  WORD_AUDIO_PREFIX  = (qs.get('wap') || "").replace(/^\//,'');

  supa = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  /* Clean URL LAST (after app has locked injected params) */
  if (PRESET_ID){
    history.replaceState(null, '', `${location.pathname}?preset=${encodeURIComponent(PRESET_ID)}`);
  }

  if (SOLO){
    WORDS = WORDS_OVERRIDE.map(w => markersToPretty(w));
  } else {
    try{
      WORDS = await loadWordsFromImages();
    }catch(err){
      console.error('Error loading words from bucket:', err);
      WORDS = ['manzana','guitarra','camión','helado','caracol'];
    }
  }

  if (SHUFFLE && WORDS.length > 1){
    shuffleInPlace(WORDS, SHUFFLE_SEED_STR);
  }

  wordSelect.innerHTML = '';
  WORDS.forEach((w,i)=>{
    const opt=document.createElement('option');
    opt.value=String(i);
    opt.textContent=w;
    wordSelect.appendChild(opt);
  });
  wordSelect.addEventListener('change', ()=>{ index=+wordSelect.value||0; buildForWord(WORDS[index]); });

  index = 0;
  wordSelect.value = String(index);
  buildForWord(WORDS[index]);

  prevBtn.disabled = WORDS.length <= 1;
  nextBtn.disabled = WORDS.length <= 1;

  if (HIDE_WORD && wordSelectLabel) {
    wordSelectLabel.style.display = 'none';
  }
})();
</script>
</body>
</html>
