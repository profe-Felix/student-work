<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cajas de Elkonin — Sílabas con audio</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

<style>
  *{box-sizing:border-box}
  :root{
    --bg:#f7f8fc; --grid:#eef1f7; --ink:#111; --muted:#6b7280; --brand:#2563eb;
    --box:#fff; --box-b:#111827; --cover:#e5e7eb; --ok:#16a34a
  }
  html,body{height:100%}
  body{
    margin:0; font:18px/1.35 Andika, system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--ink); background:
      linear-gradient(0deg, transparent calc(100% - 1px), var(--grid) 1px),
      linear-gradient(90deg, transparent calc(100% - 1px), var(--grid) 1px),
      var(--bg);
    background-size:40px 40px, 40px 40px, auto;
  }
  header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e7eb}
  .wrap{max-width:1100px;margin:0 auto;padding:12px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .spacer{flex:1}
  h1{font-size:20px;margin:0}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  select,button{font:inherit}
  select{border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;background:#fff}
  .btn{border:1px solid #d1d5db;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.primary{background:var(--brand);color:#fff;border-color:transparent}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.wide{width:100%;padding:12px 14px;font-size:20px;border-radius:12px}

  main{max-width:1100px;margin:16px auto;padding:0 12px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.05)}

  .imageWrap{position:relative;border:2px solid var(--box-b);border-radius:12px;overflow:hidden}
  .imageWrap img{display:block;width:100%;height:270px;object-fit:contain;background:#fafafa}
  .coverLayer{position:absolute;inset:0;background:var(--cover);opacity:1}
  .coverLayer.revealed{opacity:0;pointer-events:none;transition:opacity .25s ease}

  .wordTitle{margin:8px 0 0;font-size:22px;text-align:center}

  .underButtons{margin-top:10px;display:grid;grid-template-columns:1fr;gap:10px}

  .boxes{margin-top:14px;display:grid;gap:10px}
  .slots{display:grid;gap:12px}
  .slot{min-height:84px;background:var(--box);border:2px solid var(--box-b);border-radius:8px;display:flex;align-items:center;justify-content:center}

  .counter{
    width:44px;height:44px;border:2px solid var(--box-b);border-radius:999px;
    background:#111827; cursor:pointer; user-select:none;
    transition: transform .05s ease, box-shadow .15s ease;
  }
  .counter:active{ transform: scale(.97) }
  .counter.heard{ background:#10b981; border-color:#0f9a72 }
  .counter.missing{ opacity:.55; cursor:default }

  .arrowWrap{display:flex;justify-content:center}
  .arrow{width:82%;height:26px}
  small.note{color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1>Cajas de Elkonin</h1>
      <div class="spacer"></div>
      <div class="toolbar">
        <label>Palabra:
          <select id="wordSelect"></select>
        </label>
        <button id="prevBtn" class="btn">◀</button>
        <button id="nextBtn" class="btn">▶</button>
        <button id="rebuildBtn" class="btn">Reiniciar</button>
        <button id="revealBtn" class="btn primary" disabled>Destapar y escuchar palabra</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="card">
    <div class="imageWrap">
      <img id="pic" alt="Imagen"/>
      <div id="coverLayer" class="coverLayer"></div>
    </div>
    <h2 id="wordTitle" class="wordTitle"></h2>

    <!-- NEW: Under-image “Destapar y escuchar” button for easier reach -->
    <div class="underButtons">
      <button id="revealBtn2" class="btn primary wide" disabled>Destapar y escuchar</button>
    </div>

    <div class="boxes">
      <div class="elkonin">
        <div id="slots" class="slots"></div>
        <div class="arrowWrap">
          <svg class="arrow" viewBox="0 0 100 6" preserveAspectRatio="none" aria-hidden="true">
            <defs><marker id="arrowHead" markerWidth="8" markerHeight="6" refX="6" refY="3" orient="auto">
              <polygon points="0 0, 6 3, 0 6" fill="#111827"/>
            </marker></defs>
            <line x1="0" y1="3" x2="100" y2="3" stroke="#111827" stroke-width="1.2" marker-end="url(#arrowHead)"/>
          </svg>
        </div>
      </div>
      <small class="note">Pulsa cada círculo para escuchar las sílabas. Cuando todos estén escuchados, podrás destapar y oír la palabra completa.</small>
    </div>
  </div>
</main>

<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
/*** URL options ***/
const qs = new URLSearchParams(location.search);
const WORDS_OVERRIDE = (qs.get('words')||'').split(',').map(s=>s.trim()).filter(Boolean);
const SOLO = WORDS_OVERRIDE.length > 0; // Solo mode = URL provided words
const HIDE_WORD = /^(1|true|yes)$/i.test((qs.get('hideWord')||'').trim());

/*** Supabase (images + audio) ***/
const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
const SUPABASE_ANON_KEY =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";

const IMAGES_BUCKET = qs.get('ib') || "lettersort-images";
const IMAGES_PREFIX = (qs.get('ip') || "").replace(/^\//,'');   // e.g., "grade1/"

/* buckets: syllable vs word */
const SYLLABLE_AUDIO_BUCKET = qs.get('ab')  || "syllable-audio";
const SYLLABLE_AUDIO_PREFIX = (qs.get('sap') || "").replace(/^\//,'');  // e.g., "grade1/"

const WORD_AUDIO_BUCKET  = qs.get('wab') || "lettersort-audio";
const WORD_AUDIO_PREFIX  = (qs.get('wap') || "").replace(/^\//,'');     // e.g., "grade1/"

const supa = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/*** DOM refs ***/
const wordSelect   = document.getElementById('wordSelect');
const prevBtn      = document.getElementById('prevBtn');
const nextBtn      = document.getElementById('nextBtn');
const rebuildBtn   = document.getElementById('rebuildBtn');
const revealBtn    = document.getElementById('revealBtn');
const revealBtn2   = document.getElementById('revealBtn2'); // under-image button
const wordTitle    = document.getElementById('wordTitle');
const pic          = document.getElementById('pic');
const coverLayer   = document.getElementById('coverLayer');
const slotsEl      = document.getElementById('slots');

/*** Marker ↔ accents helpers ***/
function normalizeName(s){
  return (s||'').toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/ñ/g,'n').replace(/ü/g,'u')
    .replace(/[^a-z]/g,'');
}
function markersToPretty(s){
  return (s||'')
    .replace(/a\.\./g,'á').replace(/e\.\./g,'é').replace(/i\.\./g,'í').replace(/o\.\./g,'ó').replace(/u\.\./g,'ú')
    .replace(/n\.\./g,'ñ')
    .replace(/u,,/g,'ü');
}
function prettyToMarkers(s){
  return (s||'')
    .replace(/á/g,'a..').replace(/é/g,'e..').replace(/í/g,'i..').replace(/ó/g,'o..').replace(/ú/g,'u..')
    .replace(/ñ/g,'n..').replace(/ü/g,'u,,');
}

/*** Filename helpers ***/
const IMG_EXTS = new Set(['jpg']); // keep to .jpg variants
function extOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(i+1).toLowerCase() : ''; }
function stemOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(0,i) : name; }
function stripImageSuffix(t){ return t.replace(/_(pic|img|image|foto)$/i,''); }

/*** List all images (skip in SOLO mode) ***/
async function listAll(bucket, prefix){
  const out = [];
  async function walk(dir){
    let offset=0, limit=100;
    while(true){
      const { data, error } = await supa.storage.from(bucket).list(dir || '', {
        limit, offset, sortBy:{column:'name', order:'asc'}
      });
      if(error) throw error;
      const items = data || [];
      for(const it of items){
        const fullpath = dir ? `${dir.replace(/\/$/,'')}/${it.name}` : it.name;
        if (it.metadata) { out.push({ ...it, fullpath }); }
        else { await walk(fullpath); }
      }
      if(items.length < limit) break;
      offset += limit;
    }
  }
  await walk(prefix || '');
  return out;
}

const imageUrlByWord = new Map();
async function loadWordsFromImages(){
  imageUrlByWord.clear();
  const files = await listAll(IMAGES_BUCKET, IMAGES_PREFIX);
  for(const f of files){
    const base = f.fullpath.split('/').pop() || f.fullpath;
    const ext = extOf(base);
    if(!IMG_EXTS.has(ext)) continue;
    const stem = stripImageSuffix(stemOf(base));
    const pretty = markersToPretty(stem).toLowerCase();
    const { data } = supa.storage.from(IMAGES_BUCKET).getPublicUrl(f.fullpath);
    if (data?.publicUrl && !imageUrlByWord.has(pretty)) {
      imageUrlByWord.set(pretty, data.publicUrl);
    }
  }
  return Array.from(imageUrlByWord.keys()).sort((a,b)=>a.localeCompare(b,'es'));
}

/*** Image fallback (for explicit WORDS) ***/
function imgCandidates(wordPretty){
  const base = normalizeName(wordPretty);
  return [`${wordPretty.toLowerCase()}_pic.jpg`, `${base}_pic.jpg`, `${wordPretty.toLowerCase()}.jpg`, `${base}.jpg`]
    .map(n => IMAGES_PREFIX ? `${IMAGES_PREFIX.replace(/\/$/,'')}/${n}` : n);
}
async function getPublicUrlIfExists(bucket, path){
  const { data } = supa.storage.from(bucket).getPublicUrl(path);
  if(!data?.publicUrl) return null;
  try{ const r = await fetch(data.publicUrl, { method:'HEAD' }); if(r.ok) return data.publicUrl; }catch{}
  return null;
}
async function getImageUrl(wordPretty){
  if (imageUrlByWord.has(wordPretty.toLowerCase())) return imageUrlByWord.get(wordPretty.toLowerCase());
  for(const path of imgCandidates(wordPretty)){
    const url = await getPublicUrlIfExists(IMAGES_BUCKET, path);
    if(url) return url;
  }
  return null;
}

/*** Syllabifier (Spanish rules incl. ch/ll/rr, qu/gu-e/i, í/ú hiatus) ***/
function syllabifyEs(wordRaw){
  const word = (wordRaw || '').toLowerCase();
  const isV = ch => /[aeiouáéíóúü]/.test((ch||'')[0] || '');
  const isWeakUnaccented = ch => /^(i|u|ü)$/.test((ch||'')[0] || '');
  const isAccWeak = ch => /[íú]/.test((ch||'')[0] || '');
  const onsetPairs = ['pl','pr','bl','br','tr','dr','cl','cr','gl','gr','fl','fr','ch','ll','rr'];

  const chars = [];
  for (let i=0;i<word.length;i++){
    const two = word.slice(i, i+2);
    if (['ch','ll','rr'].includes(two)) { chars.push(two); i++; continue; }
    if (word[i]==='q' && word[i+1]==='u' && /[eiéí]/.test(word[i+2]||'')) { chars.push('qu'); i++; continue; }
    if (word[i]==='g' && word[i+1]==='u' && /[eiéí]/.test(word[i+2]||'') && word[i+1]!=='ü'){ chars.push('gu'); i++; continue; }
    chars.push(word[i]);
  }

  const syl = [];
  let i = 0;

  while (i < chars.length){
    let onset = [];
    while (i < chars.length && !isV(chars[i])) onset.push(chars[i++]);

    if (i >= chars.length){
      if (syl.length) syl[syl.length-1] += onset.join('');
      else syl.push(onset.join(''));
      break;
    }

    let nuc = [chars[i++]];
    for (let k = 0; k < 2 && i < chars.length && isV(chars[i]); k++){
      const prev = nuc[nuc.length-1], next = chars[i];
      const canJoin =
        ((isWeakUnaccented(prev) && !isAccWeak(prev)) && !isAccWeak(next)) ||
        ((isWeakUnaccented(next) && !isAccWeak(next)) && !isAccWeak(prev)) ||
        (isWeakUnaccented(prev) && isWeakUnaccented(next));
      if (canJoin) { nuc.push(next); i++; } else break;
    }

    let after = [];
    while (i < chars.length && !isV(chars[i])) after.push(chars[i++]);

    let coda = [], nextOnset = after.slice();
    if (nextOnset.length){
      let m = 0;
      while (nextOnset.length - m >= 2){
        const a = nextOnset[m], b = nextOnset[m+1];
        const pair = (a + b).replace(/[^a-zñ]/g,'');
        if (onsetPairs.includes(pair)) break;
        m++;
      }
      coda = nextOnset.slice(0, m);
      nextOnset = nextOnset.slice(m);
      while (nextOnset.length > 2) coda.push(nextOnset.shift());
    }

    syl.push(onset.join('') + nuc.join('') + coda.join(''));
    if (nextOnset.length) i -= nextOnset.length;
  }

  return syl.filter(Boolean).map(s => s.trim());
}

/*** AUDIO: syllables = .webm only; words = .mp3 only ***/
const SYLLABLE_EXTS = ['webm'];
const WORD_EXTS     = ['mp3'];

/* Soft r context */
function isSoftRContext(syll, idx){
  return idx > 0 && /^r/i.test(syll) && !/^rr/i.test(syll);
}

/* syllable files */
function audioPathsFor(wordPretty, syll, idx){
  const wPlain   = normalizeName(wordPretty);
  const sPlain   = normalizeName(syll);
  const sMarker  = prettyToMarkers(syll).toLowerCase();
  const prefix   = SYLLABLE_AUDIO_PREFIX ? SYLLABLE_AUDIO_PREFIX.replace(/\/$/,'')+'/' : '';

  const baseList = [];

  if (isSoftRContext(syll, idx)){
    baseList.push(
      `${prefix}-${sMarker}`,
      `${prefix}${wPlain}/-${sMarker}`,
      `${prefix}${wPlain}__-${sPlain}`,
      `${prefix}-${sPlain}`
    );
  }

  baseList.push(
    `${prefix}${sMarker}`,
    `${prefix}${wPlain}/${sMarker}`,
    `${prefix}${wPlain}_${idx+1}`,
    `${prefix}${wPlain}/${idx+1}`,
    `${prefix}${wPlain}__${sPlain}`,
    `${prefix}${sPlain}`
  );

  const paths = [];
  for (const b of baseList) for (const ext of SYLLABLE_EXTS) paths.push(`${b}.${ext}`);
  return paths;
}
async function resolveSyllableAudioUrl(wordPretty, syll, idx){
  const paths = audioPathsFor(wordPretty, syll, idx);
  for(const p of paths){
    const url = await getPublicUrlIfExists(SYLLABLE_AUDIO_BUCKET, p);
    if(url) return url;
  }
  return null;
}

/* whole-word file — mp3 only */
function wordAudioPaths(wordPretty){
  const wPlain   = normalizeName(wordPretty);
  const wMarker  = prettyToMarkers(wordPretty).toLowerCase();
  const prefix   = WORD_AUDIO_PREFIX ? WORD_AUDIO_PREFIX.replace(/\/$/,'')+'/' : '';
  const bases = [
    `${prefix}${wMarker}`,
    `${prefix}${wPlain}`,
    `${prefix}${wPlain}/word`,
    `${prefix}${wPlain}/${wPlain}`,
  ];
  const paths = [];
  for (const b of bases) for (const ext of WORD_EXTS) paths.push(`${b}.${ext}`);
  return paths;
}
async function resolveWordAudioUrl(wordPretty){
  const paths = wordAudioPaths(wordPretty);
  for(const p of paths){
    const url = await getPublicUrlIfExists(WORD_AUDIO_BUCKET, p);
    if(url) return url;
  }
  return null;
}

/*** State ***/
let WORDS = [];          // pretty display words (accents applied)
let index = 0;
let currentSyllables = [];
let heard = [];
let audioCache = [];     // one Audio per syllable
let wordAudio = null;    // Audio for full word

/*** UI Handlers ***/
prevBtn.addEventListener('click', ()=>{ index=(index-1+WORDS.length)%WORDS.length; wordSelect.value=String(index); buildForWord(WORDS[index]); });
nextBtn.addEventListener('click', ()=>{ index=(index+1)%WORDS.length; wordSelect.value=String(index); buildForWord(WORDS[index]); });
rebuildBtn.addEventListener('click', ()=> buildForWord(WORDS[index]));
revealBtn.addEventListener('click', ()=> revealAndPlay());
revealBtn2.addEventListener('click', ()=> revealAndPlay());

/*** Build one word (accepts pretty form) ***/
function setRevealEnabled(yes){
  revealBtn.disabled = !yes;
  revealBtn2.disabled = !yes;
}

async function buildForWord(wordPretty){
  // Title display (or hidden via URL param)
  wordTitle.textContent = wordPretty;
  wordTitle.style.display = HIDE_WORD ? 'none' : '';

  currentSyllables = syllabifyEs(wordPretty);
  heard = currentSyllables.map(()=>false);
  audioCache = new Array(currentSyllables.length).fill(null);
  setRevealEnabled(false);
  coverLayer.classList.remove('revealed');

  // Image
  const imgUrl = await getImageUrl(wordPretty);
  pic.src = imgUrl || 'data:image/svg+xml;utf8,' + encodeURIComponent(
    `<svg xmlns="http://www.w3.org/2000/svg" width="800" height="400"><rect width="100%" height="100%" fill="#fafafa"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="36" fill="#999">(${wordPretty})</text></svg>`
  );

  // Preload word audio (mp3)
  resolveWordAudioUrl(wordPretty).then(url=>{
    if(url){
      const a = new Audio();
      a.preload = 'auto';
      a.src = url;
      try{ a.load(); }catch{}
      wordAudio = a;
    } else {
      wordAudio = null;
    }
  });

  // Elkonin boxes + counters
  slotsEl.innerHTML = '';
  slotsEl.style.gridTemplateColumns = `repeat(${currentSyllables.length}, 1fr)`;
  for(let i=0;i<currentSyllables.length;i++){
    const syll = currentSyllables[i];
    const slot = document.createElement('div');
    slot.className = 'slot';

    const c = document.createElement('div');
    c.className = 'counter';
    c.title = `Escuchar: ${syll}`;

    resolveSyllableAudioUrl(wordPretty, syll, i).then(url=>{
      if(url){
        const a = new Audio();
        a.preload = 'auto';
        a.src = url;
        try{ a.load(); }catch{}
        audioCache[i] = a;

        c.addEventListener('click', ()=>{
          const au = audioCache[i];
          if(!au) return;
          try{ au.currentTime = 0; }catch{}
          au.play().catch(()=>{});
          if(!heard[i]){
            heard[i] = true;
            c.classList.add('heard');
            checkAllHeard();
          }
        });
      } else {
        // no audio for this syllable: don’t block reveal
        c.classList.add('missing');
        heard[i] = true;
        checkAllHeard();
      }
    });

    slot.appendChild(c);
    slotsEl.appendChild(slot);
  }
}

function checkAllHeard(){
  const all = heard.every(Boolean);
  setRevealEnabled(all);
}

function revealAndPlay(){
  coverLayer.classList.add('revealed');
  if(wordAudio){
    try{ wordAudio.currentTime = 0; }catch{}
    wordAudio.play().catch(()=>{});
  }
}

/*** BOOT ***/
(async function boot(){
  // Build pretty word list
  if (SOLO){
    // If URL provided markers (e.g., 'sofa..'), convert to pretty for display
    WORDS = WORDS_OVERRIDE.map(w => markersToPretty(w));
  } else {
    try{
      WORDS = await loadWordsFromImages(); // already pretty-mapped by loader
    }catch(err){
      console.error('Error loading words from bucket:', err);
      WORDS = ['manzana','guitarra','camión','helado','caracol'];
    }
  }

  // Populate select with pretty labels
  wordSelect.innerHTML = '';
  WORDS.forEach((w,i)=>{
    const opt=document.createElement('option');
    opt.value=String(i);
    opt.textContent=w;
    wordSelect.appendChild(opt);
  });
  wordSelect.addEventListener('change', ()=>{ index=+wordSelect.value||0; buildForWord(WORDS[index]); });

  index = 0;
  wordSelect.value = String(index);
  buildForWord(WORDS[index]);

  prevBtn.disabled = WORDS.length <= 1;
  nextBtn.disabled = WORDS.length <= 1;
})();
</script>
</body>
</html>
