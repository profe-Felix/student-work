<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Syllable Report — Supabase lettersort-images</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{--ink:#111;--muted:#666;--brand:#2563eb}
  body{margin:0;font:16px/1.45 Andika, system-ui, Segoe UI, Roboto, Helvetica, Arial;background:#fafafa;color:var(--ink)}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  header{position:sticky;top:0;background:#fff;border-bottom:1px solid #e5e7eb;z-index:5}
  h1{margin:8px 0 0}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input,button{font:inherit}
  input{padding:8px 10px;border:1px solid #d1d5db;border-radius:10px;background:#fff}
  .btn{padding:8px 12px;border-radius:10px;border:1px solid #d1d5db;background:#fff;cursor:pointer}
  .btn.primary{background:var(--brand);border-color:transparent;color:#fff}
  .grid{display:grid;grid-template-columns:1fr;gap:16px;margin-top:12px}
  @media (min-width: 960px){ .grid{grid-template-columns: 2fr 1fr;} }
  table{width:100%;border-collapse:collapse;background:#fff}
  th,td{border:1px solid #e5e7eb;padding:8px;vertical-align:top}
  th{background:#f5f7ff;text-align:left}
  .muted{color:var(--muted)}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef2ff;color:#1e3a8a;font-size:12px;margin-left:8px}
  .note{font-size:12px;color:var(--muted);margin-top:6px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:12px}
  .card h2{margin:0 0 8px;font-size:18px}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1>Syllable Report</h1>
      <span id="countPill" class="pill" style="display:none"></span>
      <span id="syllPill" class="pill" style="display:none"></span>
      <div style="flex:1"></div>
      <div class="toolbar">
        <button id="btnReload" class="btn">Recargar</button>
        <button id="btnCSVWords" class="btn">CSV palabras</button>
        <button id="btnCSVUnique" class="btn primary">CSV sílabas únicas</button>
      </div>
    </div>
    <div class="row" style="margin:8px 0 12px">
      <label>Bucket imágenes: <input id="ib" value="lettersort-images" style="width:220px"></label>
      <label>Prefijo: <input id="ip" value="" style="width:140px" placeholder="(raíz)"></label>
      <label>Bucket audio (opcional): <input id="ab" value="syllable-audio" style="width:220px"></label>
      <label>Prefijo audio: <input id="ap" value="" style="width:140px" placeholder="(raíz)"></label>
    </div>
    <div class="note">
      Puedes pasar parámetros por URL: <code>?ib=lettersort-images&ip=&ab=syllable-audio&ap=</code>.  
      Los CSV incluyen BOM UTF-8 para que Excel/Sheets respeten á, é, í, ó, ú y ñ.
    </div>
  </div>
</header>

<main class="wrap">
  <div id="warn" class="note" style="display:none"></div>

  <div class="grid">
    <div class="card">
      <h2>Palabras detectadas</h2>
      <table id="tblWords" style="display:none">
        <thead>
          <tr>
            <th>#</th>
            <th>Archivo</th>
            <th>Palabra (mostrada)</th>
            <th>Sílabas</th>
            <th>Sugeridos (nombres de audio)</th>
            <th class="muted">detalles</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="card">
      <h2>Sílabas únicas (para grabar)</h2>
      <table id="tblUnique" style="display:none">
        <thead>
          <tr>
            <th>#</th>
            <th>Sílaba</th>
            <th>Archivo sugerido</th>
            <th>Aparece en (# palabras)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="note">Ordenadas por frecuencia (desc), luego alfabético.</div>
    </div>
  </div>
</main>

<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
/* ====== CONFIG: your project ====== */
const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";
const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* ====== Marker conversions ====== */
function markersToPretty(s){
  return s
    .replace(/a\.\./g,"á").replace(/e\.\./g,"é").replace(/i\.\./g,"í").replace(/o\.\./g,"ó").replace(/u\.\./g,"ú")
    .replace(/n\.\./g,"ñ").replace(/u,,/g,"ü");
}
function prettyToMarkers(s){
  return s
    .replace(/á/g,"a..").replace(/é/g,"e..").replace(/í/g,"i..").replace(/ó/g,"o..").replace(/ú/g,"u..")
    .replace(/ñ/g,"n..").replace(/ü/g,"u,,");
}
function stripImageSuffix(stem){
  return stem.replace(/_(pic|img|image|foto)$/i, "");
}

/* ====== Spanish syllabification ====== */
const V = new Set(["a","e","i","o","u","á","é","í","ó","ú","ü"]);
const ACCENTED_WEAK = new Set(["í","ú"]);
const ALLOWED_ONSETS = new Set(["pr","pl","br","bl","tr","dr","cr","cl","gr","gl","fr","fl"]);
function tokenize(w){ return w.toLowerCase().replace(/ch/g,"Ç").replace(/ll/g,"Ł").replace(/rr/g,"Ŕ").split(""); }
function detokenize(t){ return t.join("").replace(/Ç/g,"ch").replace(/Ł/g,"ll").replace(/Ŕ/g,"rr"); }
function isVowel(t){ return V.has(t); }
function findVowelGroup(t,i){
  let group=[t[i]], k=i;
  const strong=(x)=>["a","e","o","á","é","ó"].includes(x);
  const canDiph=(a,b)=> !(ACCENTED_WEAK.has(a)||ACCENTED_WEAK.has(b)) && !(strong(a)&&strong(b));
  if(k+1<t.length && isVowel(t[k+1]) && canDiph(t[k],t[k+1])){ group.push(t[++k]);
    if(k+1<t.length && isVowel(t[k+1]) && canDiph(t[k],t[k+1])) group.push(t[++k]); }
  return {group,end:k};
}
function syllabify(word){
  const t = tokenize(word);
  const out=[]; let i=0;
  while(i<t.length){
    let onset=[]; while(i<t.length && !isVowel(t[i])) onset.push(t[i++]);
    if(i>=t.length){ if(out.length) out[out.length-1]+=detokenize(onset); else out.push(detokenize(onset)); break; }
    const {group,nucleus,end}=(()=>{const r=findVowelGroup(t,i); return {group:r.group,nucleus:r.group,end:r.end};})();
    i=end+1;
    let cStart=i,cEnd=i; while(cEnd<t.length && !isVowel(t[cEnd])) cEnd++;
    const cc=t.slice(cStart,cEnd);
    let cut=0;
    if(cc.length===1) cut=0;
    else if(cc.length===2){
      const pair=detokenize([cc[0],cc[1]]);
      cut = (pair==="ch"||pair==="ll"||pair==="rr"||ALLOWED_ONSETS.has(pair)) ? 0 : 1;
    } else if(cc.length>=3){
      const tail=detokenize([cc[1],cc[2]]);
      cut = (tail==="ch"||tail==="ll"||tail==="rr"||ALLOWED_ONSETS.has(tail)) ? 1 : 2;
    }
    const coda = cc.slice(0,cut);
    out.push(detokenize([...onset,...nucleus,...coda]));
    i = cStart + cut;
  }
  return out;
}

/* ====== Storage listing ====== */
async function listAll(bucket, prefix){
  const path = prefix && prefix.trim()!=="" ? prefix : undefined;
  let out=[], offset=0, limit=100;
  while(true){
    const { data, error } = await client.storage.from(bucket).list(path, { limit, offset, sortBy:{column:"name",order:"asc"} });
    if (error) throw error;
    const items = data || [];
    for (const it of items){
      if (it.name.endsWith("/")) continue;
      const fullpath = path ? `${path.replace(/\/$/,'')}/${it.name}` : it.name;
      out.push({ ...it, fullpath });
    }
    if (items.length < limit) break;
    offset += limit;
  }
  return out;
}

/* ====== UI refs & state ====== */
const qs = new URLSearchParams(location.search);
const els = {
  ib: document.getElementById("ib"),
  ip: document.getElementById("ip"),
  ab: document.getElementById("ab"),
  ap: document.getElementById("ap"),
  warn: document.getElementById("warn"),
  tblWords: document.getElementById("tblWords"),
  tbodyWords: document.querySelector("#tblWords tbody"),
  tblUnique: document.getElementById("tblUnique"),
  tbodyUnique: document.querySelector("#tblUnique tbody"),
  countPill: document.getElementById("countPill"),
  syllPill: document.getElementById("syllPill"),
  btnReload: document.getElementById("btnReload"),
  btnCSVWords: document.getElementById("btnCSVWords"),
  btnCSVUnique: document.getElementById("btnCSVUnique"),
};
["ib","ip","ab","ap"].forEach(k=>{ const v=qs.get(k); if(v!==null) els[k].value=v; });

els.btnReload.onclick = run;
els.btnCSVWords.onclick = ()=> downloadCSV(wordsRows, "syllable_report_words.csv");
els.btnCSVUnique.onclick = ()=> downloadCSV(uniqueRows, "syllable_report_unique_syllables.csv");

let wordsRows = [];   // for CSV (per word)
let uniqueRows = [];  // for CSV (unique syllables)

/* ====== helpers ====== */
function imageStemFromFile(name){ const i=name.lastIndexOf("."); return i>=0?name.slice(0,i):name; }
function suggestedFilesForSyllables(prettySylls){ return prettySylls.map(s=> prettyToMarkers(s).toLowerCase()+".mp3"); }
function mapUniqueSyllables(rows){
  const freq = new Map(); // pretty syllable -> count
  rows.forEach(r=>{
    r.syllables_array.forEach(s=>{
      freq.set(s, (freq.get(s)||0)+1);
    });
  });
  const arr = [...freq.entries()]
    .map(([syll,count])=>({
      syll_pretty: syll,
      syll_marker_file: (prettyToMarkers(syll).toLowerCase()+".mp3"),
      count
    }))
    .sort((a,b)=> b.count - a.count || a.syll_pretty.localeCompare(b.syll_pretty, 'es'));
  return arr;
}

/* ====== CSV (with UTF-8 BOM for á/ñ) ====== */
function downloadCSV(rows, filename){
  if (!rows || !rows.length) return;
  const headers = Object.keys(rows[0]);
  const lines = [headers.join(",")];
  for (const r of rows){
    lines.push(headers.map(h => `"${String(r[h]??"").replace(/"/g,'""')}"`).join(","));
  }
  const csv = "\uFEFF" + lines.join("\n"); // prepend BOM
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 5000);
}

/* ====== main ====== */
async function run(){
  els.warn.style.display="none";
  els.tblWords.style.display="none";
  els.tblUnique.style.display="none";
  els.tbodyWords.innerHTML="";
  els.tbodyUnique.innerHTML="";
  wordsRows=[]; uniqueRows=[];

  const IB = els.ib.value.trim();
  const IP = els.ip.value.trim();

  try{
    const files = await listAll(IB, IP);
    const imgs = files.filter(f=>{
      const n=f.fullpath.toLowerCase();
      return n.endsWith(".png")||n.endsWith(".jpg")||n.endsWith(".jpeg")||n.endsWith(".webp")||n.endsWith(".gif");
    });

    if (!imgs.length){
      els.warn.textContent = `No se encontraron imágenes en "${IB}" (prefijo: ${IP||"(raíz)"}).`;
      els.warn.style.display="block";
      return;
    }

    let idx=0; const seen = new Set();
    const wordRowsForUnique = [];

    for (const f of imgs){
      const stemRaw = stripImageSuffix(imageStemFromFile(f.fullpath.split("/").pop()));
      const prettyWord = markersToPretty(stemRaw);
      const key = prettyWord.toLowerCase();
      if (seen.has(key)) continue; // evita duplicados por varias imágenes del mismo término
      seen.add(key);

      const sylls = syllabify(prettyWord);
      const suggestion = suggestedFilesForSyllables(sylls);

      // render words table
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${++idx}</td>
        <td><code>${f.fullpath}</code></td>
        <td>${prettyWord}</td>
        <td>${sylls.join(" - ")}</td>
        <td><code>${suggestion.join(", ")}</code></td>
        <td class="muted">${sylls.length} síl.</td>
      `;
      els.tbodyWords.appendChild(tr);

      // wordsRows (for CSV)
      wordsRows.push({
        index: idx,
        path: f.fullpath,
        word_display: prettyWord,
        syllables_display: sylls.join(" - "),
        suggested_audio_files: suggestion.join(", "),
        syllable_count: sylls.length
      });

      // for unique syllables
      wordRowsForUnique.push({ word: prettyWord, syllables_array: sylls });
    }

    // build unique syllables list
    const unique = mapUniqueSyllables(wordRowsForUnique);
    let uidx=0;
    unique.forEach(u=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${++uidx}</td>
        <td>${u.syll_pretty}</td>
        <td><code>${u.syll_marker_file}</code></td>
        <td>${u.count}</td>
      `;
      els.tbodyUnique.appendChild(tr);

      uniqueRows.push({
        index: uidx,
        syllable: u.syll_pretty,
        suggested_file: u.syll_marker_file,
        word_count: u.count
      });
    });

    // show tables + pills
    els.tblWords.style.display="";
    els.tblUnique.style.display="";
    els.countPill.style.display="inline-block";
    els.countPill.textContent = `${wordsRows.length} palabras`;
    els.syllPill.style.display="inline-block";
    els.syllPill.textContent = `${uniqueRows.length} sílabas únicas`;

  } catch(err){
    els.warn.textContent = `Error: ${err?.message || err}`;
    els.warn.style.display="block";
  }
}

// autorun
run();
</script>
</body>
</html>
