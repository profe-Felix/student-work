<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clasificador de letras — Maestro & Estudiante</title>

  <!-- Kid-friendly font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

  <style>
    *{box-sizing:border-box}
    :root{--bg:#f7f7fb;--ink:#111;--muted:#666;--brand:#2563eb;--ok:#16a34a;--bad:#dc2626;--card:#fff;--drop:#eef2ff}
    html,body{height:100%}
    body{margin:0;font:16px/1.45 Andika, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;background:var(--bg);color:var(--ink)}
    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    header{position:sticky;top:0;background:#fff;border-bottom:1px solid #e5e7eb;z-index:5}
    .row{display:flex;gap:12px;align-items:center}
    .brand{font-weight:700}
    .spacer{flex:1}
    .switch{display:flex;gap:8px;align-items:center}
    .panel{margin-top:10px}
    .panel.hidden{display:none}
    .grid{display:grid;grid-template-columns:2fr 1fr 1fr;gap:12px;align-items:end}
    .field{margin:6px 0}
    .field .inline{display:flex;gap:8px}
    input,button{font:inherit}
    input{padding:8px 10px;border:1px solid #d1d5db;border-radius:10px;background:#fff;width:100%}
    .btn{padding:8px 12px;border-radius:10px;border:1px solid transparent;background:var(--brand);color:#fff;cursor:pointer}
    .btn.outline{background:#fff;border-color:#d1d5db;color:#111}
    .btn.ghost{background:transparent;border-color:transparent;color:#muted}
    .buttons{display:flex;gap:8px;align-items:center}
    .note{font-size:12px;color:#666;margin-top:8px}
    .letters{display:flex;flex-wrap:wrap;gap:6px}
    .letters button{min-width:36px;height:36px;border-radius:10px;border:1px solid #d1d5db;background:#fff;cursor:pointer}
    .letters button.active{background:var(--brand);color:#fff;border-color:transparent}
    main{max-width:1100px;margin:14px auto;padding:0 12px}
    .columns{display:grid;grid-template-columns: repeat(auto-fit,minmax(220px,1fr));gap:16px;margin-top:16px}
    .col{background:#fff;border:1px solid #e5e7eb;border-radius:14px;box-shadow:0 6px 20px rgba(0,0,0,.05);padding:10px}
    .col h2{margin:0 0 8px;font-size:18px}
    .drop{min-height:240px;background:var(--drop);border:2px dashed #c7d2fe;border-radius:12px;padding:8px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start}
    .rackSection{margin-top:18px}
    .rack{margin-top:8px;background:#fff;border:1px dashed #e5e7eb;border-radius:12px;padding:10px;display:flex;flex-wrap:wrap;gap:8px;min-height:150px}
    .card{user-select:none;touch-action:none;background:var(--card);border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 2px 6px rgba(0,0,0,.06);width:140px;overflow:hidden;cursor:grab;display:flex;flex-direction:column;align-items:center}
    .card:active{cursor:grabbing}
    .card img{display:block;width:100%;height:100px;object-fit:contain;background:#fafafa}
    .card .cap{padding:6px 8px;width:100%;text-align:center;font-size:14px}
    .card.ok{outline:3px solid var(--ok)}
    .card.bad{outline:3px solid var(--bad)}
    .locked{opacity:.85}
    .warn{padding:10px 12px;border:1px solid #fecaca;background:#fef2f2;border-radius:10px;color:#b91c1c}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <div class="brand">Clasificador de letras</div>
        <div class="spacer"></div>
        <label class="switch">
          <input id="modeToggle" type="checkbox" />
          <span>Modo Maestro</span>
        </label>
      </div>

      <!-- Maestro -->
      <div id="teacherPanel" class="panel hidden">
        <div class="field">
          <label>Código de sesión</label>
          <div class="inline">
            <input id="roomCode" placeholder="por ej., A_01" />
            <button id="btnJoin" class="btn">Iniciar sesión</button>
          </div>
          <small class="note">Comparte este código con los estudiantes.</small>
        </div>

        <div class="grid">
          <div>
            <label>Letras objetivo (1–5)</label>
            <div id="letterPicker" class="letters"></div>
          </div>
          <div>
            <label>Cartas por columna</label>
            <input id="cardsPerCol" type="number" min="1" max="8" value="4" />
          </div>
          <div class="buttons">
            <button id="btnNewRound" class="btn">Nueva ronda</button>
            <button id="btnVerify" class="btn outline">Verificar</button>
            <button id="btnReset" class="btn ghost">Reiniciar ronda</button>
          </div>
        </div>

        <div class="note">
          Las imágenes y audios se cargan de <strong>Supabase Storage</strong> (buckets públicos).
          <div id="storageWarn" class="warn" style="display:none"></div>
        </div>
      </div>

      <!-- Estudiante -->
      <div id="studentPanel" class="panel">
        <div class="field inline">
          <input id="studentRoom" placeholder="Código de sesión" />
          <button id="btnStudentJoin" class="btn">Unirse</button>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div id="columns" class="columns"></div>

    <section class="rackSection">
      <h3>Cartas</h3>
      <div id="rack" class="rack" aria-label="rack"></div>
    </section>
  </main>

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    /******** SUPABASE CONFIG (tu proyecto existente) ********/
    const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";

    const IMAGES_BUCKET = "lettersort-images";
    const AUDIO_BUCKET  = "lettersort-audio"; // opcional
    const IMAGES_PREFIX = "";                  // raíz
    const AUDIO_PREFIX  = "";                  // raíz

    // Override por query (?ib=...&ab=...&ip=...&ap=...)
    const qs = new URLSearchParams(location.search);
    const IB = qs.get('ib') || IMAGES_BUCKET;
    const AB = qs.get('ab') || AUDIO_BUCKET;
    const IP = qs.get('ip') || IMAGES_PREFIX;
    const AP = qs.get('ap') || AUDIO_PREFIX;

    const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /******** UI refs ********/
    const storageWarn = document.getElementById('storageWarn');
    const modeToggle = document.getElementById('modeToggle');
    const teacherPanel = document.getElementById('teacherPanel');
    const studentPanel = document.getElementById('studentPanel');
    const btnJoin = document.getElementById('btnJoin');
    const roomCodeEl = document.getElementById('roomCode');
    const studentRoomEl = document.getElementById('studentRoom');
    const btnStudentJoin = document.getElementById('btnStudentJoin');
    const letterPicker = document.getElementById('letterPicker');
    const cardsPerColEl = document.getElementById('cardsPerCol');
    const columnsEl = document.getElementById('columns');
    const rackEl = document.getElementById('rack');
    const btnNewRound = document.getElementById('btnNewRound');
    const btnVerify = document.getElementById('btnVerify');
    const btnReset = document.getElementById('btnReset');

    /******** State ********/
    let ROOM = null;
    let channel = null;
    let isTeacher = false;

    let imageFiles = []; // [{name, path, url, stem, initial}]
    let audioMap = new Map(); // normalizedStem -> public url

    let currentCols = [];
    let currentCards = [];
    let usedSet = new Set();

    modeToggle.addEventListener('change', () => {
      isTeacher = modeToggle.checked;
      teacherPanel.classList.toggle('hidden', !isTeacher);
      studentPanel.classList.toggle('hidden', isTeacher);
    });

    const LETTERS = 'a,b,c,ch,d,e,f,g,h,i,j,k,l,ll,m,n,ñ,o,p,q,r,rr,s,t,u,v,w,x,y,z'.split(',');
    function renderLetterPicker(){
      letterPicker.innerHTML='';
      LETTERS.forEach(L=>{
        const b=document.createElement('button');
        b.type='button'; b.textContent=L;
        b.addEventListener('click', ()=>{
          b.classList.toggle('active');
          const act=[...letterPicker.querySelectorAll('.active')];
          if(act.length>5) b.classList.remove('active');
        });
        letterPicker.appendChild(b);
      });
    }
    renderLetterPicker();

    /******** Helpers for markers ********/
    function extOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(i+1).toLowerCase() : ''; }
    function stemOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(0,i) : name; }

    // Normalize your custom markers ANYWHERE in the stem to plain letters,
    // for consistent initial detection & audio matching.
    function normalizeMarkers(s){
      let t = (s || '').toLowerCase();
      // vowels with accents stored as a.. e.. i.. o.. u..
      t = t.replace(/a\.\./g, 'a')
           .replace(/e\.\./g, 'e')
           .replace(/i\.\./g, 'i')
           .replace(/o\.\./g, 'o')
           .replace(/u\.\./g, 'u');
      // ü as u,,
      t = t.replace(/u,,/g, 'u');
      // ñ as n..
      t = t.replace(/n\.\./g, 'n');
      return t;
    }

    // Initial letter detector (respects Spanish digraphs; detects ñ if the stem STARTS with n..)
    function initialFromStem(stemRaw){
      const raw = (stemRaw || '').toLowerCase();
      // leading ñ marker
      if (raw.startsWith('n..')) return 'ñ';

      const s = normalizeMarkers(raw);

      // Spanish digraphs at start
      if (s.startsWith('ch')) return 'ch';
      if (s.startsWith('ll')) return 'll';
      if (s.startsWith('rr')) return 'rr';

      return s[0] || '';
    }

    // *** Root-listing (handles empty prefix) ***
    async function listAll(bucket, prefix) {
      const path = prefix && prefix.trim() !== "" ? prefix : undefined;
      let out = [];
      let offset = 0;
      const limit = 100;
      while (true) {
        const { data, error } = await client.storage.from(bucket).list(path, {
          limit,
          offset,
          sortBy: { column: 'name', order: 'asc' }
        });
        if (error) throw error;
        const items = data || [];
        for (const it of items) {
          const fullpath = path ? `${path.replace(/\/$/,'')}/${it.name}` : it.name;
          out.push({ ...it, fullpath });
        }
        if (items.length < limit) break;
        offset += limit;
      }
      return out;
    }

    async function ensureStorageLoaded(){
      try{
        // IMAGES
        const imgList = await listAll(IB, IP);
        const pubImg = [];
        for (const f of imgList) {
          const base = f.fullpath.split('/').pop() || f.fullpath;
          const e = extOf(base);
          if (!['png','jpg','jpeg','webp','gif'].includes(e)) continue;
          const { data } = client.storage.from(IB).getPublicUrl(f.fullpath);
          if (data?.publicUrl) {
            const stem = stemOf(base);
            pubImg.push({
              name: base,
              path: f.fullpath,
              url: data.publicUrl,
              stem,
              initial: initialFromStem(stem)
            });
          }
        }
        imageFiles = pubImg;

        // AUDIO (optional)
        audioMap = new Map();
        try {
          const audList = await listAll(AB, AP);
          for (const f of audList) {
            const base = f.fullpath.split('/').pop() || f.fullpath;
            const e = extOf(base);
            if (!['mp3','wav','m4a','ogg'].includes(e)) continue;
            const { data } = client.storage.from(AB).getPublicUrl(f.fullpath);
            if (data?.publicUrl) {
              const stem = stemOf(base);
              // key is normalized stem (markers stripped) so lookups are robust
              audioMap.set(normalizeMarkers(stem), data.publicUrl);
            }
          }
        } catch { /* audio bucket optional */ }

        if (imageFiles.length === 0){
          storageWarn.style.display = 'block';
          storageWarn.textContent =
            `No se encontraron imágenes en el bucket "${IB}" (prefijo: ${IP || '(raíz)'}). ` +
            `Verifica: 1) nombre del bucket, 2) que sea PÚBLICO, 3) que haya .png/.jpg/.webp.`;
        } else {
          storageWarn.style.display = 'none';
        }

        console.log(`[lettersort] imágenes: ${imageFiles.length}, audios: ${audioMap.size}`);
      } catch(err){
        storageWarn.style.display = 'block';
        storageWarn.textContent = `Error al listar Storage: ${err?.message || err}`;
      }
    }

    /******** Realtime ********/
    async function joinRoom(room){
      if(channel){ try{ await channel.unsubscribe(); }catch{} }
      ROOM = (room||'').trim();
      if(!ROOM){ alert('Código de sesión inválido'); return; }

      channel = client.channel(`lettersort:${ROOM}`);
      channel.on('broadcast', { event:'ROUND' }, p=>{
        const d=p.payload;
        buildColumns(d.columns);
        setCards(d.cards);
        clearAllPlacements();
      });
      channel.on('broadcast', { event:'VERIFY' }, ()=> verifyNow());
      channel.on('broadcast', { event:'RESET' }, ()=> resetRoundPlacements());

      const { error } = await channel.subscribe();
      if(error){ alert('Error de Realtime'); console.error(error); }
    }

    btnJoin.addEventListener('click', async ()=>{
      const room = roomCodeEl.value || 'A_01';
      await joinRoom(room);
      await ensureStorageLoaded();
    });
    btnStudentJoin.addEventListener('click', async ()=>{
      const room = studentRoomEl.value || 'A_01';
      await joinRoom(room);
    });

    /******** Round building from storage ********/
    const byInitial = ()=> {
      const map = new Map();
      for(const f of imageFiles){
        const list = map.get(f.initial) || [];
        list.push(f);
        map.set(f.initial, list);
      }
      return map;
    };
    const allImages = ()=> [...imageFiles];

    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]] } return a }

    btnNewRound.addEventListener('click', async ()=>{
      if(!isTeacher) return;

      if(imageFiles.length===0){
        await ensureStorageLoaded();
        if(imageFiles.length===0){ alert('No hay imágenes disponibles en Storage.'); return; }
      }

      const activeLetters = [...letterPicker.querySelectorAll('.active')].map(b=>b.textContent);
      if(activeLetters.length===0){ alert('Seleccione 1–5 letras.'); return; }

      const perCol = Math.max(1, Math.min(8, parseInt(cardsPerColEl.value||'4',10)));

      const columns = [];
      if(activeLetters.length===1){
        const L = activeLetters[0];
        columns.push({label:`Con /${L}/`, key:`${L}`});
        columns.push({label:`Sin /${L}/`, key:`not-${L}`});
      } else {
        activeLetters.forEach(L=> columns.push({label:`Con /${L}/`, key:`${L}`}));
      }

      const initialMap = byInitial();
      const everything = allImages();

      const pickNoRepeat = (arr, n) => {
        const pool = arr.filter(x=>!usedSet.has(`${x.path}`));
        shuffle(pool);
        const chosen = pool.slice(0,n);
        if(chosen.length < n){
          const more = arr.filter(x=>!chosen.includes(x));
          shuffle(more);
          chosen.push(...more.slice(0, n - chosen.length));
        }
        return chosen;
      };

      const cards = [];
      for(const col of columns){
        let picks=[];
        if(col.key.startsWith('not-')){
          const L = col.key.slice(4);
          const notList = everything.filter(f => f.initial !== L);
          picks = pickNoRepeat(notList, perCol);
        } else {
          const L = col.key;
          const list = initialMap.get(L) || [];
          picks = pickNoRepeat(list, perCol);
        }
        for(const f of picks){ usedSet.add(`${f.path}`); }
        for(const f of picks){
          const normalizedStem = normalizeMarkers(f.stem);
          const audioUrl = audioMap.get(normalizedStem) || null;
          cards.push({
            id: crypto.randomUUID(),
            file: f.name,
            word: f.stem,
            imgUrl: f.url,
            audioUrl
          });
        }
      }

      await channel.send({ type:'broadcast', event:'ROUND', payload:{ columns, cards } });
    });

    btnVerify.addEventListener('click', async ()=>{
      if(!isTeacher) return;
      await channel.send({ type:'broadcast', event:'VERIFY', payload:{} });
    });
    btnReset.addEventListener('click', async ()=>{
      if(!isTeacher) return;
      await channel.send({ type:'broadcast', event:'RESET', payload:{} });
    });

    /******** Board & DnD ********/
    function buildColumns(columns){
      currentCols = columns;
      columnsEl.innerHTML='';
      columns.forEach((c, idx)=>{
        const col = document.createElement('div');
        col.className='col';
        col.innerHTML = `<h2>${c.label}</h2><div class="drop" data-col="${idx}"></div>`;
        columnsEl.appendChild(col);
      });
    }
    function setCards(cards){
      currentCards = cards;
      rackEl.innerHTML='';
      cards.forEach(card=> rackEl.appendChild(renderCard(card)) );
    }
    function renderCard(card){
      const el=document.createElement('div');
      el.className='card';
      el.dataset.id=card.id;
      el.setAttribute('tabindex','0');
      el.innerHTML = `<img alt="" src="${card.imgUrl}"/><div class="cap">&nbsp;</div>`;
      if(card.audioUrl){
        let lastTap=0;
        const play=()=>{ const a=new Audio(card.audioUrl); a.play().catch(()=>{}); };
        el.addEventListener('dblclick', play);
        el.addEventListener('touchend', e=>{
          const now=Date.now();
          if(now-lastTap<300){ play(); }
          lastTap=now;
        });
      }
      makeDraggable(el);
      return el;
    }
    function clearAllPlacements(){
      document.querySelectorAll('.drop').forEach(d=>d.innerHTML='');
      rackEl.innerHTML='';
      currentCards.forEach(card=> rackEl.appendChild(renderCard(card)) );
    }
    function resetRoundPlacements(){
      document.querySelectorAll('.card').forEach(c=> c.classList.remove('ok','bad','locked') );
      clearAllPlacements();
    }

    function verifyNow(){
      const getTarget = key => key.startsWith('not-') ? {type:'not', letter:key.slice(4)} : {type:'is', letter:key};
      document.querySelectorAll('.drop').forEach((drop, idx)=>{
        const target = getTarget(currentCols[idx].key);
        [...drop.children].forEach(cardEl=>{
          const card = currentCards.find(c=>c.id===cardEl.dataset.id);
          if(!card) return;
          const stemRaw = (card.word||'').toLowerCase();
          const initial = initialFromStem(stemRaw);
          const ok = (target.type==='is') ? (initial===target.letter) : (initial!==target.letter);
          if(ok){ cardEl.classList.add('ok','locked'); lockCard(cardEl, card); }
          else { cardEl.classList.add('bad'); setTimeout(()=> ejectToRack(cardEl), 350); }
        });
      });
    }

    // Pointer-event DnD (with move threshold)
    let drag=null;
    function makeDraggable(el){ el.style.touchAction='none'; el.addEventListener('pointerdown', onGrab); }
    function onGrab(e){
      const el=e.currentTarget;
      if(el.classList.contains('locked')) return;
      drag={
        el,
        originParent:el.parentElement,
        pointerId:e.pointerId,
        startX:e.clientX, startY:e.clientY,
        moved:false
      };
      el.setPointerCapture(e.pointerId);
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onDrop);
    }
    function onMove(e){
      if(!drag || e.pointerId!==drag.pointerId) return;
      const dx = e.clientX - drag.startX;
      const dy = e.clientY - drag.startY;
      if(!drag.moved && Math.hypot(dx,dy) < 4) return; // tiny jitter
      if(!drag.moved){
        drag.moved = true;
        drag.el.style.position='fixed';
        drag.el.style.width = drag.el.offsetWidth + 'px';
        drag.el.style.height = drag.el.offsetHeight + 'px';
        drag.el.style.zIndex=1000;
        drag.el.style.pointerEvents='none';
      }
      moveTo(drag.el, e.clientX, e.clientY);
    }
    function onDrop(e){
      if(!drag || e.pointerId!==drag.pointerId) return;
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onDrop);
      try{ drag.el.releasePointerCapture(drag.pointerId);}catch(_){}
      const el=drag.el;
      // restore styles before placing
      el.style.position=''; el.style.left=''; el.style.top=''; el.style.zIndex=''; el.style.pointerEvents='';

      const target=document.elementFromPoint(e.clientX,e.clientY);
      const drop=target?.closest?.('.drop');
      const perCol=Math.max(1, Math.min(8, parseInt(cardsPerColEl.value||'4',10)));
      if(drop){
        if(drop.children.length>=perCol){ drag.originParent.appendChild(el); }
        else { drop.appendChild(el); }
      } else {
        rackEl.appendChild(el);
      }
      drag=null;
    }
    function moveTo(el,x,y){ el.style.left=(x-70)+'px'; el.style.top=(y-70)+'px'; }
    function ejectToRack(cardEl){ cardEl.classList.remove('bad'); rackEl.appendChild(cardEl); }
    function lockCard(cardEl, card){
      const clone = cardEl.cloneNode(true);
      clone.classList.add('locked');
      if(card?.audioUrl){
        let lastTap=0;
        const play=()=>{ const a=new Audio(card.audioUrl); a.play().catch(()=>{}); };
        clone.addEventListener('dblclick', play);
        clone.addEventListener('touchend', e=>{
          const now=Date.now();
          if(now-lastTap<300){ play(); }
          lastTap=now;
        });
      }
      cardEl.replaceWith(clone);
    }
  </script>
</body>
</html>
