<!DOCTYPE html> 
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clasificador de letras ‚Äî Maestro & Estudiante</title>

  <!-- Kid-friendly font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://dmlsiyyqpcupbizpxwhp.supabase.co" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

  <style>
    *{box-sizing:border-box}
    :root{--bg:#f7f7fb;--ink:#111;--muted:#666;--brand:#2563eb;--ok:#16a34a;--bad:#dc2626;--card:#fff;--drop:#eef2ff}
    html,body{height:100%}
    body{margin:0;font:16px/1.45 Andika, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;background:var(--bg);color:var(--ink)}
    .wrap{max-width:1200px;margin:0 auto;padding:12px}
    header{position:sticky;top:0;background:#fff;border-bottom:1px solid #e5e7eb;z-index:5}
    .row{display:flex;gap:12px;align-items:center}
    .brand{font-weight:700}
    .spacer{flex:1}
    .switch{display:flex;gap:8px;align-items:center}
    .hidden{display:none}
    .panel{margin-top:10px}
    .grid{display:grid;grid-template-columns:2fr 1fr 1fr;gap:12px;align-items:end}
    .field{margin:6px 0}
    .field .inline{display:flex;gap:8px}
    input,button{font:inherit}
    input{padding:8px 10px;border:1px solid #d1d5db;border-radius:10px;background:#fff;width:100%}
    .btn{padding:8px 12px;border-radius:10px;border:1px solid transparent;background:var(--brand);color:#fff;cursor:pointer}
    .btn.outline{background:#fff;border-color:#d1d5db;color:#111}
    .btn.ghost{background:transparent;border-color:transparent;color:#666}
    .buttons{display:flex;gap:8px;align-items:center}
    .note{font-size:12px;color:#666;margin-top:8px}
    .letters{display:flex;flex-wrap:wrap;gap:6px}
    .letters button{min-width:36px;height:36px;border-radius:10px;border:1px solid #d1d5db;background:#fff;cursor:pointer}
    .letters button.active{background:var(--brand);color:#fff;border-color:transparent}

    main{max-width:1200px;margin:14px auto;padding:0 12px}

    /* Classic columns */
    .columns{
      display:grid;
      gap:16px;
      margin-top:16px;
      overflow-x:auto;
      scroll-snap-type:x proximity;
    }
    .col{background:#fff;border:1px solid #e5e7eb;border-radius:14px;box-shadow:0 6px 20px rgba(0,0,0,.05);padding:10px;scroll-snap-align:start}
    .col header{display:flex;align-items:center;justify-content:center;margin-bottom:10px}

    .syllTile{
      min-width:110px;min-height:78px;padding:10px 14px;
      background:#6dd0ff;color:#000;font-size:38px;line-height:1;border-radius:18px;
      display:flex;flex-direction:column;align-items:center;justify-content:center;box-shadow:inset 0 0 0 2px rgba(0,0,0,.05);
      user-select:none;
      text-align:center;
    }

    /* --- Stress counter styles (new) --- */
    .stressCounters{
      display:flex;
      gap:8px;
      justify-content:center;
      margin-top:6px;
      padding-bottom:10px;          /* room for the underline */
    }

    .stressDot{
      width:18px;
      height:18px;
      border-radius:999px;
      background:#2563eb;           /* blue fill */
      position:relative;            /* so ::after is positioned from here */
    }

    /* underline under the selected dot, with a GAP */
    .stressDot.target::after{
      content:"";
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      width:22px;                   /* slightly wider than the dot */
      height:3px;
      background:#2563eb;           /* same blue as the dot */
      top:22px;                     /* 18px (dot) + ~4px gap */
      border-radius:999px;
    }

    .drop{
      min-height:240px;background:var(--drop);border:2px dashed #c7d2fe;border-radius:12px;
      padding:8px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start;align-items:stretch
    }

    .rackSection{margin-top:18px}
    .rack{
      margin-top:8px;
      background:#fff;
      border:1px dashed #e5e7eb;
      border-radius:12px;
      padding:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:flex-start;  /* cards only as tall as their content */
      min-height:0;           /* container shrinks to whatever height it needs */
    }

    .card{
      user-select:none;touch-action:none;background:var(--card);border:1px solid #e5e7eb;border-radius:12px;
      box-shadow:0 2px 6px rgba(0,0,0,.06);width:150px;overflow:hidden;cursor:grab;display:flex;flex-direction:column;align-items:center
    }
    .card:active{cursor:grabbing}
    .card img{display:block;width:100%;aspect-ratio:4/3;object-fit:contain;background:#fafafa}
    .card .cap{padding:6px 8px;width:100%;text-align:center;font-size:14px}
    .card.ok{outline:3px solid var(--ok)}
    .card.bad{outline:3px solid var(--bad)}
    .locked{opacity:.9}

    .one-per .drop .card{width:100%}
    .card.dragging{width:150px !important; height:auto !important}

    /* Word chip for rowsyll mode ‚Äî keep a wide, non-shrinking basis */
    .chip{
      user-select:none; touch-action:none; cursor:grab;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 12px;
      border:1px solid #d1d5db;
      border-radius:14px;
      background:var(--drop);
      font-size:clamp(24px, 2.8vw, 40px);
      line-height:1.1;
      min-height:48px;
      flex:0 1 auto;
      max-width:26ch;
      white-space:normal;
      word-break:break-word;
    }
    .chip:active{cursor:grabbing}
    .chip.ok{outline:3px solid var(--ok)}
    .chip.bad{outline:3px solid var(--bad)}

    .rack.chips{
      gap:12px;
      padding:12px;
      align-items:flex-start;
    }
    .chip.dragging{ width: auto !important; height:auto !important }

    /* ===== Tiles-only cards (words instead of images) ===== */
    body.tiles-only .card{
      width:auto;
      min-width:130px;
      max-width:260px;
    }
    body.tiles-only .card img{
      display:none;
    }
    body.tiles-only .card .cap{
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:clamp(24px, 2.6vw, 40px);
      line-height:1.1;
      padding:12px 16px;
      min-height:64px;
      text-align:center;
      white-space:normal;
      word-break:break-word;
    }

    /* Word tiles (cards & chips) share the same rounded layout */
    .wordTile{
      position:relative;
      border-radius:18px;
      overflow:hidden;
    }

    /* Click-to-reveal blue cover that hides the text until clicked */
    .wordCover{
      position:absolute;
      inset:0;
      border:none;
      padding:0;
      margin:0;
      border-radius:inherit;
      background:#3b82f6;            /* blue cover */
      cursor:pointer;
      outline:none;
    }
    .wordCover::after{ content:""; }

    .warn{padding:10px 12px;border:1px solid #fecaca;background:#fef2f2;border-radius:10px;color:#b91c1c}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#1e3a8a;font-size:12px;margin-left:8px}

    .soloBar{position:sticky;top:56px;z-index:4;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:8px;display:flex;gap:8px;align-items:center;box-shadow:0 4px 10px rgba(0,0,0,.04)}
    .bankActions{display:flex;gap:8px;align-items:center;margin-top:10px}

    .celebrationCanvas{position:fixed;inset:0;pointer-events:none;z-index:50}

    /* ---------- Row Picture Modes ---------- */
    #rowMode{margin-top:14px;display:grid;gap:14px}

    .rowLine{
      display:grid;
      grid-template-columns: 170px 170px 1fr; /* prompt-row mode */
      align-items:center;
      gap:14px;
      background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px;
      box-shadow:0 4px 14px rgba(0,0,0,.05)
    }

    .rowLine.twoCols{
      grid-template-columns: minmax(220px, max-content) 1fr;
      align-items:start;
    }

    .rowDrop{
      min-height:160px;
      background:var(--drop);
      border:2px dashed #c7d2fe;
      border-radius:12px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-content:flex-start;
      align-items:flex-start;
      padding:8px;
    }

    .rowLine.twoCols .rowDrop{
      width:100%;
      max-width:100%;
      min-width:0;
      justify-content:flex-start;
    }
    .rowRack{display:flex;gap:8px;flex-wrap:wrap;align-items:flex-start}
    .rowCard{width:150px}
    .rowTitle{font-size:12px;text-align:center;color:#666;margin-top:4px}

    body.row-compact .wrap { padding-top:6px; }
    body.row-compact header { border-bottom-width:1px; }
    body.row-compact .soloBar { padding:6px; }
    body.row-compact .columns { gap:12px; }

    body.row-compact #rowMode { gap:10px; }
    body.row-compact .rowLine{
      grid-template-columns: 150px 140px 1fr;
      padding:8px;
      gap:10px;
      border-radius:10px;
      box-shadow:0 3px 10px rgba(0,0,0,.045);
    }
    body.row-compact .rowLine.twoCols{ grid-template-columns: minmax(150px, max-content) 1fr; }
    body.row-compact .rowDrop{
      min-height:120px;
      padding:6px;
      border-radius:10px;
      gap:6px;
    }
    body.row-compact .rowLine.twoCols .rowDrop{
      min-width:150px;
      width:max-content;
      max-width:100%;
    }
    body.row-compact .rowRack{ gap:6px; }
    body.row-compact .rowCard{ width:120px; }
    body.row-compact .rowCard img{ aspect-ratio:4/3; object-fit:contain; }
    body.row-compact .bankActions{ margin-top:6px; }
    body.row-compact .chip{
      flex: 0 0 180px;
      min-width:180px;
      max-width:220px;
      font-size:20px;
      padding:10px 14px;
    }
    
    /* ---------- Stress reveal background scene ---------- */
    #stressRevealScene{
      margin-top:16px;
    }
    #stressRevealScene.hidden{
      display:none;
    }
    .stress-bg-wrapper{
      position:relative;
      max-width:520px;
      margin:0 auto 12px auto;
      border-radius:12px;
      overflow:hidden;
      box-shadow:0 6px 20px rgba(0,0,0,.12);
      background:#fff;
    }
    .stress-bg-wrapper img{
      display:block;
      width:100%;
      height:auto;
    }
    .revealBlob{
      position:absolute;
      background:#0f8b9c;
      border-radius:999px;
      padding:26px 32px;
      opacity:0.96;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:28px;
      font-weight:700;
      color:#fff;
      box-shadow:0 4px 10px rgba(0,0,0,.25);
      transform:translate3d(0,0,0);
      transition:opacity .3s ease, transform .3s ease;
      pointer-events:auto;
      user-select:none;
    }
    .revealBlob.hiddenBlob{
      opacity:0;
      pointer-events:none;
      transform:translate3d(0,-40px,0);
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <div class="brand" id="uiBrand">Clasificador de letras</div>
        <span id="soloPill" class="pill" style="display:none"></span>
        <div class="spacer"></div>
        <button id="qrBtn" class="btn outline">üì± QR</button>

        <label class="switch">
          <input id="modeToggle" type="checkbox" />
          <span id="uiModeLabel">Modo Maestro</span>
        </label>
      </div>

      <!-- Maestro -->
      <div id="teacherPanel" class="panel hidden">
        <div class="field">
          <label id="uiSessionCodeLabel">C√≥digo de sesi√≥n</label>
          <div class="inline">
            <input id="roomCode" placeholder="por ej., A_01" />
            <button id="btnJoin" class="btn">Iniciar sesi√≥n</button>
          </div>
          <small class="note" id="uiShareNote">Comparte este c√≥digo con los estudiantes.</small>
        </div>

        <div class="grid">
          <div>
            <label id="uiTargetLettersLabel">Letras objetivo (1‚Äì5)</label>
            <div id="letterPicker" class="letters"></div>
          </div>
          <div>
            <label id="uiCardsPerColLabel">Cartas por columna</label>
            <input id="cardsPerCol" type="number" min="1" max="8" value="4" />
          </div>
          <div class="buttons">
            <button id="btnNewRound" class="btn">Nueva ronda</button>
            <button id="btnVerify" class="btn outline">Verificar</button>
            <button id="btnReset" class="btn ghost">Reiniciar ronda</button>
          </div>
        </div>

        <div class="note" id="uiStorageNote">
          Las im√°genes y audios se cargan de <strong>Supabase Storage</strong>.
          <div id="storageWarn" class="warn" style="display:none"></div>
        </div>
      </div>

      <!-- Estudiante -->
      <div id="studentPanel" class="panel">
        <div class="field inline">
          <input id="studentRoom" placeholder="C√≥digo de sesi√≥n" />
          <button id="btnStudentJoin" class="btn">Unirse</button>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- SOLO TOOLBAR -->
    <div id="soloBar" class="soloBar hidden">
      <button id="soloNewRound" class="btn">Nueva ronda</button>
      <button id="soloVerify" class="btn outline">Verificar</button>
      <button id="soloReset" class="btn ghost">Reiniciar ronda</button>
    </div>
    
    <!-- Classic columns container -->
    <div id="columns" class="columns"></div>

    <!-- Stress reveal scene (background + ovals) -->
    <section id="stressRevealScene" class="hidden"></section>

    <!-- Row picture mode container -->
    <section id="rowMode" class="hidden"></section>

    <!-- Global rack (bank) -->
    <section id="rackSection" class="rackSection">
      <h3 id="uiCardsHeader">Cartas</h3>
      <div id="rack" class="rack" aria-label="rack"></div>
      <div class="bankActions">
        <button id="inlineVerify" class="btn outline">Verificar</button>
        <button id="inlineReset" class="btn ghost">Reiniciar ronda</button>
      </div>
    </section>
  </main>

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    /******** SUPABASE CONFIG ********/
    const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";

    const DEFAULT_IMAGES_BUCKET = "lettersort-images";
    const DEFAULT_AUDIO_BUCKET  = "lettersort-audio";
    const DEFAULT_IMAGES_PREFIX = "";
    const DEFAULT_AUDIO_PREFIX  = "";
/* =========================================================
   PRESET LOADER ‚Äî Storage presets.json (LetterSort-native)
   ========================================================= */
(function loadPresetFromStorage(){
  const qsLocal = new URLSearchParams(location.search);
  const presetId = qsLocal.get('preset');
  if (!presetId) return;

  fetch(
    'https://dmlsiyyqpcupbizpxwhp.supabase.co/storage/v1/object/public/app-presets/lettersort/presets.json',
    { cache: 'no-store' }
  )
    .then(r => r.ok ? r.json() : null)
    .then(allPresets => {
      if (!allPresets || !allPresets[presetId]) return;

      const preset = allPresets[presetId];
      let changed = false;

      Object.entries(preset).forEach(([key, value]) => {
        // URL params always win
        if (qsLocal.has(key)) return;

        qsLocal.set(
          key,
          Array.isArray(value) ? value.join(',') : String(value)
        );
        changed = true;
      });

      if (changed) {
        sessionStorage.setItem('__presetExpanded', '1');
        location.replace(`${location.pathname}?${qsLocal.toString()}`);
      }
    })
    .catch(err => {
      console.warn('[lettersort preset]', err);
    });
})();




    // URL params
    const qs = new URLSearchParams(location.search);

    // Hide expanded preset params after load
if (sessionStorage.getItem('__presetExpanded') === '1') {
  const presetOnly = qs.get('preset');
  if (presetOnly) {
    history.replaceState(
      null,
      '',
      `${location.pathname}?preset=${encodeURIComponent(presetOnly)}`
    );

    // üîÅ notify QR to refresh if open
    window.dispatchEvent(new Event('popstate'));
  }
  sessionStorage.removeItem('__presetExpanded');
}



    // language switch (Spanish default). Use: ?lang=en (or ?language=en / english)
    const LANG_RAW = (qs.get('lang') || qs.get('language') || 'es').toLowerCase().trim();
    const LANG = (LANG_RAW.startsWith('en') || LANG_RAW === 'english') ? 'en' : 'es';

    // Apply html lang attr
    document.documentElement.lang = LANG;
    // --- UI strings (ES/EN) ---
    const UI = {
      es: {
        brand: 'Clasificador de letras',
        modeTeacher: 'Modo Maestro',
        sessionCode: 'C√≥digo de sesi√≥n',
        join: 'Iniciar sesi√≥n',
        shareNote: 'Comparte este c√≥digo con los estudiantes.',
        targetLetters: 'Letras objetivo (1‚Äì5)',
        cardsPerCol: 'Cartas por columna',
        newRound: 'Nueva ronda',
        verify: 'Verificar',
        reset: 'Reiniciar ronda',
        studentRoomPh: 'C√≥digo de sesi√≥n',
        studentJoin: 'Unirse',
        cardsHeader: 'Cartas',
        storageNote: 'Las im√°genes y audios se cargan de <strong>Supabase Storage</strong>.',
        warnNoImages: (IB, IP) => `No se encontraron im√°genes JPG en "${IB}" (prefijo: ${IP || '(ra√≠z)'}).`,
        alertInvalidRoom: 'C√≥digo de sesi√≥n inv√°lido',
        alertRealtimeErr: 'Error de Realtime',
        alertNoImages: 'No hay im√°genes disponibles.',
        alertPickLetters: 'Seleccione 1‚Äì5 letras.',
        soloPrefix: 'Modo individual:',
        soloMode: {
          randinit: 'sonido inicial aleatorio',   /* ‚úÖ NEW */
          row: 'modo filas',
          rowalli: 'aliteraci√≥n por filas',
          allisyll: 's√≠labas iniciales por filas',
          rowsyll: 's√≠labas (inicio/final) por filas',
          syllcount: (arr) => `conteo de s√≠labas (${(arr.join(', ')||'1+')})`,
          stress: (arr) => `s√≠laba t√≥nica (${(arr.join(', ')||'1+')})`
        },
        soloExtras: {
          words: (w) => ` ¬∑ palabras=${w.join(', ')}`,
          emoji: ' ¬∑ etiquetas: emoji',
          hidetitle: ' ¬∑ sin t√≠tulo',
          lang: '' // default, no need to show
        },
        labels: {
          is: (L) => `Empieza con /${L}/`,
          not: (L) => `No empieza con /${L}/`,
          emojiIs: (L) => `üëç S√≠laba con /${L}/`,
          emojiNot: (L) => `üëé S√≠laba sin /${L}/`,
          syllOne: (n) => `${n} s√≠laba`,
          syllMany: (n) => `${n} s√≠labas`,
          stressBase: (p) => {
            if (p === 1) return '√∫ltima';
            if (p === 2) return 'pen√∫ltima';
            if (p === 3) return 'antepen√∫ltima';
            return `${p}¬™ desde el final`;
          },
          stressLabel: (base) => `s√≠laba t√≥nica: ${base}`
        }
      },
      en: {
        brand: 'Letter Sorter',
        modeTeacher: 'Teacher Mode',
        sessionCode: 'Session code',
        join: 'Start session',
        shareNote: 'Share this code with students.',
        targetLetters: 'Target letters (1‚Äì5)',
        cardsPerCol: 'Cards per column',
        newRound: 'New round',
        verify: 'Check',
        reset: 'Reset round',
        studentRoomPh: 'Session code',
        studentJoin: 'Join',
        cardsHeader: 'Cards',
        storageNote: 'Images and audio load from <strong>Supabase Storage</strong>.',
        warnNoImages: (IB, IP) => `No JPG images found in "${IB}" (prefix: ${IP || '(root)'}).`,
        alertInvalidRoom: 'Invalid session code',
        alertRealtimeErr: 'Realtime error',
        alertNoImages: 'No images available.',
        alertPickLetters: 'Select 1‚Äì5 letters.',
        soloPrefix: 'Solo mode:',
        soloMode: {
          randinit: 'random initial sound',       /* ‚úÖ NEW */
          row: 'row mode',
          rowalli: 'row alliteration',
          allisyll: 'row initial-syllables',
          rowsyll: 'row syllables (start/end)',
          syllcount: (arr) => `syllable count (${(arr.join(', ')||'1+')})`,
          stress: (arr) => `stressed syllable (${(arr.join(', ')||'1+')})`
        },
        soloExtras: {
          words: (w) => ` ¬∑ words=${w.join(', ')}`,
          emoji: ' ¬∑ labels: emoji',
          hidetitle: ' ¬∑ no title',
          lang: ' ¬∑ lang=en'
        },
        labels: {
          is: (L) => `Starts with /${L}/`,
          not: (L) => `Does not start with /${L}/`,
          emojiIs: (L) => `üëç Syllable with /${L}/`,
          emojiNot: (L) => `üëé Syllable without /${L}/`,
          syllOne: (n) => `${n} syllable`,
          syllMany: (n) => `${n} syllables`,
          stressBase: (p) => {
            if (p === 1) return 'last';
            if (p === 2) return 'second-to-last';
            if (p === 3) return 'third-to-last';
            return `${p}th from the end`;
          },
          stressLabel: (base) => `stress: ${base}`
        }
      }
    };
    const T = UI[LANG] || UI.es;

    function applyUiText(){
      // top bar
      const brandEl = document.getElementById('uiBrand');
      const modeLabelEl = document.getElementById('uiModeLabel');
      if (brandEl) brandEl.textContent = T.brand;
      if (modeLabelEl) modeLabelEl.textContent = T.modeTeacher;

      // teacher panel
      const sc = document.getElementById('uiSessionCodeLabel');
      const share = document.getElementById('uiShareNote');
      const tl = document.getElementById('uiTargetLettersLabel');
      const cpc = document.getElementById('uiCardsPerColLabel');
      const storageNote = document.getElementById('uiStorageNote');

      if (sc) sc.textContent = T.sessionCode;
      if (share) share.textContent = T.shareNote;
      if (tl) tl.textContent = T.targetLetters;
      if (cpc) cpc.textContent = T.cardsPerCol;

      // buttons (teacher + solo + inline)
      const btnJoin = document.getElementById('btnJoin');
      const btnNewRound = document.getElementById('btnNewRound');
      const btnVerify = document.getElementById('btnVerify');
      const btnReset = document.getElementById('btnReset');

      const soloNewRound = document.getElementById('soloNewRound');
      const soloVerify = document.getElementById('soloVerify');
      const soloReset = document.getElementById('soloReset');

      const inlineVerify = document.getElementById('inlineVerify');
      const inlineReset = document.getElementById('inlineReset');

      if (btnJoin) btnJoin.textContent = T.join;
      if (btnNewRound) btnNewRound.textContent = T.newRound;
      if (btnVerify) btnVerify.textContent = T.verify;
      if (btnReset) btnReset.textContent = T.reset;

      if (soloNewRound) soloNewRound.textContent = T.newRound;
      if (soloVerify) soloVerify.textContent = T.verify;
      if (soloReset) soloReset.textContent = T.reset;

      if (inlineVerify) inlineVerify.textContent = T.verify;
      if (inlineReset) inlineReset.textContent = T.reset;

      // student panel
      const studentRoom = document.getElementById('studentRoom');
      const btnStudentJoin = document.getElementById('btnStudentJoin');
      if (studentRoom) studentRoom.placeholder = T.studentRoomPh;
      if (btnStudentJoin) btnStudentJoin.textContent = T.studentJoin;

      // rack header
      const cardsHeader = document.getElementById('uiCardsHeader');
      if (cardsHeader) cardsHeader.textContent = T.cardsHeader;

      // storage note (HTML)
      if (storageNote) {
        storageNote.innerHTML = `${T.storageNote}<div id="storageWarn" class="warn" style="display:none"></div>`;
      }
    }

    applyUiText();

    // Special parser for ?words= that keeps "u,," together (√º marker)
    function parseWordsParam(raw) {
      const s = (raw || '').trim();
      if (!s) return [];
      const out = [];
      let cur = '';
      for (let i = 0; i < s.length; i++) {
        const ch = s[i];
        if (ch === ',') {
          const prev = s[i - 1];
          const next = s[i + 1];
          // Treat "u,," as part of the word, not a separator
          if (prev === 'u' && next === ',') {
            cur += ',,';
            i++; // skip the second comma
            continue;
          }
          // normal separator
          if (cur.trim()) out.push(cur.trim());
          cur = '';
        } else {
          cur += ch;
        }
      }
      if (cur.trim()) out.push(cur.trim());
      return out;
    }

    const MODE = (qs.get('mode') || '').toLowerCase();       // includes: 'randinit' ‚úÖ
    const IB = qs.get('ib') || DEFAULT_IMAGES_BUCKET;
    const AB = qs.get('ab') || DEFAULT_AUDIO_BUCKET;
    const IP = qs.get('ip') || DEFAULT_IMAGES_PREFIX;
    const AP = qs.get('ap') || DEFAULT_AUDIO_PREFIX;

    const SOLO_LETTERS   = (qs.get('letters')   || '').split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
    const SOLO_SYLLABLES = (qs.get('syllables') || '').split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
    const SOLO_PER       = Math.max(1, Math.min(8, parseInt(qs.get('percategory') || qs.get('per') || '0', 10) || 0));
    const SOLO_WORDS     = parseWordsParam(qs.get('words') || '');
    const HIDE_TITLE     = (qs.get('hidetitle') || '').toLowerCase() === 'true';
    const LABEL_STYLE    = (qs.get('labelstyle') || 'classic').toLowerCase(); // classic | emoji
    // tiles-only (words instead of images) + hide-words
    const TILES_ONLY = (qs.get('tilesonly') || qs.get('wordtiles') || '').toLowerCase() === 'true';
    const HIDE_WORDS = (qs.get('hidewords') || '').toLowerCase() === 'true';

    // ‚úÖ NEW: random-initial pool for ?mode=randinit&pool=b,m,s,ch,ll,rr
    const RANDINIT_POOL = (qs.get('pool') || qs.get('randpool') || '')
      .split(',')
      .map(s => s.trim().toLowerCase())
      .filter(Boolean);

    // syllable match mode ('initial' | 'any') and comparator ('equals' | 'contains' | 'prefix' | 'suffix')
    const SYLL_MATCH = (qs.get('syllmatch') || 'initial').toLowerCase();
    const SYLL_CMP   = (qs.get('syllcmp')   || 'equals').toLowerCase();
    // syllable-count columns via ?counts=1-3 or ?syllcount=1,2,3
    function parseCountsParam(v){
      const raw = (v||'').trim();
      if(!raw) return [];
      if(/^\d+\s*-\s*\d+$/.test(raw)){
        const [a,b] = raw.split('-').map(x=>parseInt(x.trim(),10));
        if(Number.isFinite(a) && Number.isFinite(b)){
          const lo = Math.min(a,b), hi = Math.max(a,b);
          return Array.from({length: hi-lo+1}, (_,i)=> lo+i);
        }
      }
      return raw.split(',').map(s=>parseInt(s.trim(),10)).filter(n=>Number.isFinite(n) && n>0);
    }
    const SOLO_SYLLCOUNT = parseCountsParam(qs.get('counts') || qs.get('syllcount'));
    // stressed-syllable positions via ?stress=1,2,3
    const SOLO_STRESSPOS = parseCountsParam(qs.get('stress') || qs.get('stresspos'));
    
    // Optional custom column titles: ?titles=s√≠,no,maybe
    const COL_TITLES = (qs.get('titles') || '')
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);

    // Row modes params
    const ROWS_RAW   = qs.get('rows') || '';
    const ROW_TITLE  = (qs.get('rowtitle') || '').toLowerCase() === 'true';

    // Force SOLO by default unless ?sync=true
    const SYNC = (qs.get('sync') || '').toLowerCase() === 'true';
    if (!SYNC) {
      document.addEventListener('DOMContentLoaded', () => {
        teacherPanel.classList.add('hidden');
        studentPanel.classList.add('hidden');
        document.querySelector('.switch')?.classList.add('hidden');
      });
    }

    // SOLO conditions
    const SOLO_MODE =
      !SYNC ||
      MODE === 'randinit' ||  /* ‚úÖ NEW */
      MODE === 'row' || MODE === 'rowalli' || MODE === 'allisort' || MODE === 'allisyll' || MODE === 'rowsyll' || MODE === 'syllcount' || MODE === 'stress' || MODE === 'stressreveal' ||
      (SOLO_LETTERS.length > 0) || (SOLO_SYLLABLES.length > 0) || (SOLO_WORDS.length > 0) || (SOLO_SYLLCOUNT.length > 0) || (SOLO_STRESSPOS.length > 0);

    const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /******** UI refs ********/
    const storageWarn   = document.getElementById('storageWarn');
    const modeToggle    = document.getElementById('modeToggle');
    const teacherPanel  = document.getElementById('teacherPanel');
    const studentPanel  = document.getElementById('studentPanel');
    const btnJoin       = document.getElementById('btnJoin');
    const roomCodeEl    = document.getElementById('roomCode');
    const studentRoomEl = document.getElementById('studentRoom');
    const btnStudentJoin= document.getElementById('btnStudentJoin');
    const letterPicker  = document.getElementById('letterPicker');
    const cardsPerColEl = document.getElementById('cardsPerCol');
    const columnsEl     = document.getElementById('columns');
    const rackSectionEl = document.getElementById('rackSection');
    const rackEl        = document.getElementById('rack');
    const btnNewRound   = document.getElementById('btnNewRound');
    const btnVerify     = document.getElementById('btnVerify');
    const btnReset      = document.getElementById('btnReset');
    const soloPill      = document.getElementById('soloPill');

    // Solo toolbar refs
    const soloBar        = document.getElementById('soloBar');
    const soloNewRoundBtn= document.getElementById('soloNewRound');
    const soloVerifyBtn  = document.getElementById('soloVerify');
    const soloResetBtn   = document.getElementById('soloReset');

    // Inline (under bank)
    const inlineVerifyBtn= document.getElementById('inlineVerify');
    const inlineResetBtn = document.getElementById('inlineReset');

    // Row mode refs
    const rowModeEl   = document.getElementById('rowMode');

    // Stress reveal scene
    const stressRevealEl = document.getElementById('stressRevealScene');

    /******** State ********/
    let ROOM = null, channel = null, isTeacher = false;

    // imageFiles entry: { name, path, url, stem, rawCore, core, initial }
    let imageFiles = [];
    // audio map and cache
    const audioUrlByRawCore = new Map();     // rawCore -> mp3 URL
    const audioElByRawCore  = new Map();     // rawCore -> preloaded HTMLAudioElement

    let currentCols = [], currentCards = [], usedSet = new Set();

    // Row mode state
    let rowData = []; // generic holder for any row-mode

    /******** Helpers ********/
    function markersToPretty(s){
      return (s||'')
        .replace(/a\.\./g,'√°').replace(/e\.\./g,'√©').replace(/i\.\./g,'√≠').replace(/o\.\./g,'√≥').replace(/u\.\./g,'√∫')
        .replace(/n\.\./g,'√±').replace(/u,,/g,'√º');
    }
    function stripDiacritics(s){
      return (s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    }
    function extOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(i+1).toLowerCase() : ''; }
    function stemOf(name){ const i=name.lastIndexOf('.'); return i>=0 ? name.slice(0,i) : name; }
    function stripImageSuffix(t){ return t.replace(/_(pic|img|image|foto)$/i,''); }
    function normalizeMarkers(s){
      let t = (s || '').toLowerCase().trim();
      t = t.replace(/a\.\./g,'a').replace(/e\.\./g,'e').replace(/i\.\./g,'i').replace(/o\.\./g,'o').replace(/u\.\./g,'u');
      t = t.replace(/u,,/g,'u').replace(/n\.\./g,'n');
      t = stripDiacritics(t);
      return t;
    }
    function initialFromStem(stemRaw){
      const raw = (stemRaw || '').toLowerCase();
      if(raw.startsWith('n..')) return '√±';
      const s = normalizeMarkers(raw);
      if(s.startsWith('ch')) return 'ch';
      if(s.startsWith('ll')) return 'll';
      if(s.startsWith('rr')) return 'rr';
      return s[0] || '';
    }

    // -----------------------------
    // Syllabify (ES + EN)
    // -----------------------------

    function syllabifyEs(wordRaw){
      const word = (wordRaw || '').toLowerCase();
      const isV = ch => /[aeiou√°√©√≠√≥√∫√º]/.test((ch||'')[0] || '');
      const isWeakUnaccented = ch => /^(i|u|√º)$/.test((ch||'')[0] || '');
      const isAccWeak = ch => /[√≠√∫]/.test((ch||'')[0] || '');
      const onsetPairs = ['pl','pr','bl','br','tr','dr','cl','cr','gl','gr','fl','fr','ch','ll','rr'];

      const chars = [];
      for (let i=0;i<word.length;i++){
        const two = word.slice(i, i+2);
        if (['ch','ll','rr'].includes(two)) { chars.push(two); i++; continue; }
        if (word[i]==='q' && word[i+1]==='u' && /[ei√©√≠]/.test(word[i+2]||'')) { chars.push('qu'); i++; continue; }
        if (word[i]==='g' && word[i+1]==='u' && /[ei√©√≠]/.test(word[i+2]||'') && word[i+1]!=='√º'){ chars.push('gu'); i++; continue; }
        chars.push(word[i]);
      }

      const syl = []; let i = 0;
      while (i < chars.length){
        let onset = [];
        while (i < chars.length && !isV(chars[i])) onset.push(chars[i++]);

        if (i >= chars.length){
          if (syl.length) syl[syl.length-1] += onset.join('');
          else syl.push(onset.join(''));
          break;
        }

        let nuc = [chars[i++]];
        for (let k = 0; k < 2 && i < chars.length && isV(chars[i]); k++){
          const prev = nuc[nuc.length-1], next = chars[i];
          const canJoin =
            ((isWeakUnaccented(prev) && !isAccWeak(prev)) && !isAccWeak(next)) ||
            ((isWeakUnaccented(next) && !isAccWeak(next)) && !isAccWeak(prev)) ||
            (isWeakUnaccented(prev) && isWeakUnaccented(next));
          if (canJoin) { nuc.push(next); i++; } else break;
        }

        let after = [];
        while (i < chars.length && !isV(chars[i])) after.push(chars[i++]);

        let coda = [], nextOnset = after.slice();
        if (nextOnset.length){
          let m = 0;
          while (nextOnset.length - m >= 2){
            const a = nextOnset[m], b = nextOnset[m+1];
            const pair = (a + b).replace(/[^a-z√±]/g,'');
            if (onsetPairs.includes(pair)) break;
            m++;
          }
          coda = nextOnset.slice(0, m);
          nextOnset = nextOnset.slice(m);
          while (nextOnset.length > 2) coda.push(nextOnset.shift());
        }

        syl.push(onset.join('') + nuc.join('') + coda.join(''));
        if (nextOnset.length) i -= nextOnset.length;
      }
      return syl.filter(Boolean).map(s => s.trim());
    }

function syllabifyEn(wordRaw){
  let w = (wordRaw || '').toLowerCase().trim();
  w = w.replace(/[^a-z']/g,'');
  if (!w) return [];

  const isVowel = ch => /[aeiouy]/.test(ch || '');

  // Detect consonant + "le" ending (table, tricycle, rifle...)
  const endsWithConsonantLe =
    w.endsWith('le') &&
    w.length >= 3 &&
    !isVowel(w[w.length - 3]);

  // If it‚Äôs consonant+le, peel off the final syllable now
  let leTail = '';
  if (endsWithConsonantLe) {
    leTail = w.slice(-3);   // e.g. "cle"
    w = w.slice(0, -3);     // rest of word
    if (!w) return [leTail];
  }

  // Find vowel groups in the remaining base word
  const groups = [];
  let i = 0;
  while (i < w.length){
    const ch = w[i];
    if (isVowel(ch)) {
      let j = i + 1;
      while (j < w.length && isVowel(w[j])) j++;
      groups.push([i, j]);
      i = j;
    } else {
      i++;
    }
  }

  let count = groups.length;

  // Silent "e" on base word only (we already handled consonant+le separately)
  if (w.endsWith('e') && count > 1) count -= 1;

  // "ed" syllable add-back (wanted, ended)
  if (w.endsWith('ed') && w.length >= 3) {
    const prev = w[w.length - 3];
    if (prev === 't' || prev === 'd') count += 1;
  }

  if (count <= 0) count = 1;

  // Cut at vowel-group starts (except first)
  const cutPoints = groups.slice(1).map(g => g[0]);
  const syl = [];
  let start = 0;
  for (const cp of cutPoints){
    if (cp <= start) continue;
    syl.push(w.slice(start, cp));
    start = cp;
  }
  syl.push(w.slice(start));

  // If we still have a trailing lone 'e', merge it (ONLY for non -le endings)
  // (This is now safe because consonant+le was removed earlier.)
  if (syl.length > 1 && syl[syl.length - 1] === 'e') {
    syl[syl.length - 2] += 'e';
    syl.pop();
  }

  // Force slice count down to computed count by merging from the end
  while (syl.length > count && syl.length > 1) {
    syl[syl.length - 2] += syl[syl.length - 1];
    syl.pop();
  }

  // Put consonant+le syllable back as its own syllable
  if (leTail) syl.push(leTail);

  return syl.filter(Boolean);
}

    function syllabifyByLang(wordPrettyOrRaw){
      if (LANG === 'en') return syllabifyEn(wordPrettyOrRaw);
      return syllabifyEs(wordPrettyOrRaw);
    }

    function syllablesNormalized(coreWord){
      const pretty = markersToPretty(coreWord);
      return syllabifyByLang(pretty).map(normalizeMarkers);
    }
    function syllableCount(coreWord){
      return syllablesNormalized(coreWord).length;
    }

    // Spanish stress logic (kept as-is)
    function stressedSyllIndex(coreWordRaw){
      const pretty = markersToPretty((coreWordRaw || '').toLowerCase());
      const syls = syllabifyEs(pretty);
      if (!syls.length) return 1;

      let stressed = -1;
      for (let i = 0; i < syls.length; i++){
        if (/[√°√©√≠√≥√∫]/.test(syls[i])) {
          stressed = i;
          break;
        }
      }

      if (stressed === -1) {
        const plain = stripDiacritics(pretty);
        const lastChar = plain[plain.length - 1] || '';
        const endsVowel = /[aeiou]/.test(lastChar);
        const endsNOrS  = /[ns]/.test(lastChar);
        if (endsVowel || endsNOrS) stressed = Math.max(0, syls.length - 2);
        else stressed = syls.length - 1;
      }

      if (stressed < 0 || stressed >= syls.length) stressed = syls.length - 1;
      const fromRight = syls.length - stressed;
      return fromRight;
    }

    function cmpSyll(a, b){
      if(!a || !b) return false;
      switch (SYLL_CMP) {
        case 'contains': return a.includes(b);
        case 'prefix':   return a.startsWith(b);
        case 'suffix':   return a.endsWith(b);
        default:         return a === b;
      }
    }

    async function publicUrlIfExists(bucket, path){
      const { data } = client.storage.from(bucket).getPublicUrl(path);
      const url = data?.publicUrl;
      if(!url) return null;
      try {
        const r = await fetch(url, { method:'GET', headers:{ Range:'bytes=0-0' } });
        if (r.ok) return url;
      } catch {}
      return null;
    }
    function jpgCandidatesForWord(word){
      const wMarker = (word||'').toLowerCase();
      const wPretty = markersToPretty(word||'').toLowerCase();
      const wPlain  = stripDiacritics(wPretty);
      const prefix = IP ? `${IP.replace(/\/$/,'')}/` : '';
      const names = [
        `${wMarker}_pic.jpg`,
        `${wPretty}_pic.jpg`,
        `${wPlain}_pic.jpg`,
      ];
      return names.map(n => `${prefix}${n}`);
    }
    async function resolveImageForWord(word){
      for(const p of jpgCandidatesForWord(word)){
        const url = await publicUrlIfExists(IB, p);
        if (url) {
          const name = p.split('/').pop();
          const stem = stemOf(name);
          const rawCore = stripImageSuffix(stem);
          return {
            name, path:p, url, stem,
            rawCore, core: normalizeMarkers(rawCore),
            initial: initialFromStem(stem)
          };
        }
      }
      return null;
    }

    async function listAll(bucket, prefix) {
      const path = prefix && prefix.trim() !== "" ? prefix : undefined;
      let out = [], offset = 0, limit = 100;
      while (true) {
        const { data, error } = await client.storage.from(bucket).list(path, {
          limit, offset, sortBy:{column:'name', order:'asc'}
        });
        if (error) throw error;
        const items = data || [];
        for (const it of items) {
          const fullpath = path ? `${path.replace(/\/$/,'')}/${it.name}` : it.name;
          if (!it.metadata) {
            out.push(...(await listAll(bucket, fullpath)));
          } else {
            out.push({ ...it, fullpath });
          }
        }
        if (items.length < limit) break;
        offset += limit;
      }
      return out;
    }
    async function listAllImagesJpg(){
      const files = await listAll(IB, IP);
      const out = [];
      for (const f of files){
        const base = f.fullpath.split('/').pop() || f.fullpath;
        if (extOf(base) !== 'jpg') continue;
        const { data } = client.storage.from(IB).getPublicUrl(f.fullpath);
        if (data?.publicUrl){
          const stem = stemOf(base);
          const rawCore = stripImageSuffix(stem);
          out.push({
            name: base, path: f.fullpath, url: data.publicUrl,
            stem, rawCore, core: normalizeMarkers(rawCore),
            initial: initialFromStem(stem)
          });
        }
      }
      return out;
    }

    async function resolveAudioForRawCore(rawCore){
      const prefix = AP ? `${AP.replace(/\/$/,'')}/` : '';
      const p = `${prefix}${rawCore}.mp3`;
      const url = await publicUrlIfExists(AB, p);
      return url;
    }
    async function ensureAudioUrl(rawCore){
      if (audioUrlByRawCore.has(rawCore)) return audioUrlByRawCore.get(rawCore);
      const url = await resolveAudioForRawCore(rawCore);
      if (url) audioUrlByRawCore.set(rawCore, url);
      return url;
    }
    async function preloadAudioForCores(rawCores){
      const uniq = Array.from(new Set(rawCores));
      await Promise.all(uniq.map(async k=>{
        const url = await ensureAudioUrl(k);
        if (url && !audioElByRawCore.has(k)){
          const a = new Audio();
          a.preload = 'auto';
          a.src = url;
          try{ a.load(); }catch{}
          audioElByRawCore.set(k, a);
        }
      }));
    }
    async function playWordAudio(rawCore){
      let a = audioElByRawCore.get(rawCore);
      if (!a){
        const url = await ensureAudioUrl(rawCore);
        if (!url) return;
        a = new Audio(url);
        audioElByRawCore.set(rawCore, a);
      }
      try{ a.currentTime = 0; }catch{}
      try{ await a.play(); }catch{}
    }

    async function ensureStorageLoaded(){
      try{
        imageFiles = [];

        if (TILES_ONLY && SOLO_WORDS.length > 0 &&
            MODE!=='row' && MODE!=='rowalli' && MODE!=='allisort' &&
            MODE!=='allisyll' && MODE!=='rowsyll' && MODE!=='syllcount' && MODE!=='stressreveal') {
          if (storageWarn) storageWarn.style.display = 'none';
          return;
        }

        if (MODE==='row' || MODE==='rowalli' || MODE==='allisort' || MODE==='allisyll' || MODE==='rowsyll' || MODE==='syllcount'){
          imageFiles = await listAllImagesJpg();
        } else if (SOLO_WORDS.length){
          const found = [];
          for (const w of SOLO_WORDS){
            const f = await resolveImageForWord(w);
            if (f) found.push(f);
          }
          imageFiles = (found.length === SOLO_WORDS.length) ? found : await listAllImagesJpg();
        } else {
          imageFiles = await listAllImagesJpg();
        }

        if (storageWarn){
          storageWarn.style.display = imageFiles.length ? 'none' : 'block';
          if (!imageFiles.length){
            storageWarn.textContent = T.warnNoImages(IB, IP);
          }
        }
      } catch(err){
        if (storageWarn){
          storageWarn.style.display = 'block';
          storageWarn.textContent = `Error: ${err?.message || err}`;
        }
      }
    }

    let currentMode = MODE || 'classic';
    async function joinRoom(room){
      if(channel){ try{ await channel.unsubscribe(); }catch{} }
      ROOM = (room||'').trim();
      if(!ROOM){ alert(T.alertInvalidRoom); return; }

      channel = client.channel(`lettersort:${ROOM}`);
      channel.on('broadcast', { event:'ROUND' }, p=>{
        const d=p.payload;
        buildColumns(d.columns);
        setCards(d.cards);
        clearAllPlacements();
      });
      channel.on('broadcast', { event:'VERIFY' }, ()=> verifyNow(true));
      channel.on('broadcast', { event:'RESET' }, ()=> resetRoundPlacements());

      const { error } = await channel.subscribe();
      if(error){ alert(T.alertRealtimeErr); console.error(error); }
    }

    function labelTextFor(letter, type){
      if (LABEL_STYLE === 'emoji') {
        return type==='is' ? T.labels.emojiIs(letter) : T.labels.emojiNot(letter);
      }
      return type==='is' ? T.labels.is(letter) : T.labels.not(letter);
    }

    function applyTitleOverrides(cols){
      if (!COL_TITLES.length) return cols;
      return cols.map((c, idx) => ({
        ...c,
        label: COL_TITLES[idx] || c.label
      }));
    }

    function buildColumnsForLetters(activeLetters){
      const columns = [];
      if(activeLetters.length===1){
        const L = activeLetters[0];
        columns.push({label:labelTextFor(L,'is'),  key:`${L}`});
        columns.push({label:labelTextFor(L,'not'), key:`not-${L}`});
      } else {
        activeLetters.forEach(L=> columns.push({label:labelTextFor(L,'is'), key:`${L}`}));
      }
      return applyTitleOverrides(columns);
    }

    function buildColumnsForSyllables(sylls){
      const cols = sylls.map(s => ({ label: s, key:`syll:${normalizeMarkers(s)}`, display:s }));
      return applyTitleOverrides(cols);
    }

    function buildColumnsForSyllCount(counts){
      const cols = counts.map(n => ({
        label: (n===1 ? T.labels.syllOne(n) : T.labels.syllMany(n)),
        key: `count:${n}`,
        display: `${n}`
      }));
      return applyTitleOverrides(cols);
    }

    function buildColumnsForStress(positions){
      const cols = positions.map(p => {
        const base = T.labels.stressBase(p);
        return {
          label: T.labels.stressLabel(base),
          key: `stress:${p}`,
          display: String(p)
        };
      });
      return applyTitleOverrides(cols);
    }

    function backgroundUrlFromParam(){
      const bg = qs.get('bg') || qs.get('background') || '';
      if (!bg) return null;
      const prefix = IP ? `${IP.replace(/\/$/,'')}/` : '';
      const full = `${prefix}${bg}`;
      const { data } = client.storage.from(IB).getPublicUrl(full);
      return data?.publicUrl || null;
    }

    function buildStressRevealScene(cards){
      if (!stressRevealEl) return;
      const bgUrl = backgroundUrlFromParam();
      if (!bgUrl){
        stressRevealEl.classList.add('hidden');
        stressRevealEl.innerHTML = '';
        return;
      }

      const wrapper = document.createElement('div');
      wrapper.className = 'stress-bg-wrapper';

      const img = document.createElement('img');
      img.src = bgUrl;
      img.alt = '';
      wrapper.appendChild(img);

      const n = cards.length || 0;
      const cols = Math.min(3, Math.max(1, n >= 6 ? 3 : (n >= 3 ? 2 : 1)));
      const rows = Math.ceil(n / cols) || 1;

      cards.forEach((card, idx) => {
        const blob = document.createElement('div');
        blob.className = 'revealBlob';
        blob.dataset.cardId = card.id;

        const col = idx % cols;
        const row = Math.floor(idx / cols);
        const left = 12 + col * (76 / (cols - 1 || 1));
        const top  = 15 + row * (65 / (rows - 1 || 1));

        blob.style.left = `${left}%`;
        blob.style.top  = `${top}%`;
        blob.textContent = String(idx + 1);

        wrapper.appendChild(blob);
      });

      stressRevealEl.innerHTML = '';
      stressRevealEl.appendChild(wrapper);
      stressRevealEl.classList.remove('hidden');
    }

    function revealBlobForCard(card){
      if (!stressRevealEl || !card) return;
      const blob = stressRevealEl.querySelector(`.revealBlob[data-card-id="${card.id}"]`);
      if (blob) blob.classList.add('hiddenBlob');
    }

    function pickNoRepeat(arr, n){
      const pool = arr.filter(x=>!usedSet.has(`${x.path}`));
      pool.sort(()=>Math.random()-0.5);
      const chosen = pool.slice(0,n);
      if(chosen.length < n){
        const more = arr.filter(x=>!chosen.includes(x));
        more.sort(()=>Math.random()-0.5);
        chosen.push(...more.slice(0, n - chosen.length));
      }
      return chosen;
    }

    function buildRoundFromLetters(activeLetters, perCol){
      const columns = buildColumnsForLetters(activeLetters);
      const byInitial = (()=>{
        const m=new Map();
        for(const f of imageFiles){
          if(!m.has(f.initial)) m.set(f.initial, []);
          m.get(f.initial).push(f);
        }
        return m;
      })();
      const everything = [...imageFiles];
      const cards = [];
      for(const col of columns){
        let picks=[];
        if(col.key.startsWith('not-')){
          const L = col.key.slice(4);
          picks = pickNoRepeat(everything.filter(f => f.initial !== L), perCol);
        } else {
          const L = col.key;
          picks = pickNoRepeat(byInitial.get(L) || [], perCol);
        }
        for(const f of picks){ usedSet.add(`${f.path}`); }
        for(const f of picks){
          cards.push({ id: crypto.randomUUID(), imgUrl: f.url, word: f.stem, coreRaw: f.rawCore });
        }
      }
      return { columns, cards };
    }

    // ‚úÖ NEW: random initial-sound round builder (2 columns: is/not)
    function buildRoundFromRandomInitial(pool, perCol){
      const clean = (pool || []).map(s=>String(s).trim().toLowerCase()).filter(Boolean);
      const fallback = SOLO_LETTERS.length ? SOLO_LETTERS : ['a'];
      const picked = (clean.length ? clean : fallback)[Math.floor(Math.random() * (clean.length ? clean : fallback).length)];
      return buildRoundFromLetters([picked], perCol);
    }

    function buildRoundFromSyllables(sylls, perCol){
      const columns = buildColumnsForSyllables(sylls);
      const cards = [];
      for(const col of columns){
        const targetSyl = col.key.slice(5);
        const list = imageFiles.filter(f => {
          const syls = syllablesNormalized(f.rawCore);
          return SYLL_MATCH === 'any'
            ? syls.some(s => cmpSyll(s, targetSyl))
            : cmpSyll(syls[0], targetSyl);
        });
        const picks = pickNoRepeat(list, perCol);
        for(const f of picks){ usedSet.add(`${f.path}`); }
        for(const f of picks){
          cards.push({ id: crypto.randomUUID(), imgUrl: f.url, word: f.stem, coreRaw: f.rawCore });
        }
      }
      return { columns, cards };
    }

    function buildRoundFromSyllCount(counts, perCol){
      const columns = buildColumnsForSyllCount(counts);
      const cards = [];
      for(const col of columns){
        const need = parseInt(col.key.slice(6),10);
        const list = imageFiles.filter(f => syllableCount(f.rawCore) === need);
        const picks = pickNoRepeat(list, perCol);
        for(const f of picks){ usedSet.add(`${f.path}`); }
        for(const f of picks){
          cards.push({ id: crypto.randomUUID(), imgUrl: f.url, word: f.stem, coreRaw: f.rawCore });
        }
      }
      return { columns, cards };
    }

    function buildRoundFromStress(positions, perCol){
      const columns = buildColumnsForStress(positions);
      const cards = [];
      for (const col of columns){
        const pos = parseInt(col.key.slice(7),10);
        const list = imageFiles.filter(f => stressedSyllIndex(f.rawCore) === pos);
        const picks = pickNoRepeat(list, perCol);
        for (const f of picks){ usedSet.add(`${f.path}`); }
        for (const f of picks){
          cards.push({ id: crypto.randomUUID(), imgUrl: f.url, word: f.stem, coreRaw: f.rawCore });
        }
      }
      return { columns, cards };
    }

    function buildRoundFromWordList(activeLetters, sylls, wordsList){
      const columns = (sylls && sylls.length)
        ? buildColumnsForSyllables(sylls)
        : buildColumnsForLetters(activeLetters);

      if (TILES_ONLY) {
        const cards = wordsList.map(wRaw => ({
          id: crypto.randomUUID(),
          imgUrl: '',
          word: wRaw,
          coreRaw: wRaw
        }));
        return { columns, cards };
      }

      const indexNorm = new Map();
      for(const f of imageFiles){
        const k = normalizeMarkers(f.rawCore);
        if(!indexNorm.has(k)) indexNorm.set(k, f);
      }

      const cards = [];
      for(const wRaw of wordsList){
        const k = normalizeMarkers(wRaw);
        const f = indexNorm.get(k);
        if(!f) continue;
        cards.push({ id: crypto.randomUUID(), imgUrl: f.url, word: f.stem, coreRaw: f.rawCore });
      }
      return { columns, cards };
    }

    function buildRoundFromWordListWithCounts(counts, wordsList){
      const columns = buildColumnsForSyllCount(counts);

      if (TILES_ONLY) {
        const cards = wordsList.map(wRaw => ({
          id: crypto.randomUUID(),
          imgUrl: '',
          word: wRaw,
          coreRaw: wRaw
        }));
        return { columns, cards };
      }

      const indexNorm = new Map();
      for(const f of imageFiles){
        const k = normalizeMarkers(f.rawCore);
        if(!indexNorm.has(k)) indexNorm.set(k, f);
      }

      const cards = [];
      for(const wRaw of wordsList){
        const k = normalizeMarkers(wRaw);
        const f = indexNorm.get(k);
        if(!f) continue;
        cards.push({ id: crypto.randomUUID(), imgUrl: f.url, word: f.stem, coreRaw: f.rawCore });
      }
      return { columns, cards };
    }

    function buildRoundFromWordListWithStress(positions, wordsList){
      const columns = buildColumnsForStress(positions);

      if (TILES_ONLY) {
        const cards = wordsList.map(wRaw => ({
          id: crypto.randomUUID(),
          imgUrl: '',
          word: wRaw,
          coreRaw: wRaw
        }));
        return { columns, cards };
      }

      const indexNorm = new Map();
      for(const f of imageFiles){
        const k = normalizeMarkers(f.rawCore);
        if(!indexNorm.has(k)) indexNorm.set(k, f);
      }

      const cards = [];
      for(const wRaw of wordsList){
        const k = normalizeMarkers(wRaw);
        const f = indexNorm.get(k);
        if(!f) continue;
        cards.push({ id: crypto.randomUUID(), imgUrl: f.url, word: f.stem, coreRaw: f.rawCore });
      }
      return { columns, cards };
    }

    function setOneRowGrid(colsCount){
      columnsEl.style.gridTemplateColumns = `repeat(${colsCount}, minmax(140px, 1fr))`;
    }

    function renderHeaderHTML(col){
      if (col.key.startsWith('syll:')) {
        if (HIDE_TITLE) return '';
        const fallback = (col.display || '').toLowerCase();
        const text = col.label || fallback;
        return `<div class="syllTile" aria-hidden="true">${text}</div>`;
      }

      if (col.key.startsWith('count:')){
        if (HIDE_TITLE) return '';
        const n = parseInt(col.display || col.key.slice(6),10);
        const defaultLabel = (n===1 ? T.labels.syllOne(n) : T.labels.syllMany(n));
        const text = col.label || defaultLabel;
        return `<div class="syllTile" aria-hidden="true">${text}</div>`;
      }

      if (col.key.startsWith('stress:')){
        if (HIDE_TITLE) return '';
        const posRaw = parseInt(col.display || col.key.slice(7),10);
        const totalDots = 3;

        let pos = Number.isFinite(posRaw) ? posRaw : 1;
        let idxFromLeft = totalDots - pos;
        const targetIdx = Math.min(totalDots-1, Math.max(0, idxFromLeft));

        const dots = Array.from({ length: totalDots }, (_, i) =>
          `<span class="stressDot${i === targetIdx ? ' target' : ''}"></span>`
        ).join('');

        return `<div class="stressCounters" aria-hidden="true">${dots}</div>`;
      }

      return `<h2>${col.label}</h2>`;
    }

    function buildColumns(columns){
      currentCols = columns;
      columnsEl.innerHTML='';
      setOneRowGrid(columns.length);
      columns.forEach((c, idx)=>{
        const col = document.createElement('div');
        col.className='col';
        col.innerHTML = `
          <header>${renderHeaderHTML(c)}</header>
          <div class="drop" data-col="${idx}"></div>`;
        columnsEl.appendChild(col);
      });
      const per = Math.max(1, Math.min(8, parseInt(cardsPerColEl.value||'4',10)));
      document.body.classList.toggle('one-per', per === 1);
    }

    function setCards(cards){
      currentCards = [...cards];
      rackEl.innerHTML='';
      const ordered = (new URLSearchParams(location.search).get('words')||'').length ? [...currentCards] : currentCards.sort(()=>Math.random()-0.5);
      ordered.forEach(card=> rackEl.appendChild(renderCard(card)) );
      preloadAudioForCores(ordered.map(c=>c.coreRaw));
    }

    function attachWordCover(tileEl){
      const cover = document.createElement('button');
      cover.type = 'button';
      cover.className = 'wordCover';

      cover.addEventListener('pointerdown', ev => { ev.stopPropagation(); });
      cover.addEventListener('click', ev => {
        ev.stopPropagation();
        ev.preventDefault();
        cover.remove();
      });

      tileEl.appendChild(cover);
    }

    let lastDragEndedAt = 0;
    function renderCard(card, opts={}){
      const el = document.createElement('div');
      el.className = 'card' + (opts.rowCard ? ' rowCard' : '');
      el.dataset.id = card.id;
      if (opts.rowIndex != null) el.dataset.row = String(opts.rowIndex);
      el.setAttribute('tabindex','0');

      const labelText = markersToPretty(card.coreRaw || card.word || card.stem || '');

      if (TILES_ONLY) {
        el.classList.add('wordTile');
        el.innerHTML = `<div class="cap">${labelText || '&nbsp;'}</div>`;
      } else {
        el.innerHTML = `
          <img alt="" src="${card.imgUrl}"/>
          <div class="cap" ${ROW_TITLE ? '' : 'style="display:none"'}>${ROW_TITLE ? (markersToPretty(card.coreRaw) || '') : '&nbsp;'}</div>
        `;
      }

      el.addEventListener('click', async (ev) => {
        if (ev.target && ev.target.classList && ev.target.classList.contains('wordCover')) return;
        if (Date.now() - lastDragEndedAt < 150) return;
        if (card.coreRaw) playWordAudio(card.coreRaw);
      });

      if (TILES_ONLY && HIDE_WORDS) attachWordCover(el);

      makeDraggable(el, opts.rowScope ? String(opts.rowIndex) : null);
      return el;
    }

    function renderChip(word, id){
      const el = document.createElement('div');
      el.className = 'chip';
      el.dataset.id = id || crypto.randomUUID();
      el.textContent = markersToPretty(word);
      el.setAttribute('tabindex','0');

      el.classList.add('wordTile');
      if (HIDE_WORDS) attachWordCover(el);

      makeDraggable(el, null);
      return el;
    }

    function clearAllPlacements(){
      document.querySelectorAll('.drop').forEach(d=>d.innerHTML='');
      rackEl.innerHTML='';
      const ordered = (new URLSearchParams(location.search).get('words')||'').length ? [...currentCards] : currentCards.sort(()=>Math.random()-0.5);
      ordered.forEach(card=> rackEl.appendChild(renderCard(card)) );
    }

    function resetRoundPlacements(){
      document.querySelectorAll('.card, .chip').forEach(c=> c.classList.remove('ok','bad','locked') );
      if (currentMode==='row' || currentMode==='rowalli' || currentMode==='allisyll' || currentMode==='rowsyll'){
        rowData.forEach((r)=>{ r.dropEl.innerHTML=''; });
        if (currentMode==='rowsyll'){
          rackEl.innerHTML = '';
          rackEl.classList.add('chips');
          SOLO_WORDS.forEach(w => rackEl.appendChild(renderChip(w)));
        } else {
          rowData.forEach((r, idx)=>{
            if (r.rackEl && r.cards){
              r.rackEl.innerHTML='';
              r.cards.forEach(c=> r.rackEl.appendChild(renderCard(c,{rowCard:true,rowIndex:idx,rowScope:true})));
            }
          });
        }
      } else {
        clearAllPlacements();
      }
    }

    function celebrate(){
      const cvs = document.createElement('canvas');
      cvs.className = 'celebrationCanvas';
      document.body.appendChild(cvs);
      const ctx = cvs.getContext('2d');
      let W, H, t0;
      const N = 180;
      const parts = [];
      function resize(){ W=window.innerWidth; H=window.innerHeight; cvs.width=W; cvs.height=H; }
      window.addEventListener('resize', resize); resize();
      for(let i=0;i<N;i++){
        parts.push({
          x: Math.random()*W,
          y: -20-Math.random()*H*0.2,
          vx: (-0.9 + Math.random()*1.8),
          vy: 2.0 + Math.random()*2.1,
          rot: Math.random()*Math.PI,
          vr: (-0.22 + Math.random()*0.44),
          size: 5 + Math.random()*6,
          hue: Math.floor(Math.random()*360)
        });
      }
      function tick(ts){
        if(!t0) t0=ts;
        const dt = Math.min(32, ts - t0); t0 = ts;
        ctx.clearRect(0,0,W,H);
        parts.forEach(p=>{
          const gravity = 0.011;
          const drag    = 0.004;
          p.vy += gravity * (dt/16);
          p.vx *= (1 - drag);
          p.vy *= (1 - drag*0.6);
          p.x += p.vx * (dt/16);
          p.y += p.vy * (dt/16);
          p.rot += p.vr * (dt/16);
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = `hsl(${p.hue} 80% 55%)`;
          ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
          ctx.restore();
        });
        if (parts.every(p=>p.y > H+30)) {
          document.body.removeChild(cvs);
        } else { requestAnimationFrame(tick); }
      }
      requestAnimationFrame(tick);
    }

    function parseRows(str){
      return str.split(';').map(seg=>seg.trim()).filter(Boolean).map(seg=>{
        const [left, right] = seg.split('~');
        const prompt = (left||'').trim();
        const choices = (right||'').split(',').map(s=>s.trim()).filter(Boolean);
        return { prompt, choices };
      }).filter(r=>r.prompt && r.choices.length);
    }
    function parseRowSyllDefs(str){
      return str.split(';').map(seg=>seg.trim()).filter(Boolean).map(seg=>{
        const [left] = seg.split('~');
        const [prompt, howRaw] = (left||'').split(':').map(s=>s.trim());
        const how = (howRaw||'init').toLowerCase()==='final' ? 'final' : 'init';
        return { prompt, how };
      }).filter(r=>r.prompt);
    }
    function parseAlliGroups(str){
      return str.split(';').map(seg=>seg.trim()).filter(Boolean).map(seg=>{
        const items = seg.split(',').map(s=>s.trim()).filter(Boolean);
        return items;
      }).filter(items=>items.length>=2);
    }
    function majorityInitial(rawCores){
      const m = new Map();
      for (const rc of rawCores){
        const ini = initialFromStem(rc);
        m.set(ini, (m.get(ini)||0)+1);
      }
      let bestI = null, bestC = -1;
      for (const [k,v] of m){ if (v>bestC){ bestC=v; bestI=k; } }
      return { initial: bestI || '', count: bestC<0 ? 0 : bestC };
    }
    function majorityInitialSyll(rawCores){
      const m = new Map();
      for (const rc of rawCores){
        const syls = syllablesNormalized(rc);
        const s0 = syls[0] || '';
        if (!s0) continue;
        m.set(s0, (m.get(s0) || 0) + 1);
      }
      let bestS = null, bestC = -1;
      for (const [k,v] of m){
        if (v > bestC){
          bestC = v;
          bestS = k;
        }
      }
      return { syll: bestS || '', count: bestC<0 ? 0 : bestC };
    }

    async function buildRowMode(){
      currentMode = 'row';
      document.body.classList.add('row-compact');
      columnsEl.classList.add('hidden');
      rackSectionEl.classList.add('hidden');
      rowModeEl.classList.remove('hidden');

      const rows = parseRows(ROWS_RAW);
      rowData = [];
      rowModeEl.innerHTML = '';

      for (let i=0;i<rows.length;i++){
        const r = rows[i];
        const pImg = await resolveImageForWord(r.prompt);
        if (!pImg) continue;

        const choiceImgs = [];
        for (const ch of r.choices){
          const ci = await resolveImageForWord(ch);
          if (ci) choiceImgs.push(ci);
        }
        if (!choiceImgs.length) continue;

        const coresToPreload = [pImg.rawCore, ...choiceImgs.map(c=>c.rawCore)];
        await preloadAudioForCores(coresToPreload);

        const line = document.createElement('div');
        line.className = 'rowLine';

        const promptWrap = document.createElement('div');
        promptWrap.className = 'rowPrompt';
        const pCard = document.createElement('div');
        pCard.className = 'card';
        pCard.innerHTML = `<img alt="" src="${pImg.url}"><div class="cap" style="display:${ROW_TITLE?'block':'none'}">${ROW_TITLE?markersToPretty(pImg.rawCore):'&nbsp;'}</div>`;
        pCard.addEventListener('click', ()=> playWordAudio(pImg.rawCore));
        promptWrap.appendChild(pCard);

        const drop = document.createElement('div');
        drop.className = 'rowDrop';
        drop.dataset.row = String(i);

        const rack = document.createElement('div');
        rack.className = 'rowRack';
        rack.dataset.row = String(i);

        line.appendChild(promptWrap);
        line.appendChild(drop);
        line.appendChild(rack);
        rowModeEl.appendChild(line);

        const cards = choiceImgs.map(ci => ({
          id: crypto.randomUUID(),
          imgUrl: ci.url,
          coreRaw: ci.rawCore
        }));
        cards.forEach(c=> rack.appendChild(renderCard(c,{rowCard:true,rowIndex:i,rowScope:true})));

        rowData.push({ type:'row', prompt:pImg, dropEl:drop, rackEl:rack, cards });
      }
    }

    async function buildRowAlliMode(){
      currentMode = 'rowalli';
      document.body.classList.add('row-compact');
      columnsEl.classList.add('hidden');
      rackSectionEl.classList.add('hidden');
      rowModeEl.classList.remove('hidden');

      const groups = parseAlliGroups(ROWS_RAW);
      rowData = [];
      rowModeEl.innerHTML = '';

      for (let i=0;i<groups.length;i++){
        const names = groups[i];

        const imgs = [];
        for (const w of names){
          const f = await resolveImageForWord(w);
          if (f) imgs.push(f);
        }
        if (imgs.length < 2) continue;

        const { initial: majInitial, count: majCount } = majorityInitial(imgs.map(x=>x.rawCore));
        await preloadAudioForCores(imgs.map(x=>x.rawCore));

        const line = document.createElement('div');
        line.className = 'rowLine twoCols';

        const drop = document.createElement('div');
        drop.className = 'rowDrop';
        drop.dataset.row = String(i);

        const rack = document.createElement('div');
        rack.className = 'rowRack';
        rack.dataset.row = String(i);

        line.appendChild(drop);
        line.appendChild(rack);
        rowModeEl.appendChild(line);

        const cards = imgs.map(ci => ({
          id: crypto.randomUUID(),
          imgUrl: ci.url,
          coreRaw: ci.rawCore
        }));
        cards.forEach(c=> rack.appendChild(renderCard(c,{rowCard:true,rowIndex:i,rowScope:true})));

        rowData.push({
          type:'rowalli',
          dropEl: drop,
          rackEl: rack,
          cards,
          expectedCount: majCount,
          majInitial
        });
      }
    }

    async function buildRowAlliSyllMode(){
      currentMode = 'allisyll';
      document.body.classList.add('row-compact');
      columnsEl.classList.add('hidden');
      rackSectionEl.classList.add('hidden');
      rowModeEl.classList.remove('hidden');

      const groups = parseAlliGroups(ROWS_RAW);
      rowData = [];
      rowModeEl.innerHTML = '';

      for (let i=0;i<groups.length;i++){
        const names = groups[i];

        const imgs = [];
        for (const w of names){
          const f = await resolveImageForWord(w);
          if (f) imgs.push(f);
        }
        if (imgs.length < 2) continue;

        const { syll: majSyl, count: majCount } = majorityInitialSyll(imgs.map(x=>x.rawCore));
        await preloadAudioForCores(imgs.map(x=>x.rawCore));

        const line = document.createElement('div');
        line.className = 'rowLine twoCols';

        const drop = document.createElement('div');
        drop.className = 'rowDrop';
        drop.dataset.row = String(i);

        const rack = document.createElement('div');
        rack.className = 'rowRack';
        rack.dataset.row = String(i);

        line.appendChild(drop);
        line.appendChild(rack);
        rowModeEl.appendChild(line);

        const cards = imgs.map(ci => ({
          id: crypto.randomUUID(),
          imgUrl: ci.url,
          coreRaw: ci.rawCore
        }));
        cards.forEach(c=> rack.appendChild(renderCard(c,{rowCard:true,rowIndex:i,rowScope:true})));

        rowData.push({
          type:'allisyll',
          dropEl: drop,
          rackEl: rack,
          cards,
          expectedCount: majCount,
          majSyl
        });
      }
    }

    async function buildRowSyllMode(){
      currentMode = 'rowsyll';
      document.body.classList.remove('row-compact');
      columnsEl.classList.add('hidden');
      rowModeEl.classList.remove('hidden');

      rackSectionEl.classList.remove('hidden');
      rackEl.innerHTML = '';
      rackEl.classList.add('chips');
      SOLO_WORDS.forEach(w => rackEl.appendChild(renderChip(w)));

      const defs = parseRowSyllDefs(ROWS_RAW);
      rowData = [];
      rowModeEl.innerHTML = '';

      for (let i=0;i<defs.length;i++){
        const r = defs[i];
        const pImg = await resolveImageForWord(r.prompt);
        if (!pImg) continue;

        const line = document.createElement('div');
        line.className = 'rowLine twoCols';

        const promptWrap = document.createElement('div');
        promptWrap.className = 'rowPrompt';
        const pCard = document.createElement('div');
        pCard.className = 'card';
        pCard.innerHTML = `<img alt="" src="${pImg.url}"><div class="cap" style="display:${ROW_TITLE?'block':'none'}">${ROW_TITLE?markersToPretty(pImg.rawCore):'&nbsp;'}</div>`;
        promptWrap.appendChild(pCard);

        const drop = document.createElement('div');
        drop.className = 'rowDrop';
        drop.dataset.row = String(i);

        const spacer = document.createElement('div');
        spacer.className = 'rowRack';

        line.appendChild(promptWrap);
        line.appendChild(drop);
        line.appendChild(spacer);
        rowModeEl.appendChild(line);

        const promptSyls = syllablesNormalized(pImg.rawCore);
        const targetSyl = r.how === 'init'
          ? (promptSyls[0] || '')
          : (promptSyls[promptSyls.length - 1] || '');
        const targetInitial = initialFromStem(targetSyl);

        rowData.push({
          type: 'rowsyll',
          dropEl: drop,
          prompt: pImg,
          how: r.how,
          targetInitial
        });
      }
    }

function everythingCorrect(){
  // ---------- ROWSYLL (chips in rowDrop) ----------
  if (currentMode === 'rowsyll') {
    const rackChips = rackEl.querySelectorAll('.chip');
    if (rackChips.length > 0) return false; // anything left in the bank

    // any incorrect chip currently in a row drop?
    if (document.querySelector('.rowDrop .chip.bad')) return false;

    const placed = document.querySelectorAll('.rowDrop .chip').length;
    const locked = document.querySelectorAll('.rowDrop .chip.locked').length;

    // Require at least one placed, and all placed are locked
    return placed > 0 && placed === locked;
  }

  // ---------- ROW / ROWALLI / ALLISYLL (cards in rowDrop) ----------
  if (currentMode === 'row' || currentMode === 'rowalli' || currentMode === 'allisyll') {
    // any unlocked still in per-row racks?
    const anyUnplaced = rowData.some(r => r.rackEl && r.rackEl.querySelector('.card'));
    if (anyUnplaced) return false;

    if (document.querySelector('.rowDrop .card.bad')) return false;

    const placed = document.querySelectorAll('.rowDrop .card').length;
    const locked = document.querySelectorAll('.rowDrop .card.locked').length;

    return placed > 0 && placed === locked;
  }

  // ---------- CLASSIC (cards in .drop) ----------
  const rackCards = rackEl.querySelectorAll('.card');
  if (rackCards.length > 0) return false;

  if (document.querySelector('.drop .card.bad')) return false;

  const placed = document.querySelectorAll('.drop .card').length;
  const locked = document.querySelectorAll('.drop .card.locked').length;

  return placed > 0 && placed === locked;
}

    function verifyNow(fromBroadcast){
      if (currentMode==='row'){
        rowData.forEach((r)=>{
          const dropped = r.dropEl.querySelector('.card');
          if (!dropped) return;
          const cardId = dropped.dataset.id;
          const card = r.cards.find(c=>c.id===cardId);
          if (!card) return;
          const a = initialFromStem(r.prompt.rawCore);
          const b = initialFromStem(card.coreRaw);
          const ok = (a===b);
          if(ok){ dropped.classList.add('ok','locked'); lockCard(dropped, card); }
          else { dropped.classList.add('bad'); setTimeout(()=> { dropped.classList.remove('bad'); r.rackEl.appendChild(dropped); }, 300); }
        });
        if (everythingCorrect()) celebrate();
        return;
      }

      if (currentMode==='rowalli'){
        rowData.forEach((r)=>{
          [...r.dropEl.children].forEach(cardEl=>{
            const card = r.cards.find(c=>c.id===cardEl.dataset.id);
            if (!card) return;
            const ini = initialFromStem(card.coreRaw);
            const ok = (ini === r.majInitial);
            if(ok){
              cardEl.classList.add('ok','locked');
              lockCard(cardEl, card);
              if (currentMode === 'stressreveal') revealBlobForCard(card);
            } else {
              cardEl.classList.add('bad');
              setTimeout(()=> ejectToRack(cardEl), 350);
            }
          });
        });
        if (everythingCorrect()) celebrate();
        return;
      }

      if (currentMode==='allisyll'){
        rowData.forEach((r)=>{
          [...r.dropEl.children].forEach(cardEl=>{
            const card = r.cards.find(c=>c.id===cardEl.dataset.id);
            if (!card) return;
            const syls = syllablesNormalized(card.coreRaw);
            const firstSyl = syls[0] || '';
            const ok = cmpSyll(firstSyl, r.majSyl);
            if (ok){ cardEl.classList.add('ok','locked'); lockCard(cardEl, card); }
            else {
              cardEl.classList.add('bad');
              setTimeout(()=> { cardEl.classList.remove('bad'); r.rackEl.appendChild(cardEl); }, 300);
            }
          });
        });
        if (everythingCorrect()) celebrate();
        return;
      }

      if (currentMode==='rowsyll'){
        rowData.forEach((r)=>{
          const tgt = r.targetInitial;
          const how = r.how;

          [...r.dropEl.children].forEach(chipEl=>{
            const text = (chipEl.textContent || '').trim().toLowerCase();
            const syls = syllablesNormalized(text);
            let ok = false;

            if (syls.length){
              const chosen = (how==='init') ? syls[0] : syls[syls.length-1];
              const VOWEL = /^[aeiou]/;
              const digraphs = ['ch','ll','rr'];
              const syllableMatchesCV = (syllNorm, targetInitial)=>{
                if(!syllNorm) return false;
                if (digraphs.includes(targetInitial)) {
                  if (!syllNorm.startsWith(targetInitial)) return false;
                  const rest = syllNorm.slice(targetInitial.length);
                  return rest.length > 0 && VOWEL.test(rest[0]);
                }
                if (syllNorm[0] !== targetInitial) return false;
                return syllNorm.length > 1 && VOWEL.test(syllNorm[1]);
              };
              ok = syllableMatchesCV(chosen, tgt);
            }

            if (ok){
              chipEl.classList.add('ok','locked');
            } else {
              chipEl.classList.add('bad');
              setTimeout(()=> { chipEl.classList.remove('bad'); rackEl.appendChild(chipEl); }, 300);
            }
          });
        });

        if (everythingCorrect()) celebrate();
        return;
      }

      const getTarget = key => {
        if (key.startsWith('not-'))    return {type:'not', letter:key.slice(4)};
        if (key.startsWith('syll:'))   return {type:'syll', syll:key.slice(5)};
        if (key.startsWith('count:'))  return {type:'count', n: parseInt(key.slice(6),10)};
        if (key.startsWith('stress:')) return {type:'stress', pos: parseInt(key.slice(7),10)};
        return {type:'is', letter:key};
      };

      document.querySelectorAll('.drop').forEach((drop, idx)=>{
        const target = getTarget(currentCols[idx].key);
        [...drop.children].forEach(cardEl=>{
          const card = currentCards.find(c=>c.id===cardEl.dataset.id);
          if(!card) return;

          const coreRaw = card.coreRaw;
          let ok = false;
          if (target.type === 'syll') {
            const syls = syllablesNormalized(coreRaw);
            ok = (SYLL_MATCH==='any')
              ? syls.some(s => cmpSyll(s, target.syll))
              : cmpSyll(syls[0], target.syll);
          } else if (target.type === 'count') {
            ok = syllableCount(coreRaw) === target.n;
          } else if (target.type === 'stress') {
            ok = stressedSyllIndex(coreRaw) === target.pos;
          } else {
            const initial = initialFromStem(coreRaw);
            ok = (target.type==='is') ? (initial===target.letter) : (initial!==target.letter);
          }

          if(ok){ cardEl.classList.add('ok','locked'); lockCard(cardEl, card); }
          else { cardEl.classList.add('bad'); setTimeout(()=> ejectToRack(cardEl), 350); }
        });
      });

      if (everythingCorrect()) celebrate();
      if (!fromBroadcast && isTeacher && channel){
        channel.send({ type:'broadcast', event:'VERIFY' });
      }
    }

    // Drag & Drop
    let drag=null;
    function makeDraggable(el, rowScope){
      el.style.touchAction='none';
      if (rowScope != null) el.dataset.row = String(rowScope);
      el.addEventListener('pointerdown', onGrab);
    }
    function onGrab(e){
      e.preventDefault();
      const el=e.currentTarget;
      if(el.classList.contains('locked')) return;
      drag={
        el,
        originParent:el.parentElement,
        rowScope: el.dataset.row || null,
        pointerId:e.pointerId,
        startX:e.clientX, startY:e.clientY,
        moved:false
      };
      el.classList.add('dragging');
      el.setPointerCapture(e.pointerId);
      window.addEventListener('pointermove', onMove, {passive:false});
      window.addEventListener('pointerup', onDrop, {passive:false});
      window.addEventListener('pointercancel', onCancel, {passive:false});
    }
    function onMove(e){
      if(!drag || e.pointerId!==drag.pointerId) return;
      e.preventDefault();
      const dx = e.clientX - drag.startX;
      const dy = e.clientY - drag.startY;
      if(!drag.moved && Math.hypot(dx,dy) < 4) return;
      if(!drag.moved){
        drag.moved = true;
        drag.el.style.position='fixed';
        if (drag.el.classList.contains('card')) {
          drag.el.style.width = '150px';
        } else {
          drag.el.style.width = drag.el.getBoundingClientRect().width + 'px';
        }
        drag.el.style.height = '';
        drag.el.style.zIndex=1000;
        drag.el.style.pointerEvents='none';
      }
      drag.el.style.left=(e.clientX-70)+'px';
      drag.el.style.top =(e.clientY-70)+'px';
    }
    function onDrop(e){
      if (!drag || e.pointerId !== drag.pointerId) return;
      cleanupPointer(e.pointerId);
      const el = drag.el;

      if (!drag.moved) {
        resetDraggedStyles(el);
        drag = null;
        return;
      }

      resetDraggedStyles(el);

      const drop = hitTestDrop(e.clientX, e.clientY, drag.rowScope);

      const perCol = Math.max(1, Math.min(8, parseInt(cardsPerColEl.value || '4', 10)));
      document.body.classList.toggle('one-per', perCol === 1);

      if (drop) {
        if (drop.classList.contains('rowDrop')) {
          if (currentMode === 'row' && drop.children.length >= 1) {
            drag.originParent.appendChild(el);
          } else {
            drop.appendChild(el);
          }
        } else {
          drop.appendChild(el);
        }
      } else {
        drag.originParent.appendChild(el);
      }

      lastDragEndedAt = Date.now();
      drag = null;
    }
    function onCancel(e){
      if(!drag || e.pointerId!==drag.pointerId) return;
      cleanupPointer(e.pointerId);
      resetDraggedStyles(drag.el);
      drag=null;
    }
    function cleanupPointer(pointerId){
      try{ drag.el.releasePointerCapture(pointerId);}catch(_){}
      drag.el.classList.remove('dragging');
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onDrop);
      window.removeEventListener('pointercancel', onCancel);
    }
    function resetDraggedStyles(el){
      el.classList.remove('dragging');
      el.style.position=''; el.style.left=''; el.style.top=''; el.style.zIndex=''; el.style.pointerEvents='';
      el.style.width=''; el.style.height='';
    }
    function hitTestDrop(x, y, rowScope){
      const zones = Array.from(document.querySelectorAll('.drop, .rowDrop, .rack, .rowRack'));
      for (const d of zones){
        if (rowScope != null && d.dataset.row && d.dataset.row !== rowScope) continue;
        const r = d.getBoundingClientRect();
        if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return d;
      }
      return null;
    }
    function ejectToRack(cardEl){ cardEl.classList.remove('bad'); rackEl.appendChild(cardEl); }
    function lockCard(cardEl, card){
      const clone = cardEl.cloneNode(true);
      clone.classList.add('locked');
      if (cardEl.classList.contains('card') && card){
        clone.addEventListener('click', ()=> playWordAudio(card.coreRaw));
      }
      cardEl.replaceWith(clone);
    }

    // Controls wiring
    btnVerify.addEventListener('click', ()=> verifyNow(false));
    btnReset.addEventListener('click', resetRoundPlacements);

    soloVerifyBtn.addEventListener('click', ()=> verifyNow(false));
    soloResetBtn.addEventListener('click', resetRoundPlacements);

    inlineVerifyBtn.addEventListener('click', ()=> verifyNow(false));
    inlineResetBtn.addEventListener('click', resetRoundPlacements);

    btnNewRound.addEventListener('click', async ()=>{
      if(!isTeacher) return;
      if(imageFiles.length===0){
        await ensureStorageLoaded();
        if(imageFiles.length===0){ alert(T.alertNoImages); return; }
      }
      const hasSyll   = SOLO_SYLLABLES.length > 0;
      const hasCount  = SOLO_SYLLCOUNT.length > 0;
      const hasStress = SOLO_STRESSPOS.length > 0;
      const activeLetters = (hasSyll || hasCount || hasStress) ? [] : [...letterPicker.querySelectorAll('.active')].map(b=>b.textContent);
      if(!hasSyll && !hasCount && !hasStress && activeLetters.length===0){ alert(T.alertPickLetters); return; }
      const perCol = Math.max(1, Math.min(8, parseInt(cardsPerColEl.value||'4',10)));
      const useWords = SOLO_WORDS.length > 0;

      const payload =
        useWords
          ? (hasCount
              ? buildRoundFromWordListWithCounts(SOLO_SYLLCOUNT, SOLO_WORDS)
              : (hasStress
                  ? buildRoundFromWordListWithStress(SOLO_STRESSPOS, SOLO_WORDS)
                  : buildRoundFromWordList(activeLetters, SOLO_SYLLABLES, SOLO_WORDS)))
          : (hasCount
              ? buildRoundFromSyllCount(SOLO_SYLLCOUNT, perCol)
              : (hasStress
                  ? buildRoundFromStress(SOLO_STRESSPOS, perCol)
                  : (hasSyll
                      ? buildRoundFromSyllables(SOLO_SYLLABLES, perCol)
                      : buildRoundFromLetters(activeLetters, perCol))));

      await channel.send({ type:'broadcast', event:'ROUND', payload });
    });

    modeToggle.addEventListener('change', () => {
      isTeacher = modeToggle.checked;
      teacherPanel.classList.toggle('hidden', !isTeacher);
      studentPanel.classList.toggle('hidden', isTeacher);
    });

    const LETTERS = 'a,b,c,ch,d,e,f,g,h,i,j,k,l,ll,m,n,√±,o,p,q,r,rr,s,t,u,v,w,x,y,z'.split(',');
    function renderLetterPicker(){
      letterPicker.innerHTML='';
      LETTERS.forEach(L=>{
        const b=document.createElement('button');
        b.type='button'; b.textContent=L;
        b.addEventListener('click', ()=>{
          b.classList.toggle('active');
          const act=[...letterPicker.querySelectorAll('.active')];
          if(act.length>5) b.classList.remove('active');
        });
        letterPicker.appendChild(b);
      });
    }
    renderLetterPicker();

    function setPanelsForSolo() {
      teacherPanel.classList.add('hidden');
      studentPanel.classList.add('hidden');
      document.querySelector('.switch').classList.add('hidden');

      document.body.classList.toggle('one-per', (SOLO_PER || 4) === 1);

      const modeTxt =
        (MODE==='randinit')  ? T.soloMode.randinit :  /* ‚úÖ NEW */
        (MODE==='row')       ? T.soloMode.row :
        (MODE==='rowalli' || MODE==='allisort') ? T.soloMode.rowalli :
        (MODE==='allisyll')  ? T.soloMode.allisyll :
        (MODE==='rowsyll')   ? T.soloMode.rowsyll :
        (MODE==='syllcount' || SOLO_SYLLCOUNT.length) ? T.soloMode.syllcount(SOLO_SYLLCOUNT) :
        (MODE==='stress' || MODE==='stressreveal' || SOLO_STRESSPOS.length) ? T.soloMode.stress(SOLO_STRESSPOS) :
        (SOLO_SYLLABLES.length
          ? `syllables=${SOLO_SYLLABLES.join(', ')}`
          : (SOLO_LETTERS.length ? `letters=${SOLO_LETTERS.join(', ')}` : 'word list'));

      const wordsTxt = SOLO_WORDS.length ? T.soloExtras.words(SOLO_WORDS) : '';
      const labelTxt = LABEL_STYLE==='emoji' ? T.soloExtras.emoji : '';
      const hideTxt = HIDE_TITLE ? T.soloExtras.hidetitle : '';
      const langTxt = (LANG === 'en') ? T.soloExtras.lang : '';

      soloPill.style.display = 'inline-block';
      soloPill.textContent = `${T.soloPrefix} ${modeTxt}${wordsTxt}${labelTxt}${hideTxt}${langTxt}`;
      soloBar.classList.remove('hidden');
    }

    function startSoloRound(){
      usedSet = new Set();
      rackEl.classList.remove('chips');

      if (MODE==='row'){ buildRowMode(); return; }
      if (MODE==='rowalli' || MODE==='allisort'){ buildRowAlliMode(); return; }
      if (MODE==='allisyll'){ buildRowAlliSyllMode(); return; }
      if (MODE==='rowsyll'){ buildRowSyllMode(); return; }

      document.body.classList.remove('row-compact');

      const hasSyll   = SOLO_SYLLABLES.length > 0;
      const hasCount  = SOLO_SYLLCOUNT.length > 0;
      const hasStress = SOLO_STRESSPOS.length > 0;
      const per = SOLO_PER || 4;
      document.body.classList.toggle('one-per', per === 1);

      let payload;

      // ‚úÖ NEW: random-initial sound mode
      if (MODE === 'randinit') {
        payload = buildRoundFromRandomInitial(RANDINIT_POOL, per);
      } else if (MODE === 'stressreveal') {
        let positions = SOLO_STRESSPOS.slice();
        if (!positions.length && SOLO_WORDS.length){
          const set = new Set();
          SOLO_WORDS.forEach(w => set.add(stressedSyllIndex(w)));
          positions = Array.from(set).sort((a,b)=>a-b);
        }
        if (!positions.length) positions = [1,2];
        payload = buildRoundFromWordListWithStress(positions, SOLO_WORDS);
      } else if (SOLO_WORDS.length > 0) {
        payload = hasCount
          ? buildRoundFromWordListWithCounts(SOLO_SYLLCOUNT, SOLO_WORDS)
          : (hasStress
              ? buildRoundFromWordListWithStress(SOLO_STRESSPOS, SOLO_WORDS)
              : buildRoundFromWordList(hasSyll ? [] : SOLO_LETTERS, SOLO_SYLLABLES, SOLO_WORDS));
      } else if (hasCount) {
        payload = buildRoundFromSyllCount(SOLO_SYLLCOUNT, per);
      } else if (hasStress) {
        payload = buildRoundFromStress(SOLO_STRESSPOS, per);
      } else if (hasSyll) {
        payload = buildRoundFromSyllables(SOLO_SYLLABLES, per);
      } else {
        payload = buildRoundFromLetters(SOLO_LETTERS, per);
      }

      currentMode = (MODE === 'stressreveal') ? 'stressreveal' : 'classic';
      rowModeEl.classList.add('hidden');
      columnsEl.classList.remove('hidden');
      rackSectionEl.classList.remove('hidden');

      buildColumns(payload.columns);
      setCards(payload.cards);
      clearAllPlacements();

      if (MODE === 'stressreveal') {
        buildStressRevealScene(payload.cards);
      } else if (stressRevealEl) {
        stressRevealEl.classList.add('hidden');
        stressRevealEl.innerHTML = '';
      }
    }

    (async function boot(){
      if (TILES_ONLY) document.body.classList.add('tiles-only');
      if (HIDE_WORDS) document.body.classList.add('hide-words');

      // (re)apply UI text after DOM ready (safe)
      applyUiText();

      if (SOLO_MODE) {
        setPanelsForSolo();
        await ensureStorageLoaded();
        if(!TILES_ONLY &&
           imageFiles.length===0 &&
           MODE!=='row' && MODE!=='rowalli' && MODE!=='allisort' &&
           MODE!=='allisyll' && MODE!=='rowsyll' && MODE!=='syllcount') return;
        soloNewRoundBtn.addEventListener('click', ()=> startSoloRound());
        startSoloRound();
        return;
      }

      currentMode = 'classic';
      modeToggle.checked = false;
      isTeacher = false;
      teacherPanel.classList.add('hidden');
      studentPanel.classList.remove('hidden');
    })();
  </script>
<!-- ---------- QR MODAL ---------- -->
<div id="qrModal" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.45);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9999;
">
  <div style="
    background:#fff;
    padding:20px 22px 24px;
    border-radius:16px;
    text-align:center;
    max-width:320px;
    width:90%;
  ">
    <h2 style="margin:0 0 12px 0;font-size:18px">
      Escanea para abrir
    </h2>
    <div id="qrCode"></div>
    <div id="qrLink" style="
      margin-top:10px;
      font-size:12px;
      color:#374151;
      word-break:break-all;
    "></div>
  </div>
</div>
<!-- QR CODE LOGIC -->
<script>
(function loadQRCodeThenInit(){
  const script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/qrcode@1.5.4/build/qrcode.min.js';
  script.onload = initQR;
  document.head.appendChild(script);

  function initQR(){
    const qrBtn   = document.getElementById('qrBtn');
    const qrModal = document.getElementById('qrModal');
    const qrCode  = document.getElementById('qrCode');
    const qrLink  = document.getElementById('qrLink');

    if (!qrBtn || !qrModal || !qrCode) {
      console.warn('[QR] Missing elements');
      return;
    }

    function cleanUrl(){
      return location.href;
    }

    async function showQR(){
      const url = cleanUrl();
      qrCode.innerHTML = '';

      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width: 260, margin: 2 });
      qrCode.appendChild(canvas);

      if (qrLink) qrLink.textContent = url;
      qrModal.style.display = 'flex';
    }

    qrBtn.addEventListener('click', showQR);

    qrModal.addEventListener('click', (e)=>{
      if (e.target === qrModal) {
        qrModal.style.display = 'none';
      }
    });

    window.addEventListener('popstate', ()=>{
      if (qrModal.style.display === 'flex') showQR();
    });
  }
})();
</script>



</body>
</html>
