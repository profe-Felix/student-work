<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clasificador de letras — Maestro & Estudiante</title>

  <!-- Kid-friendly font (single-storey “a”) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

  <style>
    *{box-sizing:border-box}
    :root{--bg:#f7f7fb;--ink:#111;--muted:#666;--brand:#2563eb;--ok:#16a34a;--bad:#dc2626;--card:#fff;--drop:#eef2ff}
    html,body{height:100%}
    body{margin:0;font:16px/1.45 Andika, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;background:var(--bg);color:var(--ink)}
    .wrap{max-width:1100px;margin:0 auto;padding:12px}
    header{position:sticky;top:0;background:#fff;border-bottom:1px solid #e5e7eb;z-index:5}
    .row{display:flex;gap:12px;align-items:center}
    .brand{font-weight:700}
    .spacer{flex:1}
    .switch{display:flex;gap:8px;align-items:center}
    .panel{margin-top:10px}
    .panel.hidden{display:none}
    .grid{display:grid;grid-template-columns:2fr 1fr 1fr;gap:12px;align-items:end}
    .field{margin:6px 0}
    .field .inline{display:flex;gap:8px}
    input,button{font:inherit}
    input{padding:8px 10px;border:1px solid #d1d5db;border-radius:10px;background:#fff;width:100%}
    .btn{padding:8px 12px;border-radius:10px;border:1px solid transparent;background:var(--brand);color:#fff;cursor:pointer}
    .btn.outline{background:#fff;border-color:#d1d5db;color:var(--ink)}
    .btn.ghost{background:transparent;border-color:transparent;color:var(--muted)}
    .buttons{display:flex;gap:8px;align-items:center}
    .note{font-size:12px;color:var(--muted);margin-top:8px}
    .letters{display:flex;flex-wrap:wrap;gap:6px}
    .letters button{min-width:36px;height:36px;border-radius:10px;border:1px solid #d1d5db;background:#fff;cursor:pointer}
    .letters button.active{background:var(--brand);color:#fff;border-color:transparent}
    main{max-width:1100px;margin:14px auto;padding:0 12px}
    .columns{display:grid;grid-template-columns: repeat(auto-fit,minmax(220px,1fr));gap:16px;margin-top:16px}
    .col{background:#fff;border:1px solid #e5e7eb;border-radius:14px;box-shadow:0 6px 20px rgba(0,0,0,.05);padding:10px}
    .col h2{margin:0 0 8px;font-size:18px}
    .drop{min-height:240px;background:var(--drop);border:2px dashed #c7d2fe;border-radius:12px;padding:8px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start}
    .rackSection{margin-top:18px}
    .rack{margin-top:8px;background:#fff;border:1px dashed #e5e7eb;border-radius:12px;padding:10px;display:flex;flex-wrap:wrap;gap:8px;min-height:150px}
    .card{user-select:none;touch-action:none;background:var(--card);border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 2px 6px rgba(0,0,0,.06);width:140px;overflow:hidden;cursor:grab;display:flex;flex-direction:column;align-items:center}
    .card:active{cursor:grabbing}
    .card img{display:block;width:100%;height:100px;object-fit:contain;background:#fafafa}
    .card .cap{padding:6px 8px;width:100%;text-align:center;font-size:14px}
    .card.ok{outline:3px solid var(--ok)}
    .card.bad{outline:3px solid var(--bad)}
    .locked{opacity:.85}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <div class="brand">Clasificador de letras</div>
        <div class="spacer"></div>
        <label class="switch">
          <input id="modeToggle" type="checkbox" />
          <span>Modo Maestro</span>
        </label>
      </div>

      <!-- Teacher panel -->
      <div id="teacherPanel" class="panel hidden">
        <div class="field">
          <label>Código de sesión</label>
          <div class="inline">
            <input id="roomCode" placeholder="por ej., A_01" />
            <button id="btnJoin" class="btn">Iniciar sesión</button>
          </div>
          <small class="note">Comparte este código con los estudiantes.</small>
        </div>

        <div class="grid">
          <div>
            <label>Letras objetivo (1–5)</label>
            <div id="letterPicker" class="letters"></div>
          </div>
          <div>
            <label>Cartas por columna</label>
            <input id="cardsPerCol" type="number" min="1" max="8" value="4" />
          </div>
          <div class="buttons">
            <button id="btnNewRound" class="btn">Nueva ronda</button>
            <button id="btnVerify" class="btn outline">Verificar</button>
            <button id="btnReset" class="btn ghost">Reiniciar ronda</button>
          </div>
        </div>

        <div class="note">
          Las imágenes y audios se cargan desde <strong>Supabase Storage</strong> (sin manifest.json).
        </div>
      </div>

      <!-- Student panel -->
      <div id="studentPanel" class="panel">
        <div class="field inline">
          <input id="studentRoom" placeholder="Código de sesión" />
          <button id="btnStudentJoin" class="btn">Unirse</button>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div id="columns" class="columns"></div>

    <section class="rackSection">
      <h3>Cartas</h3>
      <div id="rack" class="rack" aria-label="rack"></div>
    </section>
  </main>

  <audio id="fxOk" preload="auto"></audio>
  <audio id="fxBad" preload="auto"></audio>

  <!-- Supabase SDK -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <script>
    /************ CONFIGURA TU SUPABASE Y BUCKETS ************/
    const SUPABASE_URL = "https://dmlsiyyqpcupbizpxwhp.supabase.co";    // tu proyecto existente
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHNpeXlxcGN1cGJpenB4d2hwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg0MDI1NjUsImV4cCI6MjA3Mzk3ODU2NX0.mkgeUtjC8ulLyHHVVOic4LmhhQP_JJtMi2JQztdzjsg";          // anon key
    // Buckets de Storage que vas a crear en Supabase:
    const IMAGES_BUCKET = "lettersort-images"; // subir PNG/JPG/GIF/WebP/SVG
    const AUDIO_BUCKET  = "lettersort-audio";  // subir MP3 (opcional)
    /**********************************************************/

    // Cliente Supabase
    const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // UI
    const modeToggle     = document.getElementById('modeToggle');
    const teacherPanel   = document.getElementById('teacherPanel');
    const studentPanel   = document.getElementById('studentPanel');
    const btnJoin        = document.getElementById('btnJoin');
    const roomCodeEl     = document.getElementById('roomCode');
    const studentRoomEl  = document.getElementById('studentRoom');
    const btnStudentJoin = document.getElementById('btnStudentJoin');
    const letterPicker   = document.getElementById('letterPicker');
    const cardsPerColEl  = document.getElementById('cardsPerCol');
    const columnsEl      = document.getElementById('columns');
    const rackEl         = document.getElementById('rack');
    const btnNewRound    = document.getElementById('btnNewRound');
    const btnVerify      = document.getElementById('btnVerify');
    const btnReset       = document.getElementById('btnReset');

    // Estado
    let ROOM = null;
    let channel = null;
    let isTeacher = false;
    let currentCols = [];
    let currentCards = [];
    let usedSet = new Set(); // evita repeticiones dentro de la sesión del maestro

    /*************** Modo maestro / estudiante ***************/
    modeToggle.addEventListener('change', () => {
      isTeacher = modeToggle.checked;
      teacherPanel.classList.toggle('hidden', !isTeacher);
      studentPanel.classList.toggle('hidden', isTeacher);
    });

    /*************** Selector de letras (incluye ch, ll, rr) ***************/
    const LETTERS = 'a,b,c,ch,d,e,f,g,h,i,j,k,l,ll,m,n,ñ,o,p,q,r,rr,s,t,u,v,w,x,y,z'.split(',');
    function renderLetterPicker(){
      letterPicker.innerHTML='';
      LETTERS.forEach(L => {
        const b=document.createElement('button');
        b.type='button'; b.textContent=L;
        b.addEventListener('click',()=>{
          b.classList.toggle('active');
          const actives=[...letterPicker.querySelectorAll('.active')];
          if(actives.length>5){ b.classList.remove('active'); }
        });
        letterPicker.appendChild(b);
      });
    }
    renderLetterPicker();

    /*************** Unirse a sala (Realtime) ***************/
    async function joinRoom(room){
      if(channel){ try{ await channel.unsubscribe(); }catch{} }
      ROOM = (room||'').trim();
      if(!ROOM){ alert('Código de sesión inválido'); return; }

      channel = client.channel(`lettersort:${ROOM}`);

      channel.on('broadcast', { event: 'ROUND'  }, p => {
        const d = p.payload;
        buildColumns(d.columns);
        setCards(d.cards);
        clearAllPlacements();
      });
      channel.on('broadcast', { event: 'VERIFY' }, () => verifyNow());
      channel.on('broadcast', { event: 'RESET'  }, () => resetRoundPlacements());

      const { error } = await channel.subscribe();
      if(error){ console.error(error); alert('Error al suscribirse al canal'); }
    }

    btnJoin.addEventListener('click', async ()=>{
      const room = roomCodeEl.value || 'A_01';
      await joinRoom(room);
      // (no necesitamos precargar nada — todo viene de Storage al crear la ronda)
    });
    btnStudentJoin.addEventListener('click', async ()=>{
      const room = studentRoomEl.value || 'A_01';
      await joinRoom(room);
    });

    /*************** Storage helpers (lista + URLs) ***************/
    const IMG_EXT = /\.(png|jpe?g|gif|webp|svg)$/i;
    const AUD_EXT = /\.(mp3|m4a|wav|ogg)$/i;

    // Recorre una carpeta (y subcarpetas) listando todos los archivos
    async function listAllFiles(bucket, prefix = '') {
      const results = [];
      async function walk(dir) {
        let offset = 0;
        const limit = 1000;
        while (true) {
          const { data, error } = await client.storage.from(bucket).list(dir, { limit, offset });
          if (error) { console.error('list error', bucket, dir, error); break; }
          if (!data || data.length === 0) break;

          for (const entry of data) {
            const isFolder = !entry.name.includes('.') && !entry.id; // heuristic
            const path = dir ? `${dir}/${entry.name}` : entry.name;
            if (isFolder) {
              await walk(path);
            } else {
              results.push(path);
            }
          }
          if (data.length < limit) break;
          offset += limit;
        }
      }
      await walk(prefix);
      return results;
    }

    // Intenta publicUrl primero; si no hay, crea Signed URL (1h)
    async function fileUrl(bucket, path) {
      const pub = client.storage.from(bucket).getPublicUrl(path);
      if (pub?.data?.publicUrl) return pub.data.publicUrl;
      const { data: signed, error } = await client.storage.from(bucket).createSignedUrl(path, 60 * 60);
      if (error) { console.warn('signedUrl error', path, error); return ''; }
      return signed?.signedUrl || '';
    }

    // Carga todas las imágenes y opcionalmente audios emparejados por "stem"
    async function loadAssetsFromStorage() {
      // 1) lista imágenes
      const imgPaths = (await listAllFiles(IMAGES_BUCKET)).filter(p => IMG_EXT.test(p));
      // 2) lista audios (opcional)
      let audioMap = new Map();
      try {
        const audioPaths = (await listAllFiles(AUDIO_BUCKET)).filter(p => AUD_EXT.test(p));
        audioMap = new Map(audioPaths.map(p => [stemFromPath(p), p]));
      } catch (e) {
        // si no existe el bucket de audio, seguimos sin audio
        console.warn('No audio bucket or listing error; continuing without audio', e);
      }

      // 3) materializa URLs (public o firmadas)
      const cards = [];
      for (const imgPath of imgPaths) {
        const stem = stemFromPath(imgPath);
        const initial = initialFromStem(stem);
        const imgUrl = await fileUrl(IMAGES_BUCKET, imgPath);
        if (!imgUrl) continue; // saltar si no se puede obtener URL

        let audioUrl = '';
        const audioPath = audioMap.get(stem);
        if (audioPath) {
          audioUrl = await fileUrl(AUDIO_BUCKET, audioPath);
        }

        cards.push({
          id: crypto.randomUUID(),
          file: imgPath,             // ruta dentro del bucket
          word: stem,                // nombre "amigable"
          initial,
          imgUrl,
          audioUrl
        });
      }
      return cards;
    }

    /*************** Nueva ronda (Maestro) ***************/
    btnNewRound.addEventListener('click', async ()=>{
      if(!isTeacher) return;

      // 1) Carga/actualiza inventario desde Storage
      const allCards = await loadAssetsFromStorage(); // [{word, initial, imgUrl, audioUrl, file},...]
      if (!allCards.length) { alert('No se encontraron imágenes en Storage.'); return; }

      // 2) Config maestro
      const activeLetters = [...letterPicker.querySelectorAll('.active')].map(b=>b.textContent);
      if(activeLetters.length===0){ alert('Seleccione 1–5 letras.'); return; }
      const perCol = clamp(parseInt(cardsPerColEl.value||'4',10), 1, 8);

      // 3) Columnas
      const columns = [];
      if(activeLetters.length===1){
        const L = activeLetters[0];
        columns.push({label:`Con /${L}/`, key:`${L}`});
        columns.push({label:`Sin /${L}/`, key:`not-${L}`});
      } else {
        activeLetters.forEach(L=>columns.push({label:`Con /${L}/`, key:`${L}`}));
      }

      // 4) Muestreo por columna evitando repetidos dentro de la sesión
      const cards = [];
      for (const col of columns) {
        let pool = [];
        if (col.key.startsWith('not-')) {
          const L = col.key.slice(4);
          pool = allCards.filter(c => c.initial !== L && !usedSet.has(c.file));
        } else {
          const L = col.key;
          pool = allCards.filter(c => c.initial === L && !usedSet.has(c.file));
        }
        shuffle(pool);
        const picks = pool.slice(0, perCol);
        picks.forEach(c => usedSet.add(c.file));
        cards.push(...picks);
      }

      // 5) Broadcast ronda a todos
      await channel.send({ type:'broadcast', event:'ROUND', payload:{ columns, cards } });
    });

    /*************** Verificar / Reiniciar (Maestro) ***************/
    btnVerify.addEventListener('click', async ()=> {
      if(!isTeacher) return;
      await channel.send({ type:'broadcast', event:'VERIFY', payload:{} });
    });
    btnReset.addEventListener('click', async ()=> {
      if(!isTeacher) return;
      await channel.send({ type:'broadcast', event:'RESET', payload:{} });
    });

    /*************** Render de columnas y cartas ***************/
    function buildColumns(columns){
      currentCols = columns;
      columnsEl.innerHTML='';
      columns.forEach((c, idx)=>{
        const col = document.createElement('div');
        col.className='col';
        col.innerHTML = `<h2>${c.label}</h2><div class="drop" data-col="${idx}"></div>`;
        columnsEl.appendChild(col);
      });
    }

    function setCards(cards){
      currentCards = cards;
      rackEl.innerHTML='';
      cards.forEach(card=> rackEl.appendChild(renderCard(card)) );
    }

    function renderCard(card){
      const el=document.createElement('div');
      el.className='card';
      el.dataset.id=card.id;
      el.setAttribute('tabindex','0');
      el.innerHTML=`<img alt="${escapeHtml(card.word)}" src="${card.imgUrl}"/><div class="cap">&nbsp;</div>`;

      // Audio: doble click / doble tap
      if (card.audioUrl) {
        let lastTap=0;
        const playAudio=()=>{ const a=new Audio(card.audioUrl); a.play().catch(()=>{}); };
        el.addEventListener('dblclick', playAudio);
        el.addEventListener('touchend', e=>{
          const now=Date.now();
          if(now-lastTap<300){ playAudio(); }
          lastTap=now;
        });
      }

      makeDraggable(el);
      return el;
    }

    function clearAllPlacements(){
      document.querySelectorAll('.drop').forEach(d=>d.innerHTML='');
      rackEl.innerHTML='';
      currentCards.forEach(card=> rackEl.appendChild(renderCard(card)) );
    }

    function resetRoundPlacements(){
      document.querySelectorAll('.card').forEach(c=> c.classList.remove('ok','bad','locked') );
      clearAllPlacements();
    }

    /*************** Verificación en cliente ***************/
    function verifyNow(){
      const getTargetForCol = key => key.startsWith('not-') ? {type:'not', letter:key.slice(4)} : {type:'is', letter:key};
      document.querySelectorAll('.drop').forEach((drop,idx)=>{
        const colKey=currentCols[idx].key;
        const target=getTargetForCol(colKey);
        [...drop.children].forEach(cardEl=>{
          const card=currentCards.find(c=>c.id===cardEl.dataset.id);
          if(!card) return;
          const ok = (target.type==='is') ? (card.initial===target.letter) : (card.initial!==target.letter);
          if(ok){ cardEl.classList.add('ok','locked'); lockCard(cardEl, card); }
          else { cardEl.classList.add('bad'); setTimeout(()=>ejectToRack(cardEl),350); }
        });
      });
    }

    /*************** Drag & Drop táctil (Pointer Events) ***************/
    let drag=null;
    function makeDraggable(el){ el.style.touchAction='none'; el.addEventListener('pointerdown', onGrab); }
    function onGrab(e){
      const el=e.currentTarget;
      if(el.classList.contains('locked')) return;
      drag={el, originParent:el.parentElement};
      el.setPointerCapture(e.pointerId);
      el.style.position='absolute'; el.style.zIndex=1000;
      moveTo(el,e.clientX,e.clientY);
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onDrop);
    }
    function onMove(e){ if(!drag) return; moveTo(drag.el,e.clientX,e.clientY); }
    function onDrop(e){
      if(!drag) return;
      const el=drag.el;
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onDrop);
      try{ el.releasePointerCapture(e.pointerId);}catch(_){}
      const target=document.elementFromPoint(e.clientX,e.clientY);
      const drop=target?.closest?.('.drop');
      el.style.position=''; el.style.left=''; el.style.top=''; el.style.zIndex='';
      const perCol=clamp(parseInt(cardsPerColEl.value||'4',10),1,8);
      if(drop){
        if(drop.children.length>=perCol){ drag.originParent.appendChild(el); }
        else { drop.appendChild(el); }
      } else {
        rackEl.appendChild(el);
      }
      drag=null;
    }
    function moveTo(el,x,y){ el.style.left=(x-60)+'px'; el.style.top=(y-60)+'px'; }
    function ejectToRack(cardEl){ cardEl.classList.remove('bad'); rackEl.appendChild(cardEl); }

    function lockCard(cardEl, card){
      const clone=cardEl.cloneNode(true);
      clone.classList.add('locked');
      if (card?.audioUrl) {
        let lastTap=0;
        const playAudio=()=>{ const a=new Audio(card.audioUrl); a.play().catch(()=>{}); };
        clone.addEventListener('dblclick', playAudio);
        clone.addEventListener('touchend', e=>{
          const now=Date.now();
          if(now-lastTap<300){ playAudio(); }
          lastTap=now;
        });
      }
      cardEl.replaceWith(clone);
    }

    /*************** Utilidades ***************/
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function stemFromPath(p){
      const seg = p.split('/').pop() || p;
      const dot = seg.lastIndexOf('.');
      return (dot>=0? seg.slice(0,dot): seg).toLowerCase();
    }
    function initialFromStem(stem){
      const s = stem.toLowerCase();
      if(s.startsWith('ch')) return 'ch';
      if(s.startsWith('ll')) return 'll';
      if(s.startsWith('rr')) return 'rr';
      return s[0];
    }
    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function escapeHtml(s){ return s.replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
  </script>
</body>
</html>
