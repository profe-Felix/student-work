<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Construye palabras ‚Äî Letras, S√≠labas, Palabras & Im√°genes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>


<style>
  *{box-sizing:border-box}
  :root{
    --bg:#fafbff; --grid:#eef1f7; --ink:#111; --muted:#6b7280; --brand:#2563eb;
    --tile:#fff; --tile-border:#111827; --drop:#ffffff; --drop-border:#111827;
    --trash:#fee2e2; --danger:#ef4444;
    --gap:12px;
    --inner-gap:10px;
    --tile-min-w:48px;
    --tile-h:48px;
    --tile-fs:28px;
    --tray-cols:10;
    --space-w:1.8ch;
  }
  html,body{height:100%}
  body{
    margin:0;
    font:18px/1.35 Andika, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--ink);
    background:
      linear-gradient(0deg, transparent calc(100% - 1px), var(--grid) 1px),
      linear-gradient(90deg, transparent calc(100% - 1px), var(--grid) 1px),
      var(--bg);
    background-size:40px 40px, 40px 40px, auto;
  }

  header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e7eb}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .row{display:flex;gap:12px;align-items:center}
  .spacer{flex:1}
  h1{font-size:20px;margin:0}

  .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{border:1px solid #d1d5db;background:var(--brand);color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.ghost{background:#fff;color:#111}
  input[type=number]{font:inherit;border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;min-width:70px}
  small.note{color:var(--muted)}

  main{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:minmax(0,1.2fr) minmax(0,1fr);gap:16px}
  /* MOBILE ONLY */
 @media (max-width:700px){main{grid-template-columns:1fr}
 }


  .board{
    background:var(--drop);
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:12px;
  
    min-width:0;   /* ‚≠ê REQUIRED for grid shrink */
  }

  .slots{
    display:flex;
    flex-direction:column;
    gap:var(--gap);
    align-items:stretch;
    justify-content:flex-start;
  }
  .line{
    display:flex;
    gap:var(--gap);
    align-items:flex-start;
    justify-content:flex-start;
  
    /* ‚≠ê CRITICAL FIX */
    min-width:0;      /* allow shrinking */
    width:100%;
  }

  .slot{
    background:#fff;
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:6px 8px;
    display:inline-flex;
    gap:0; /* no automatic gaps; only spaces create gaps */
    align-items:center;
    justify-content:flex-start;
    flex-wrap:nowrap;
    width:100%;
    min-width:0;
    max-width:100%;
    overflow:hidden;
    position:relative;
    vertical-align:top;
  }
  .slot:empty::before{
    content:"";
    display:block;
    width:8ch;
    height:clamp(40px, 6vh, 64px);
  }

  .row-bottom{margin-top:12px}
  .note-wrap{display:flex;flex-direction:column;align-items:flex-start;gap:6px}
  .trash-row{
    display:flex;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
  }
  .trash{
    display:inline-flex;align-items:center;gap:8px;
    background:var(--trash);border:2px dashed var(--danger);color:#991b1b;
    padding:6px 10px;border-radius:12px;font-size:16px;user-select:none
  }

  .palettes{display:grid;grid-template-columns:1fr;gap:14px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px}
  .card h2{margin:0;font-size:18px}
  .card small{color:var(--muted)}
  .tray{
    display:grid;
    grid-template-columns:repeat(var(--tray-cols), max-content);
    gap:8px;
  }

  .card-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:6px;
    margin-bottom:8px;
  }
  .mini-tools{
    display:flex;
    gap:4px;
  }

  .tile{
    user-select:none; -webkit-user-drag:none; touch-action:none;
    display:inline-flex; align-items:center; justify-content:center;
    min-width:var(--tile-min-w); height:var(--tile-h); padding:0 12px;
    background:var(--tile); border:2px solid var(--tile-border); border-radius:12px;
    font-size:var(--tile-fs); line-height:1; cursor:grab; position:relative;
    transition:transform .05s ease;
  }

  /* HYBRID FIT MODE */
  .tile.wrap-mode{
    white-space:normal !important;
    line-height:1.2;
    text-align:center;
  }
  .tile:active{cursor:grabbing; transform:scale(.98)}
  .dragging{opacity:.9; box-shadow:0 8px 24px rgba(0,0,0,.15)}
  .highlight{outline:3px solid #a5b4fc; outline-offset:2px}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#1e3a8a;font-size:12px;margin-left:8px}

  .slot .tile.in-slot{
    flex:0 0 auto; min-width:0;
    height:clamp(40px, 6vh, 64px);
    font-size:clamp(26px, 3.4vw, 56px);
    padding:0;
    background:transparent; border:none; border-radius:0; box-shadow:none;
  }

  .tile.img{ padding:4px 6px; min-width:auto; }
  .tile.img img{ display:block; max-height:var(--tile-h); height:auto; width:auto; max-width:160px; }
  .slot .tile.img.in-slot{ background:transparent; border:none; padding:0 4px; }
  .slot .tile.img.in-slot img{ max-height:clamp(40px, 6vh, 64px); border-radius:6px; }

  .tile.space{
    border-style:dashed;
    background:#f3f4f6;
    min-width:auto;
    padding:0 10px;
    font-size:16px;
  }
  .tile.space::after{ content:"‚ê£"; }
  .slot .tile.space.in-slot{
    width:var(--space-w);
    min-width:var(--space-w);
    padding:0;
    height:clamp(40px, 6vh, 64px);
    font-size:0;
    background:#e5e7eb;
    border:1px dashed #9ca3af;
    border-radius:999px;
    margin:0 var(--inner-gap);
  }

  .tile.punc{
    min-width:auto;
    padding:0 8px;
    font-size:24px;
  }
 
  .tile.writegen{
    min-width:auto;
    padding:0 10px;
    font-size:22px;
    background:#eef2ff;
    border-style:dashed;
  }
 
  .slot .tile.punc.in-slot{
    padding:0;
    margin:0;
  }

  .tile.captool,
  .tile.accenttool{
    min-width:auto;
    height:32px;
    padding:0 10px;
    font-size:18px;
  }

  /* ===== WRITE TILE (student typing tile) ===== */
 /* ===== WRITE TILE (behaves like punctuation tile) ===== */
 .tile.write{
   display:block;        /* ‚≠ê VERY IMPORTANT */
   min-width:0;
   padding:0;
   font-size:24px;
   height:var(--tile-h);
 }
  
 .write-input{
   border:none;
   outline:none;
   background:transparent;
   font-family:inherit;
   font-size:inherit;
   padding:0 6px;
   text-align:left;
 
   white-space:nowrap;   /* ‚≠ê critical */
   overflow:hidden;
 }
 
 /* inside slots */
 .slot .tile.write.in-slot .write-input{
   width:auto;
   min-width:1ch;
   font-size:inherit;
 }
 /* ===== INSERTION PREVIEW (SNAP + SPLIT) ===== */
 
 /* Edge insert: blue bar at left/right edge */
 .slot.preview-edge-left::before,
 .slot.preview-edge-right::after{
   content:'';
   position:absolute;
   top:6px;
   bottom:6px;
   width:4px;
   background:#2563eb;
   border-radius:4px;
   opacity:.95;
 }
 .slot.preview-edge-left::before{ left:8px; }
 .slot.preview-edge-right::after{ right:8px; }
 
 /* Between-tiles insert: shift ONLY the tile after the insertion point */
 .slot .tile.preview-after{
   margin-left:28px;
 }
 
 /* Empty slot preview */
 .slot.preview-empty{
   outline:3px dashed #93c5fd;
   outline-offset:4px;
 }
 
 /* Phone: slightly smaller split */
 @media (max-width:700px){
   .slot .tile.preview-after{ margin-left:22px; }
 }


 /* STEP 2 ‚Äî PHONE SHRINK MODE */
 @media (max-width:700px){
   :root{
     --tile-h:40px;
     --tile-fs:22px;
     --gap:8px;
     --inner-gap:6px;
   }
 
   body{
     font-size:16px;
   }
 
   h1{
     font-size:18px;
   }
 }
/* HEADER ‚Äî compact default */
header{
  border-bottom:1px solid #e5e7eb;
}

header .wrap{
  padding:6px 10px;
}

header .row{
  gap:8px;
}

header h1{
  font-size:18px;
}

header .pill{
  font-size:11px;
  padding:3px 6px;
}
/* HEADER controls ‚Äî tighter */
header .toolbar{
  gap:6px;
}

header input[type=number]{
  min-width:56px;
  padding:4px 8px;
  font-size:16px;
}

header .btn{
  padding:5px 10px;
  font-size:15px;
}
/* STEP D ‚Äî PHONE: ultra-compact header */
@media (max-width:700px){
  header .wrap{
    padding:4px 8px;
  }

  header h1{
    font-size:16px;
  }

  header .pill{
    display:none;
  }

  header .toolbar{
    gap:4px;
  }

  header .btn{
    padding:4px 8px;
    font-size:14px;
  }

  header input[type=number]{
    min-width:48px;
    padding:4px 6px;
    font-size:14px;
  }
}
/* STEP E ‚Äî PHONE: shrink word boxes */
@media (max-width:700px){

  /* Outer slot (the box) */
  .slot{
    padding:4px 6px;
    min-width:60px;
    border-radius:10px;
  }

  /* Empty box placeholder height */
  .slot:empty::before{
    height:32px;
    width:6ch;
  }

  /* Tiles inside boxes */
  .slot .tile.in-slot{
    height:32px;
    font-size:20px;
  }

  /* Image tiles inside boxes */
  .slot .tile.img.in-slot img{
    max-height:32px;
  }
}
/* STEP F ‚Äî PHONE: floating trash */
@media (max-width:700px){
  .trash-row{
    position:fixed;
    left:50%;
    bottom:calc(120px + env(safe-area-inset-bottom));
    transform:translateX(-50%);
    z-index:1000;
    background:transparent;
    pointer-events:none; /* default off */
  }

  .trash{
    pointer-events:auto;
    opacity:0;
    transform:scale(.9);
    transition:opacity .15s ease, transform .15s ease;
  }

  body.drag-active .trash{
    opacity:1;
    transform:scale(1);
  }
}
/* ===== VALIDATION STATES ===== */
.slot.correct{
  outline:3px solid #22c55e; /* green */
  outline-offset:2px;
}

.slot.incorrect{
  outline:3px solid #ef4444; /* red */
  outline-offset:2px;
}

.slot.unanswered{
  outline:3px dashed #9ca3af; /* gray */
  outline-offset:2px;
}

</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1>Construye palabras</h1>
      <span class="pill">Arrastra desde los paneles ‚Üí se clona</span>
      <div class="spacer"></div>
       <div class="toolbar">
       
         <div id="teacherControls">
           <label>Cajas:
             <input id="boxesInput" type="number" min="1" max="12" value="4"/>
           </label>
           <label>Filas:
             <input id="rowsInput" type="number" min="1" max="50" value="1"/>
           </label>
           <button id="applyBoxes" class="btn ghost">Aplicar</button>
         </div>
       
         <button id="validateBtn" class="btn">Validar</button>
         <button id="qrBtn" class="btn ghost">QR</button>
       
       </div>

    </div>
  </div>
</header>

<main>
  <section class="board">
    <div id="slots" class="slots"></div>
    <div class="row-bottom">
      <div class="note-wrap">
        <small class="note">Consejo: suelta sobre la papelera para borrar.</small>
        <div class="trash-row">
          <div id="trash" class="trash" aria-label="Papelera">üóëÔ∏è Papelera</div>
          <div id="trashSpace"></div>
        </div>
      </div>
    </div>
  </section>

  <aside class="palettes">
    <div class="card" id="lettersCard">
      <div class="card-header">
        <h2>Letras</h2>
        <div class="mini-tools" id="lettersTools"></div>
      </div>
      <div id="lettersTray" class="tray"></div>
    </div>

    <div class="card" id="syllCard">
      <div class="card-header">
        <h2>S√≠labas</h2>
        <div class="mini-tools" id="syllTools"></div>
      </div>
      <div id="syllTray" class="tray"></div>
    </div>

    <div class="card" id="wordsCard">
      <div class="card-header">
        <h2>Palabras</h2>
        <div class="mini-tools" id="wordsTools"></div>
      </div>
      <div id="wordsTray" class="tray"></div>
    </div>

    <div class="card" id="puncCard">
      <h2>Puntuaci√≥n</h2>
      <div id="puncTray" class="tray"></div>
    </div>

    <div class="card" id="picsCard">
      <h2>Im√°genes</h2>
      <small>Arrastra im√°genes (o p√©galos) aqu√≠. Tambi√©n puedes precargar con <code>?imgs=URL1,URL2</code>.</small>
      <div id="picsTray" class="tray"></div>
    </div>
  </aside>
</main>
<div id="qrModal" style="
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.4);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
">
  <div id="qrCard" style="
    background:#fff;
    border-radius:16px;
    padding:24px;
    width:min(92vw,360px);
    text-align:center;
    box-shadow:0 18px 50px rgba(0,0,0,.25);
  ">
    <strong style="display:block;font-size:18px">Escanea para abrir</strong>
    <div style="height:12px"></div>
    <div id="qrCode" style="margin:0 auto;"></div>
    <div style="height:14px"></div>
    <button id="qrClose" class="btn ghost">Cerrar</button>
  </div>
</div>

<script>
const qs = new URLSearchParams(location.search);
 // ===== Correct answers (case + accent sensitive) =====
 // ?answers=respuesta1|respuesta2|respuesta3
 const ANSWERS = (() => {
   const raw = qs.get('answers');
   if (!raw) return null;
   return raw.split('|').map(s => s.trim());
 })();

const IS_STUDENT = qs.has('student');


(async () => {
const presetId = qs.get('preset');
if (qs.has('__applied')) return;
if (!presetId) return;

  try {
    const res = await fetch(
      'https://dmlsiyyqpcupbizpxwhp.supabase.co/storage/v1/object/public/app-presets/wordbuilder/presets.json',
      { cache: 'no-store' }
    );
    if (!res.ok) return;

    const allPresets = await res.json();
    const preset = allPresets[presetId];
    if (!preset || !preset.content) return;

    const c = preset.content;

    const inject = (key, value) => {
      if (value === undefined || value === null) return;
      if (!qs.has(key)) qs.set(key, value);
    };

    inject('boxes', c.boxes);
    inject('rows', c.rows);
    inject('perRow', c.perRow);


    if (Array.isArray(c.letters))   inject('letters', c.letters.join(','));
    if (Array.isArray(c.syllables)) inject('syll', c.syllables.join(','));
    if (Array.isArray(c.words))     inject('words', c.words.join(','));
    if (Array.isArray(c.images))    inject('imgs', c.images.join(','));

   // Inject correct answers from preset (case + accent sensitive)
   if (Array.isArray(c.answers)) {
     inject('answers', c.answers.join('|'));
   }

   
    if (c.toggles) {
      inject('space',  c.toggles.space  === false ? 'off' : undefined);
      inject('caps',   c.toggles.caps   === false ? 'off' : undefined);
      inject('accent', c.toggles.accent === false ? 'off' : undefined);
      inject('punc',   c.toggles.punc   === false ? 'off' : undefined);
      inject('images', c.toggles.images === false ? 'off' : undefined);
      inject('write', c.toggles.write === true ? 'on' : undefined);
    }

    qs.set('__applied', '1');
   const newUrl =
  location.pathname + '?' + qs.toString();

history.replaceState(null, '', newUrl);
location.reload();

    } catch {}
})();  // <-- ADD THIS LINE RIGHT HERE

  function clampInt(val, fallback, min, max){

    const n = parseInt(val, 10);
    if (Number.isFinite(n)) return Math.max(min, Math.min(max, n));
    return fallback;
  }
  function getList(keys, defaults){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaults;
    const raw = (qs.get(key) ?? '').trim();
    const lo = raw.toLowerCase();
    if (raw === '' || lo === 'off' || lo === 'false' || lo === '0' || lo === 'none') return [];
    return raw.split(',').map(s => s.trim()).filter(Boolean);
  }
  function getToggle(keys, defaultOn=true){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaultOn;
    const lo = (qs.get(key) ?? '').trim().toLowerCase();
    return !['0','off','false','none','no'].includes(lo);
  }

  // ===== Prefill (per-box, by rows) =====
  // ?prefillRows=row1box1|row1box2|.../row2box1|row2box2|...
  // "_" means a SPACE tile inside a box.
  function getPrefillRows(){
    const raw = (qs.get('prefillRows') ?? qs.get('fillRows') ?? qs.get('rowFill') ?? '').trim();
    if (!raw) return null;
    return raw.split('/').map(r => r.trim()).filter(Boolean).map(r =>
      r.split('|').map(x => x.trim())
    );
  }
  const PREFILL_ROWS = getPrefillRows();

  let BOXES_PER_ROW = clampInt(qs.get('boxCols') ?? qs.get('boxes') ?? qs.get('columns'), 4, 1, 12);
  let NUM_ROWS      = clampInt(qs.get('boxRows') ?? qs.get('rows') ?? qs.get('r'), 1, 1, 50);
  const BOX_COUNT   = clampInt(qs.get('boxCount') ?? qs.get('count'), null, 1, 500);

  // If prefillRows is present and boxCount is NOT forcing a fixed count,
  // auto-expand rows/cols so everything fits.
  if (PREFILL_ROWS && !Number.isFinite(BOX_COUNT)) {
    const needRows = PREFILL_ROWS.length;
    const needCols = Math.max(1, ...PREFILL_ROWS.map(r => r.length || 1));
    BOXES_PER_ROW = Math.max(BOXES_PER_ROW, Math.min(12, needCols));
    NUM_ROWS      = Math.max(NUM_ROWS, Math.min(50, needRows));
  }

  const perRow = clampInt(qs.get('perRow') ?? qs.get('perrow') ?? qs.get('cols') ?? qs.get('trayCols'), null, 1, 24);
  if (perRow) document.documentElement.style.setProperty('--tray-cols', String(perRow));

  /* ===== Feature toggles (URL) =====
     ?space=off   -> removes space tile next to papelera
     ?caps=off    -> hides ‚Üë ‚Üì tools and disables them
     ?accent=off  -> hides ¬¥ tool and disables it
     ?punc=off    -> hides punctuation palette
  */
  const SPACE_ON   = getToggle('space', true);
  const CAPS_ON    = getToggle(['caps','case','upper'], true);
  const ACCENT_ON  = getToggle(['accent','acento'], true);
  const PUNC_ON    = getToggle(['punc','punct','punctuation'], true);

  const IMAGES_ON = getToggle(['images','imgs','pics','pictures'], true);
  const WRITE_ON = getToggle(['write','type','input','studentwrite'], false);

  const spaceW = parseFloat(qs.get('spacew'));
  if (!isNaN(spaceW) && spaceW > 0 && spaceW < 5) {
    document.documentElement.style.setProperty('--space-w', `${spaceW}ch`);
  }

  const DEFAULT_LETTERS = ['a','e','i','o','u'];
  const DEFAULT_SYLL  = ['ma','me','mi','mo','mu'];
  const DEFAULT_WORDS = ['la','el'];
  const DEFAULT_PUNC  = ['¬ø','?','¬°','!',',','.'];

  const LETTERS  = getList('letters', DEFAULT_LETTERS);
  const SYLL     = getList(['syll','syllables'], DEFAULT_SYLL);
  const WORDS    = getList(['words','word'], DEFAULT_WORDS);
  const PUNC     = getList(['punc','punct','punctuation'], DEFAULT_PUNC);
  const IMG_URLS = getList(['imgs','images','pics','pictures'], []);

  const slotsEl       = document.getElementById('slots');
  const trashEl       = document.getElementById('trash');
  const trashSpaceEl  = document.getElementById('trashSpace');

  const lettersTray = document.getElementById('lettersTray');
  const syllTray    = document.getElementById('syllTray');
  const wordsTray   = document.getElementById('wordsTray');
  const puncTray    = document.getElementById('puncTray');
  const picsTray    = document.getElementById('picsTray');

  const lettersCard = document.getElementById('lettersCard');
  const syllCard    = document.getElementById('syllCard');
  const wordsCard   = document.getElementById('wordsCard');
  const puncCard    = document.getElementById('puncCard');
  const picsCard    = document.getElementById('picsCard');

  const lettersTools = document.getElementById('lettersTools');
  const syllTools    = document.getElementById('syllTools');
  const wordsTools   = document.getElementById('wordsTools');

  const boxesInput = document.getElementById('boxesInput');
  const rowsInput  = document.getElementById('rowsInput');
  const applyBoxes = document.getElementById('applyBoxes');
  const validateBtn= document.getElementById('validateBtn');
  const qrBtn    = document.getElementById('qrBtn');
  const teacherControls = document.getElementById('teacherControls');

  const qrModal  = document.getElementById('qrModal');
  const qrClose  = document.getElementById('qrClose');
  const qrCodeEl = document.getElementById('qrCode');
  
  let qrInstance = null;
  
  if (IS_STUDENT && teacherControls) {
    teacherControls.style.display = 'none';
  }

 
  boxesInput.value = BOXES_PER_ROW;
  rowsInput.value  = NUM_ROWS;

  function applyCapToTile(tile, mode){
    if (!tile || tile.dataset.kind !== 'text') return;
    const cur = tile.dataset.text ?? tile.textContent ?? '';
    if (!cur) return;
    const first = cur[0];
    const rest  = cur.slice(1);
    const out = (mode === 'up' ? first.toUpperCase() : first.toLowerCase()) + rest;
    tile.dataset.text = out;
    tile.textContent  = out;
  }

  const plainToAcc = { a:'√°', e:'√©', i:'√≠', o:'√≥', u:'√∫',
                       A:'√Å', E:'√â', I:'√ç', O:'√ì', U:'√ö' };
  const accToPlain = { √°:'a', √©:'e', √≠:'i', √≥:'o', √∫:'u',
                       √Å:'A', √â:'E', √ç:'I', √ì:'O', √ö:'U' };

  function applyAccentAtPointer(tile, clientX){
    if (!tile || tile.dataset.kind !== 'text') return;

    const cur = tile.dataset.text ?? tile.textContent ?? '';
    const len = cur.length;
    if (!len) return;

    const rect = tile.getBoundingClientRect();
    const safeWidth = rect.width || 1;
    let relX = clientX - rect.left;
    if (relX < 0) relX = 0;
    if (relX > safeWidth) relX = safeWidth;

    let approx = Math.floor((relX / safeWidth) * len);
    if (approx < 0) approx = 0;
    if (approx >= len) approx = len - 1;

    const chars = [...cur];
    const isAccentable = (ch) => !!plainToAcc[ch] || !!accToPlain[ch];

    let idx = approx;
    if (!isAccentable(chars[idx])) {
      let best = -1;
      let bestDist = Infinity;
      for (let i = 0; i < len; i++){
        if (!isAccentable(chars[i])) continue;
        const d = Math.abs(i - approx);
        if (d < bestDist){
          bestDist = d;
          best = i;
        }
      }
      if (best === -1) return;
      idx = best;
    }

    const c = chars[idx];
    if (plainToAcc[c]) chars[idx] = plainToAcc[c];
    else if (accToPlain[c]) chars[idx] = accToPlain[c];
    else return;

    const out = chars.join('');
    tile.dataset.text = out;
    tile.textContent  = out;
  }

  function makeTextTile(text, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile' + (isClone ? ' clone' : '');
    div.dataset.kind = 'text';
    div.dataset.text = text;
    div.textContent  = text;
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makePuncTile(ch, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile punc' + (isClone ? ' clone' : '');
    div.dataset.kind = 'punc';
    div.dataset.text = ch;
    div.textContent  = ch;
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeImageTile(url, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile img' + (isClone ? ' clone' : '');
    div.dataset.kind = 'img';
    div.dataset.src = url;
    const im = document.createElement('img');
    im.src = url;
    im.alt = 'img';
    div.appendChild(im);
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeSpaceTile(isClone=false){
    const div = document.createElement('div');
    div.className = 'tile space' + (isClone ? ' clone' : '');
    div.dataset.kind = 'space';
    div.dataset.text = ' ';
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }
 
  function makeWriteTile(isClone=false){
   const div = document.createElement('div');
   div.className = 'tile write' + (isClone ? ' clone' : '');
   div.dataset.kind = 'write';
   div.dataset.text = '';
 
   const input = document.createElement('input');
   input.type = 'text';
   input.placeholder = '';
   input.className = 'write-input';
 
   // keep tile text synced for validation
   input.addEventListener('input', ()=>{
    const val = input.value || '';
  
    div.dataset.text = val;
  
    // ===== REAL AUTO WIDTH =====
    // ‚≠ê ONLY auto-grow when NOT inside slot
   if (!div.classList.contains('in-slot')){
   
     const ghost = document.createElement('span');
     ghost.style.position = 'absolute';
     ghost.style.visibility = 'hidden';
     ghost.style.whiteSpace = 'pre';
     ghost.style.font = getComputedStyle(input).font;
     ghost.textContent = val || ' ';
     document.body.appendChild(ghost);
   
     const w = ghost.offsetWidth + 12;
     ghost.remove();
   
     input.style.width = w + 'px';
   }
  });
 
   // IMPORTANT: typing should NOT start dragging
   input.addEventListener('pointerdown', (e)=>{
     e.stopPropagation();
   });

   // ‚≠ê DOUBLE TAP TO CLEAR
   let lastTap = 0;
   input.addEventListener('pointerup', ()=>{
     const now = Date.now();
     if (now - lastTap < 300){
       input.value = '';
       div.dataset.text = '';
       input.style.width = '12px';
     }
     lastTap = now;
   });
 
   div.appendChild(input);
   // ‚≠ê START SMALL (same logic as typing)
  requestAnimationFrame(()=>{
    const ghost = document.createElement('span');
    ghost.style.position = 'absolute';
    ghost.style.visibility = 'hidden';
    ghost.style.whiteSpace = 'pre';
    ghost.style.font = getComputedStyle(input).font;
    ghost.textContent = ' ';
    document.body.appendChild(ghost);
  
    const w = ghost.offsetWidth + 12;
    ghost.remove();
  
    input.style.width = w + 'px';
  });
   
   makeDraggable(div, { cloneOnDrag: !isClone });
   return div;
 }

  function makeWriteGenerator(){
   const div = document.createElement('div');
   div.className = 'tile writegen';
   div.textContent = '+';
   div.title = 'Nueva ficha para escribir';
 
   div.addEventListener('pointerdown', (e)=>{
     e.stopPropagation();
 
     const newTile = makeWriteTile(false);
 
     // insert BEFORE the +
     lettersTray.insertBefore(newTile, div);
 
     // focus input immediately
     const inp = newTile.querySelector('input');
     if (inp) setTimeout(()=>inp.focus(),0);
   });
 
   return div;
 }
 
  function makeCapTool(mode){
    const div = document.createElement('div');
    div.className = 'tile captool';
    div.dataset.kind = 'captool';
    div.dataset.mode = mode;
    div.textContent  = mode === 'up' ? '‚Üë' : '‚Üì';
    makeDraggable(div, { cloneOnDrag:true });
    return div;
  }

  function makeAccentTool(){
    const div = document.createElement('div');
    div.className = 'tile accenttool';
    div.dataset.kind = 'accenttool';
    div.textContent  = '¬¥';
    makeDraggable(div, { cloneOnDrag:true });
    return div;
  }

  function buildRows(boxesPerRow, numRows, countOverride){
    let rows = numRows;
    if (Number.isFinite(countOverride)) {
      rows = Math.max(1, Math.ceil(countOverride / boxesPerRow));
    }
    slotsEl.innerHTML = '';
    let index = 0;
    for (let r = 0; r < rows; r++){
      const line = document.createElement('div');
      line.className = 'line';
      const boxesThisRow = Number.isFinite(countOverride)
        ? Math.min(boxesPerRow, Math.max(0, countOverride - r*boxesPerRow))
        : boxesPerRow;
      for (let c = 0; c < boxesThisRow; c++){
        const s = document.createElement('div');
        s.className = 'slot';
        s.dataset.index = index++;
        line.appendChild(s);
      }
      slotsEl.appendChild(line);
    }
  }

  function fillPalettes(){
    lettersTray.innerHTML = '';
    lettersCard.style.display = LETTERS.length || WRITE_ON ? '' : 'none';
    
    if (WRITE_ON){
      lettersTray.appendChild(makeWriteTile(false));
      lettersTray.appendChild(makeWriteGenerator());
    }
    
    LETTERS.forEach(t => lettersTray.appendChild(makeTextTile(t, false)));

    syllTray.innerHTML = '';
    syllCard.style.display = SYLL.length ? '' : 'none';
    SYLL.forEach(t => syllTray.appendChild(makeTextTile(t, false)));

    wordsTray.innerHTML = '';
    wordsCard.style.display = WORDS.length ? '' : 'none';
    WORDS.forEach(w => wordsTray.appendChild(makeTextTile(w, false)));

    puncTray.innerHTML = '';
    puncCard.style.display = (PUNC_ON && PUNC.length) ? '' : 'none';
    if (PUNC_ON) {
      PUNC.forEach(ch => puncTray.appendChild(makePuncTile(ch, false)));
    }

    picsTray.innerHTML = '';
    picsCard.style.display = IMAGES_ON ? '' : 'none';
    if (IMAGES_ON) IMG_URLS.forEach(u => picsTray.appendChild(makeImageTile(u, false)));

    // Space tile next to Papelera (toggleable)
    trashSpaceEl.innerHTML = '';
    if (SPACE_ON) {
      trashSpaceEl.appendChild(makeSpaceTile(false));
    }

    function attachTools(container){
      container.innerHTML = '';
      if (CAPS_ON) {
        container.appendChild(makeCapTool('up'));
        container.appendChild(makeCapTool('down'));
      }
      if (ACCENT_ON) {
        container.appendChild(makeAccentTool());
      }
    }
    attachTools(lettersTools);
    attachTools(syllTools);
    attachTools(wordsTools);
  }

  function relayoutSlot(slot){
    const tiles = [...slot.querySelectorAll('.tile')];
  
    tiles.forEach(t=>{
      t.classList.add('in-slot');
      const inp = t.querySelector?.('.write-input');
      if (inp) inp.style.width = '';   // ‚≠ê release fixed width
      // ‚≠ê SHRINK-TO-FIT TEXT ONLY
      if (t.dataset.kind === 'text' || t.dataset.kind === 'write'){
        fitTextToSlot(t, slot);
      }
    });
  }
  function relayoutAllSlots(){
    document.querySelectorAll('.slot').forEach(relayoutSlot);
  }

  function fitTextToSlot(tile, slot){
  
    const maxWidth = slot.clientWidth - 16;
    if (!maxWidth) return;
  
    const tiles = [...slot.querySelectorAll('.tile')]
      .filter(t => t.dataset.kind === 'text' || t.dataset.kind === 'write');
  
    if (!tiles.length) return;
  
    let sharedSize = 56;
    const MIN_FONT = 22;   // ‚≠ê you can tweak later
  
    // --- PASS 1: SHRINK ---
    tiles.forEach(t=>{
      let measureEl;
      let applyEl;
      
      if (t.dataset.kind === 'write'){
        applyEl = t.querySelector('.write-input');
        if (!applyEl) return;
      
        // ‚≠ê create ghost span for accurate width measuring
        const ghost = document.createElement('span');
        ghost.style.position = 'absolute';
        ghost.style.visibility = 'hidden';
        ghost.style.whiteSpace = 'nowrap';
        ghost.style.font = getComputedStyle(applyEl).font;
        ghost.textContent = applyEl.value || ' ';
        document.body.appendChild(ghost);
      
        measureEl = ghost;
      
      }else{
        applyEl = t;
        measureEl = t;
      }
  
      t.classList.remove('wrap-mode');
  
      let size = 56;
      applyEl.style.fontSize = size + 'px';
      measureEl.style.fontSize = size + 'px';
  
      while (measureEl.scrollWidth > maxWidth && size > MIN_FONT){
        size -= 1;
        applyEl.style.fontSize = size + 'px';
        measureEl.style.fontSize = size + 'px';
      }

     if (measureEl !== applyEl) measureEl.remove();
  
      sharedSize = Math.min(sharedSize, size);
    });
  
    // --- APPLY SHARED SIZE ---
    tiles.forEach(t=>{
      let target = t;
      if (t.dataset.kind === 'write'){
        target = t.querySelector('.write-input');
        if (!target) return;
      }
      target.style.fontSize = sharedSize + 'px';
    });
  
    // --- PASS 2: WRAP IF STILL TOO WIDE ---
    tiles.forEach(t=>{
      let target = t;
      if (t.dataset.kind === 'write'){
        target = t.querySelector('.write-input');
        if (!target) return;
      }
  
      if (target.scrollWidth > maxWidth){

        // ‚≠ê FORCE WORD BREAKING
        t.style.wordBreak = 'break-word';
        t.style.overflowWrap = 'anywhere';
      
        t.classList.add('wrap-mode');
      }
      else{
        t.style.wordBreak = '';
        t.style.overflowWrap = '';
      }
    });
  }

  // ===== Prefill helpers (per-box) =====
  function isPuncChar(ch){
    return PUNC.includes(ch);
  }
  function addTokenToSlot(slot, token){
    if (token === '_') {
      slot.appendChild(makeSpaceTile(true));
      return;
    }
    if (token.length === 1 && isPuncChar(token)) {
      slot.appendChild(makePuncTile(token, true));
      return;
    }
    slot.appendChild(makeTextTile(token, true));
  }
  function fillSlotFromString(slot, str){
    if (!str) return;

    // Convert real spaces into "_" tokens too (so "hola mundo" works)
    str = str.replace(/ /g, '_');

    let buf = '';
    for (const ch of [...str]){
      if (ch === '_'){
        if (buf) { addTokenToSlot(slot, buf); buf = ''; }
        addTokenToSlot(slot, '_');
        continue;
      }
      if (isPuncChar(ch)){
        if (buf) { addTokenToSlot(slot, buf); buf = ''; }
        addTokenToSlot(slot, ch);
        continue;
      }
      buf += ch;
    }
    if (buf) addTokenToSlot(slot, buf);
  }
  function applyPrefillRows(){
    if (!PREFILL_ROWS || !PREFILL_ROWS.length) return;
    const lines = [...document.querySelectorAll('.line')];
    for (let r = 0; r < lines.length; r++){
      const rowData = PREFILL_ROWS[r];
      if (!rowData) continue;
      const slots = [...lines[r].querySelectorAll('.slot')];
      for (let c = 0; c < slots.length; c++){
        const content = rowData[c];
        if (!content) continue;
        fillSlotFromString(slots[c], content);
      }
    }
  }

  let drag = null;
  const DRAG_Y_OFFSET = 48; // pixels above finger (tweak later if needed)



/* ===== INSERTION SNAP STATE ===== */
let activeInsert = null; // { slot, index }

function clearPreview(){
  document.querySelectorAll('.slot').forEach(s=>{
    s.classList.remove(
      'preview-edge-left',
      'preview-edge-right',
      'preview-empty'
    );
  });
  document.querySelectorAll('.tile.preview-after').forEach(t=>{
    t.classList.remove('preview-after');
  });
  activeInsert = null;
}

function getNearestIndex(slot, clientX, movingEl){
  const tiles = [...slot.querySelectorAll('.tile')].filter(t => t !== movingEl);

  if (tiles.length === 0) return 0;

  const first = tiles[0].getBoundingClientRect();
  const last  = tiles[tiles.length - 1].getBoundingClientRect();

  if (clientX < first.left + first.width / 2) return 0;
  if (clientX > last.left  + last.width  / 2) return tiles.length;

  for (let i = 0; i < tiles.length - 1; i++){
    const a = tiles[i].getBoundingClientRect();
    const b = tiles[i + 1].getBoundingClientRect();
    const mid = (a.right + b.left) / 2;
    if (clientX < mid) return i + 1;
  }

  return tiles.length;
}

function applyPreview(slot, index, movingEl){
  clearPreview();
  activeInsert = { slot, index };

  const tiles = [...slot.querySelectorAll('.tile')].filter(t => t !== movingEl);

  if (tiles.length === 0){
    slot.classList.add('preview-empty');
    return;
  }

  if (index === 0){
    slot.classList.add('preview-edge-left');
    return;
  }

  if (index === tiles.length){
    slot.classList.add('preview-edge-right');
    return;
  }

  tiles[index].classList.add('preview-after');
}


  function makeDraggable(el, opts){
    const cloneOnDrag = !!opts?.cloneOnDrag;
    el.style.touchAction = 'none';

    el.addEventListener('pointerdown', (e)=>{
      if(e.button!==0) return;
      document.body.classList.add('drag-active');
      const src = e.currentTarget;
      const parent = src.parentElement;
      const isPalette = [
        lettersTray, syllTray, wordsTray, puncTray, picsTray,
        trashSpaceEl, lettersTools, syllTools, wordsTools
      ].includes(parent);

      let dragEl;
      if (cloneOnDrag && isPalette){
        const k = src.dataset.kind;
        if (k === 'img') dragEl = makeImageTile(src.dataset.src, true);
        else if (k === 'space') dragEl = makeSpaceTile(true);
        else if (k === 'punc') dragEl = makePuncTile(src.dataset.text, true);
        else if (k === 'captool') dragEl = makeCapTool(src.dataset.mode);
        else if (k === 'accenttool') dragEl = makeAccentTool();
        else dragEl = makeTextTile(src.dataset.text, true);
      } else {
        dragEl = src;
      }

      if (dragEl !== src && isPalette){
        document.body.appendChild(dragEl);
      }

      drag = {
        el: dragEl,
        pointerId: e.pointerId,
        fromPalette: isPalette,
        originParent: isPalette ? null : src.parentElement
      };
      drag.el.classList.add('dragging');
      Object.assign(drag.el.style, {
        position:'fixed', zIndex:1000, pointerEvents:'none',
        width: dragEl.offsetWidth + 'px',
        height: dragEl.offsetHeight + 'px'
      });
      moveTo(drag.el, e.clientX, e.clientY);

      document.addEventListener('pointermove', onMove, {passive:false});
      document.addEventListener('pointerup', onUp, {passive:false});
      document.addEventListener('pointercancel', onCancel, {passive:false});
    });
  }

  function moveTo(el, x, y){
  el.style.left = (x - 28) + 'px';
  el.style.top  = (y - 28 - DRAG_Y_OFFSET) + 'px';
}


  function onMove(e){
    if(!drag || e.pointerId !== drag.pointerId) return;
  
    moveTo(drag.el, e.clientX, e.clientY);
  
    clearPreview();
  
    const virtualY = e.clientY - DRAG_Y_OFFSET;
    const t = document.elementFromPoint(e.clientX, virtualY);

    const slot = t?.closest?.('.slot');
    const kind = drag.el.dataset.kind;
  
    // Trash highlight (unchanged behavior)
    trashEl.classList.toggle(
      'highlight',
      kind !== 'captool' &&
      kind !== 'accenttool' &&
      !!t?.closest?.('#trash')
    );
  
    // Tools do NOT get insertion previews
    if (!slot || kind === 'captool' || kind === 'accenttool') return;
  
    const index = getNearestIndex(slot, e.clientX, drag.el);

    applyPreview(slot, index, drag.el);
  }








  function onUp(e){
    if(!drag || e.pointerId!==drag.pointerId) return;
    const virtualY = e.clientY - DRAG_Y_OFFSET;
    const t = document.elementFromPoint(e.clientX, virtualY);

    const kind = drag.el.dataset.kind;

    if (kind === 'captool'){
      if (!CAPS_ON) { drag.el.remove();  cleanup(); return; }
      const tile = t?.closest?.('.tile[data-kind="text"]');
      if (tile) applyCapToTile(tile, drag.el.dataset.mode === 'down' ? 'down' : 'up');
      drag.el.remove();
      
      cleanup();
      return;
    }

    if (kind === 'accenttool'){
      if (!ACCENT_ON) { drag.el.remove();  cleanup(); return; }
      const tile = t?.closest?.('.tile[data-kind="text"]');
      if (tile) {
        const accRect = drag.el.getBoundingClientRect();
        const centerX = accRect.left + accRect.width / 2;
        applyAccentAtPointer(tile, centerX);
      }
      drag.el.remove();
      
      cleanup();
      return;
    }

    const onTrash = !!t?.closest?.('#trash');
    const slot = t?.closest?.('.slot');

    

    drag.el.classList.remove('dragging');
    Object.assign(drag.el.style, {position:'', left:'', top:'', zIndex:'', pointerEvents:'', width:'', height:''});

    if(onTrash){
      const prev = drag.el.parentElement;
      drag.el.remove();
      if(prev?.classList.contains('slot')) relayoutSlot(prev);

} else if (activeInsert && activeInsert.slot === slot) {
  const { slot, index } = activeInsert;
  const prev = drag.el.parentElement;

  if (prev?.classList?.contains('slot')) {
    try { prev.removeChild(drag.el); } catch {}
  }

  const tiles = [...slot.querySelectorAll('.tile')];
  if (index >= tiles.length) {
    slot.appendChild(drag.el);
  } else {
    slot.insertBefore(drag.el, tiles[index]);
  }

  relayoutSlot(slot);
  if (prev && prev !== slot && prev.classList.contains('slot')) {
    relayoutSlot(prev);
  }
}
 else {
      if(drag.fromPalette){
        drag.el.remove();
      } else if (drag.originParent){
        drag.originParent.appendChild(drag.el);
        if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
      }
    }
    cleanup();
  }

  function onCancel(){
    if(!drag) return;
    if(drag.fromPalette ||
       drag.el.dataset.kind === 'captool' ||
       drag.el.dataset.kind === 'accenttool'){
      drag.el.remove();
    } else if (drag.originParent){
      drag.originParent.appendChild(drag.el);
      if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
    }
    cleanup();
  }
  function cleanup(){
    clearPreview();
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', onUp);
    document.removeEventListener('pointercancel', onCancel);
    document.body.classList.remove('drag-active');
    drag = null;
  }

  ['dragenter','dragover'].forEach(ev=>{
    picsTray.addEventListener(ev, e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
  });
  picsTray.addEventListener('drop', async e=>{
    e.preventDefault();
    const files = [...(e.dataTransfer?.files||[])].filter(f=>f.type.startsWith('image/'));
    for(const f of files){
      const url = URL.createObjectURL(f);
      picsTray.appendChild(makeImageTile(url, false));
    }
  });
  window.addEventListener('paste', e=>{
    const items = [...(e.clipboardData?.items||[])];
    items.forEach(it=>{
      if(it.type && it.type.startsWith('image/')){
        const file = it.getAsFile();
        if(file){
          const url = URL.createObjectURL(file);
          picsTray.appendChild(makeImageTile(url, false));
        }
      }
    });
  });
// ===== CONFETTI (LetterSort-style, no library) =====
function launchConfetti(){
  const count = 80;
  const duration = 900;
  const end = Date.now() + duration;

  (function frame(){
    const now = Date.now();
    if (now > end) return;

    for (let i = 0; i < 4; i++){
      const conf = document.createElement('div');
      conf.style.position = 'fixed';
      conf.style.left = Math.random() * 100 + 'vw';
      conf.style.top = '-10px';
      conf.style.width = '8px';
      conf.style.height = '8px';
      conf.style.background = `hsl(${Math.random()*360},90%,60%)`;
      conf.style.borderRadius = '50%';
      conf.style.opacity = '0.9';
      conf.style.zIndex = 3000;
      conf.style.pointerEvents = 'none';

      document.body.appendChild(conf);

      const fall = conf.animate([
        { transform: 'translateY(0)', opacity: 1 },
        { transform: `translateY(${window.innerHeight + 100}px)`, opacity: 0 }
      ], {
        duration: 700 + Math.random() * 400,
        easing: 'ease-in'
      });

      fall.onfinish = () => conf.remove();
    }

    requestAnimationFrame(frame);
  })();
}

validateBtn.addEventListener('click', ()=>{
  // Reset validation outlines
  document.querySelectorAll('.slot').forEach(slot=>{
    slot.classList.remove('correct','incorrect','unanswered');
  });
 
  let allCorrect = true;

  // If no answer key, do nothing
  if (!ANSWERS) return;

  const slots = [...document.querySelectorAll('.slot')];

  slots.forEach((slot, i)=>{
    let built = '';

    [...slot.querySelectorAll('.tile')].forEach(t=>{
      const k = t.dataset.kind;

      if (k === 'text') {
        built += t.dataset.text ?? t.textContent ?? '';
      }
      else if (k === 'write') {
        built += t.dataset.text || '';
      }
      else if (k === 'space') {
        built += ' ';
      }
      else if (k === 'img') {
        built += '[img]';
      }
      else if (k === 'punc') {
        const ch = t.dataset.text || t.textContent || '';
        if (',.?!'.includes(ch)) {
          built = built.replace(/\s+$/,'');
          built += ch;
        } else {
          built += ch;
        }
      }
    });

    built = built.trim();
    const expected = ANSWERS[i];

    if (!expected) return; // no answer for this box

    if (!built) {
      slot.classList.add('unanswered');
      allCorrect = false;
    }
    else if (built === expected) {
      slot.classList.add('correct');
    }
    else {
      slot.classList.add('incorrect');
      allCorrect = false;
    }

  });

  // üéâ All correct ‚Üí celebrate
  if (allCorrect) {
    launchConfetti();
  }
});


 
qrBtn.addEventListener('click', () => {
  qrModal.style.display = 'flex';
  qrCodeEl.innerHTML = '';

  const qrQs = new URLSearchParams(location.search);
  qrQs.set('student', '1'); // force student mode

  const cleanUrl =
    location.origin +
    location.pathname +
    '?' +
    qrQs.toString();

  qrInstance = new QRCode(qrCodeEl, {
    text: cleanUrl,
    width: 260,
    height: 260,
    correctLevel: QRCode.CorrectLevel.M
  });
});


 
function closeQR(){
  qrModal.style.display = 'none';
  qrCodeEl.innerHTML = '';
}

qrClose.addEventListener('click', closeQR);

// Click outside the white card closes the modal
qrModal.addEventListener('click', closeQR);

// Clicking inside the white card should NOT close it
document.getElementById('qrCard').addEventListener('click', (e) => {
  e.stopPropagation();
});


  applyBoxes.addEventListener('click', ()=>{
    const boxesPer = clampInt(boxesInput.value, BOXES_PER_ROW, 1, 12);
    const rows     = clampInt(rowsInput.value,  NUM_ROWS,      1, 50);
    buildRows(boxesPer, rows, null);
    relayoutAllSlots();
  });

  buildRows(BOXES_PER_ROW, NUM_ROWS, BOX_COUNT);
  fillPalettes();
  applyPrefillRows();
  relayoutAllSlots();
if (qs.has('preset')) {
  history.replaceState(
    null,
    '',
    `${location.pathname}?preset=${encodeURIComponent(qs.get('preset'))}`
  );
}

</script>


</body>
</html>
