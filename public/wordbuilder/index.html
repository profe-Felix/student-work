<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Construye palabras ‚Äî Letras, S√≠labas, Palabras & Im√°genes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

<style>
  *{box-sizing:border-box}
  :root{
    --bg:#fafbff; --grid:#eef1f7; --ink:#111; --muted:#6b7280; --brand:#2563eb;
    --tile:#fff; --tile-border:#111827; --drop:#ffffff; --drop-border:#111827;
    --trash:#fee2e2; --danger:#ef4444;
    --gap:12px;              /* gap between word boxes / rows */
    --inner-gap:10px;        /* gap inside a word box (between tiles) */
    --tile-min-w:48px;       /* palette text tile base size */
    --tile-h:48px;
    --tile-fs:28px;
    --tray-cols: 10;         /* items per row in right palettes (URL-overridable) */
    --space-w: 1ch;          /* width of space when dropped */
  }
  html,body{height:100%}
  body{
    margin:0; font:18px/1.35 Andika, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--ink); background:
      linear-gradient(0deg, transparent calc(100% - 1px), var(--grid) 1px),
      linear-gradient(90deg, transparent calc(100% - 1px), var(--grid) 1px),
      var(--bg);
    background-size:40px 40px, 40px 40px, auto;
  }

  header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e7eb}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .row{display:flex;gap:12px;align-items:center}
  .spacer{flex:1}
  h1{font-size:20px;margin:0}

  .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{border:1px solid #d1d5db;background:var(--brand);color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.ghost{background:#fff;color:#111}
  input[type=number]{font:inherit;border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;min-width:70px}
  small.note{color:var(--muted)}

  main{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:1.2fr 1fr;gap:16px}
  @media (max-width:1000px){ main{grid-template-columns:1fr} }

  /* Board */
  .board{
    background:var(--drop);
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:12px;
  }

  /* Rows-based board (no CSS grid) */
  .slots{
    display:flex;
    flex-direction:column;
    gap:var(--gap);
    align-items:stretch;
    justify-content:flex-start;
  }
  .line{
    display:flex;
    gap:var(--gap);
    align-items:flex-start;
    justify-content:flex-start;
    flex-wrap:nowrap;
    width:100%;
  }

  .slot{
    background:#fff;
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:6px 8px;
    display:inline-flex;               /* tighter natural sizing */
    gap:var(--inner-gap);
    align-items:center;
    justify-content:flex-start;
    flex-wrap:nowrap;
    min-width:max(6ch, 80px);          /* keeps minimum shape */
    width:auto;                        /* shrink to fit contents */
    position:relative;
    vertical-align:top;
  }
  .slot:empty::before{
    content:"";
    display:block;
    width:8ch;                         /* nice default syllable width */
    height:clamp(40px, 6vh, 64px);
  }

  /* Bottom: note + trash stacked on the left */
  .row-bottom{margin-top:12px}
  .note-wrap{display:flex;flex-direction:column;align-items:flex-start;gap:6px}
  .trash{
    display:inline-flex;align-items:center;gap:8px;
    background:var(--trash);border:2px dashed var(--danger);color:#991b1b;
    padding:6px 10px;border-radius:12px;font-size:16px;user-select:none
  }

  /* Right palettes */
  .palettes{display:grid;grid-template-columns:1fr;gap:14px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px}
  .card h2{margin:0 0 8px;font-size:18px}
  .card small{color:var(--muted)}
  .tray{
    display:grid;
    grid-template-columns: repeat(var(--tray-cols), max-content);
    gap:8px;
  }

  /* Text tiles */
  .tile{
    user-select:none; -webkit-user-drag:none; touch-action:none;
    display:inline-flex; align-items:center; justify-content:center;
    min-width:var(--tile-min-w); height:var(--tile-h); padding:0 12px;
    background:var(--tile); border:2px solid var(--tile-border); border-radius:12px;
    font-size:var(--tile-fs); line-height:1; cursor:grab; position:relative;
    transition:transform .05s ease;
  }
  .tile:active{cursor:grabbing; transform:scale(.98)}
  .tile .x{
    position:absolute; top:-8px; right:-8px; width:22px; height:22px; border-radius:999px;
    background:#fff; border:2px solid var(--danger); color:#ef4444; font-size:14px; display:none;
    align-items:center; justify-content:center; cursor:pointer
  }
  .tile.clone .x{display:flex}
  .dragging{opacity:.9; box-shadow:0 8px 24px rgba(0,0,0,.15)}
  .highlight{outline:3px solid #a5b4fc; outline-offset:2px}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#1e3a8a;font-size:12px;margin-left:8px}

  /* In-slot compact look (remove inner box) */
  .slot .tile.in-slot{
    flex:0 0 auto; min-width:0;
    height:clamp(40px, 6vh, 64px);
    font-size:clamp(26px, 3.4vw, 56px);
    padding:0 6px;
    background:transparent; border:none; border-radius:0; box-shadow:none;
  }
  .slot .tile.in-slot .x{ top:-6px; right:-6px; }

  /* Image tiles */
  .tile.img{ padding:4px 6px; min-width:auto; }
  .tile.img img{ display:block; max-height:var(--tile-h); height:auto; width:auto; max-width:160px; }
  .slot .tile.img.in-slot{ background:transparent; border:none; padding:0 4px; }
  .slot .tile.img.in-slot img{ max-height:clamp(40px, 6vh, 64px); border-radius:6px; }

  /* Space tile */
  .tile.space{
    border-style:dashed;
    background:#f3f4f6;
    min-width:auto;
    padding:0 10px;
    font-size:16px;
  }
  .tile.space::after{ content:"‚ê£"; }
  .slot .tile.space.in-slot{
    width:var(--space-w);
    min-width:var(--space-w);
    padding:0;
    height:clamp(40px, 6vh, 64px);
    font-size:0;                 /* invisible label */
    background:transparent;
    border:none;
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1>Construye palabras</h1>
      <span class="pill">Arrastra desde los paneles ‚Üí se clona</span>
      <div class="spacer"></div>
      <div class="toolbar">
        <label>Cajas:
          <input id="boxesInput" type="number" min="1" max="12" value="4"/>
        </label>
        <label>Filas:
          <input id="rowsInput" type="number" min="1" max="50" value="1"/>
        </label>
        <button id="applyBoxes" class="btn ghost">Aplicar</button>
        <button id="validateBtn" class="btn">Validar</button>
      </div>
    </div>
  </div>
</header>

<main>
  <!-- LEFT: Word building board -->
  <section class="board">
    <div id="slots" class="slots"></div>
    <div class="row-bottom">
      <div class="note-wrap">
        <small class="note">Consejo: suelta sobre la papelera para borrar.</small>
        <div id="trash" class="trash" aria-label="Papelera">üóëÔ∏è Papelera</div>
      </div>
    </div>
  </section>

  <!-- RIGHT: Palettes -->
  <aside class="palettes">
    <div class="card" id="spaceCard">
      <h2>Espacio</h2>
      <div id="spaceTray" class="tray"></div>
    </div>
    <div class="card" id="lettersCard">
      <h2>Letras</h2>
      <div id="lettersTray" class="tray"></div>
    </div>
    <div class="card" id="syllCard">
      <h2>S√≠labas</h2>
      <div id="syllTray" class="tray"></div>
    </div>
    <div class="card" id="wordsCard">
      <h2>Palabras</h2>
      <div id="wordsTray" class="tray"></div>
    </div>
    <div class="card" id="picsCard">
      <h2>Im√°genes</h2>
      <small>Arrastra im√°genes (o p√©galos) aqu√≠. Tambi√©n puedes precargar con <code>?imgs=URL1,URL2</code>.</small>
      <div id="picsTray" class="tray"></div>
    </div>
  </aside>
</main>

<script>
  /* ===== URL options ===== */
  const qs = new URLSearchParams(location.search);

  /* Helpers */
  function clampInt(val, fallback, min, max){
    const n = parseInt(val, 10);
    if (Number.isFinite(n)) return Math.max(min, Math.min(max, n));
    return fallback;
  }
  // Omit ‚Üí defaults; blank/off/false/0/none ‚Üí []; otherwise split by comma
  function getList(keys, defaults){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaults;
    const raw = (qs.get(key) ?? '').trim();
    const lo = raw.toLowerCase();
    if (raw === '' || lo === 'off' || lo === 'false' || lo === '0' || lo === 'none') return [];
    return raw.split(',').map(s => s.trim()).filter(Boolean);
  }
  function getToggle(keys, defaultOn=true){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaultOn;
    const lo = (qs.get(key) ?? '').trim().toLowerCase();
    return !['0','off','false','none','no'].includes(lo);
  }

  /* Old single-number (kept for compat; unused by builder now) */
  const BOXES = clampInt(qs.get('boxes') ?? qs.get('drops'), 4, 1, 12);

  /* Rows-based controls: boxes per row + number of rows */
  const BOXES_PER_ROW = clampInt(
    qs.get('boxCols') ?? qs.get('boxes') ?? qs.get('columns'),
    4, 1, 12
  );
  const NUM_ROWS = clampInt(
    qs.get('boxRows') ?? qs.get('rows') ?? qs.get('r'),
    1, 1, 50
  );

  /* Optional fixed total (still supported) */
  const BOX_COUNT = clampInt(qs.get('boxCount') ?? qs.get('count'), null, 1, 500);

  /* Palettes per-row */
  const perRow = clampInt(qs.get('perRow') ?? qs.get('perrow') ?? qs.get('cols') ?? qs.get('trayCols'), null, 1, 24);
  if (perRow) document.documentElement.style.setProperty('--tray-cols', String(perRow));

  /* Space + Images toggles */
  const SPACE_ON = getToggle('space', true);
  const IMAGES_ON = getToggle(['images','imgs','pics','pictures'], true);

  const spaceW = parseFloat(qs.get('spacew'));
  if (!isNaN(spaceW) && spaceW > 0 && spaceW < 5) {
    document.documentElement.style.setProperty('--space-w', `${spaceW}ch`);
  }

  /* ===== Data ===== */
  const DEFAULT_LETTERS = [
    '√≥','o','m','t','n','g','qu',
    '√°','a','p','d','f','ch','z',
    '√≠','i','s','r','b','√±','h',
    '√∫','u','l','c','j','v','y',
    '√©','e','ll','k','w','x'
  ];
  const DEFAULT_SYLL = ['ma','me','mi','mo','mu','la','le','li','lo','lu','pa','pe','pi','po','pu','sa','se','si','so','su','bra','bre','bri','bro','bru','cha','che','chi','cho','chu','que','qui'];
  const DEFAULT_WORDS = ['yo','t√∫','mi','la','el','un','una','me','te','va','no','s√≠'];

  const LETTERS = getList('letters', DEFAULT_LETTERS);
  const SYLL = getList(['syll','syllables'], DEFAULT_SYLL);
  const WORDS = getList(['words','word'], DEFAULT_WORDS);
  const IMG_URLS = getList(['imgs','images','pics','pictures'], []); // optional

  /* ===== DOM refs ===== */
  const slotsEl = document.getElementById('slots');
  const trashEl = document.getElementById('trash');

  const spaceCard = document.getElementById('spaceCard');
  const spaceTray = document.getElementById('spaceTray');

  const lettersTray = document.getElementById('lettersTray');
  const syllTray = document.getElementById('syllTray');
  const wordsTray = document.getElementById('wordsTray');
  const picsTray = document.getElementById('picsTray');

  const lettersCard = document.getElementById('lettersCard');
  const syllCard   = document.getElementById('syllCard');
  const wordsCard  = document.getElementById('wordsCard');
  const picsCard   = document.getElementById('picsCard');

  const boxesInput = document.getElementById('boxesInput');
  const rowsInput  = document.getElementById('rowsInput');
  const applyBoxes = document.getElementById('applyBoxes');
  const validateBtn= document.getElementById('validateBtn');

  /* reflect current inputs */
  boxesInput.value = BOXES_PER_ROW;
  rowsInput.value  = NUM_ROWS;

  /* ===== Tile makers ===== */
  function makeTextTile(text, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile' + (isClone ? ' clone' : '');
    div.textContent = text;
    div.dataset.kind = 'text';
    div.dataset.text = text;

    if(isClone){
      const x = document.createElement('div');
      x.className = 'x'; x.textContent = '√ó'; x.title = 'Eliminar';
      x.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopImmediatePropagation(); });
      x.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopImmediatePropagation();
        const p = div.parentElement; div.remove();
        if(p?.classList?.contains('slot')) relayoutSlot(p);
      });
      div.appendChild(x);
    }
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeImageTile(url, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile img' + (isClone ? ' clone' : '');
    div.dataset.kind = 'img';
    div.dataset.src = url;

    const im = document.createElement('img');
    im.src = url; im.alt = 'img';
    div.appendChild(im);

    if(isClone){
      const x = document.createElement('div');
      x.className = 'x'; x.textContent = '√ó'; x.title = 'Eliminar';
      x.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopImmediatePropagation(); });
      x.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopImmediatePropagation();
        const p = div.parentElement; div.remove();
        if(p?.classList?.contains('slot')) relayoutSlot(p);
      });
      div.appendChild(x);
    }
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeSpaceTile(isClone=false){
    const div = document.createElement('div');
    div.className = 'tile space' + (isClone ? ' clone' : '');
    div.dataset.kind = 'space';
    div.dataset.text = ' ';
    if(isClone){
      const x = document.createElement('div');
      x.className = 'x'; x.textContent = '√ó'; x.title = 'Eliminar';
      x.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopImmediatePropagation(); });
      x.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopImmediatePropagation();
        const p = div.parentElement; div.remove();
        if(p?.classList?.contains('slot')) relayoutSlot(p);
      });
      div.appendChild(x);
    }
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  /* ===== Build board & palettes ===== */
  function buildRows(boxesPerRow, numRows, countOverride){
    // If a fixed count is provided, compute rows/boxes from it
    let rows = numRows, boxes = boxesPerRow;
    if (Number.isFinite(countOverride)) {
      rows = Math.max(1, Math.ceil(countOverride / boxesPerRow));
    }

    slotsEl.innerHTML = '';
    let index = 0;
    for (let r = 0; r < rows; r++){
      const line = document.createElement('div');
      line.className = 'line';
      const boxesThisRow = Number.isFinite(countOverride)
        ? Math.min(boxesPerRow, Math.max(0, countOverride - r*boxesPerRow))
        : boxesPerRow;

      for (let c = 0; c < boxesThisRow; c++){
        const s = document.createElement('div');
        s.className = 'slot';
        s.dataset.index = index++;
        line.appendChild(s);
      }
      slotsEl.appendChild(line);
    }
  }

  function fillPalettes(){
    // Space (its own small card)
    spaceTray.innerHTML = '';
    spaceCard.style.display = SPACE_ON ? '' : 'none';
    if (SPACE_ON) spaceTray.appendChild(makeSpaceTile(false));

    // Letters
    lettersTray.innerHTML = '';
    lettersCard.style.display = LETTERS.length ? '' : 'none';
    LETTERS.forEach(t => lettersTray.appendChild(makeTextTile(t, false)));

    // Syllables
    syllTray.innerHTML = '';
    syllCard.style.display = SYLL.length ? '' : 'none';
    SYLL.forEach(t => syllTray.appendChild(makeTextTile(t, false)));

    // Words
    wordsTray.innerHTML = '';
    wordsCard.style.display = WORDS.length ? '' : 'none';
    WORDS.forEach(w => wordsTray.appendChild(makeTextTile(w, false)));

    // Pictures (toggleable)
    picsTray.innerHTML = '';
    picsCard.style.display = IMAGES_ON ? '' : 'none';
    if (IMAGES_ON) {
      IMG_URLS.forEach(u => picsTray.appendChild(makeImageTile(u, false)));
    }
  }

  /* ===== Layout inside slots ===== */
  function relayoutSlot(slot){
    const tiles = [...slot.querySelectorAll('.tile')];
    tiles.forEach(t => t.classList.add('in-slot'));
  }
  function relayoutAllSlots(){
    document.querySelectorAll('.slot').forEach(relayoutSlot);
  }

  /* ===== Drag & Drop (with insert-between) ===== */
  let drag = null;

  function makeDraggable(el, opts){
    const cloneOnDrag = !!opts?.cloneOnDrag;
    el.style.touchAction = 'none';

    el.addEventListener('pointerdown', (e)=>{
      if(e.button!==0) return;
      if (e.target && e.target.closest && e.target.closest('.x')) return; // clicking ‚úï ‚Üí no drag

      const src = e.currentTarget;
      const isPalette = [spaceTray, lettersTray, syllTray, wordsTray, picsTray].includes(src.parentElement);
      let dragEl;
      if (cloneOnDrag && isPalette){
        if (src.dataset.kind === 'img') dragEl = makeImageTile(src.dataset.src, true);
        else if (src.dataset.kind === 'space') dragEl = makeSpaceTile(true);
        else dragEl = makeTextTile(src.dataset.text, true);
      } else {
        dragEl = src;
      }

      if(dragEl !== src && isPalette){
        document.body.appendChild(dragEl);
      }

      drag = {
        el: dragEl,
        pointerId: e.pointerId,
        fromPalette: isPalette,
        originParent: isPalette ? null : src.parentElement
      };
      drag.el.classList.add('dragging');
      Object.assign(drag.el.style, {
        position:'fixed', zIndex:1000, pointerEvents:'none',
        width: drag.el.offsetWidth + 'px',
        height: drag.el.offsetHeight + 'px'
      });
      moveTo(drag.el, e.clientX, e.clientY);

      document.addEventListener('pointermove', onMove, {passive:false});
      document.addEventListener('pointerup', onUp, {passive:false});
      document.addEventListener('pointercancel', onCancel, {passive:false});
    });
  }

  function moveTo(el,x,y){ el.style.left=(x-28)+'px'; el.style.top=(y-28)+'px'; }

  function onMove(e){
    if(!drag || e.pointerId!==drag.pointerId) return;
    moveTo(drag.el, e.clientX, e.clientY);

    document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
    const t = document.elementFromPoint(e.clientX, e.clientY);
    const slot = t?.closest?.('.slot');
    if(slot) slot.classList.add('highlight');

    trashEl.classList.toggle('highlight', !!t?.closest?.('#trash'));
  }

  // Insert el into slot at the position nearest to clientX
  function insertAtPointer(slot, el, clientX){
    const kids = [...slot.querySelectorAll('.tile')].filter(k => k !== el);
    if (kids.length === 0){
      slot.appendChild(el);
      return;
    }
    const before = kids.find(k => {
      const r = k.getBoundingClientRect();
      return (r.left + r.width/2) >= clientX;
    });
    if (before) slot.insertBefore(el, before);
    else slot.appendChild(el);
  }

  function onUp(e){
    if(!drag || e.pointerId!==drag.pointerId) return;

    const t = document.elementFromPoint(e.clientX, e.clientY);
    const onTrash = !!t?.closest?.('#trash');
    const slot = t?.closest?.('.slot');

    document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
    trashEl.classList.remove('highlight');

    drag.el.classList.remove('dragging');
    Object.assign(drag.el.style, {position:'', left:'', top:'', zIndex:'', pointerEvents:'', width:'', height:''});

    if(onTrash){
      const prev = drag.el.parentElement;
      drag.el.remove();
      if(prev?.classList.contains('slot')) relayoutSlot(prev);

    } else if(slot){
      const prev = drag.el.parentElement;
      if(prev?.classList?.contains('slot') && prev !== slot){
        try { prev.removeChild(drag.el); } catch {}
      }
      insertAtPointer(slot, drag.el, e.clientX);
      relayoutSlot(slot);
      if(prev && prev !== slot && prev.classList.contains('slot')) relayoutSlot(prev);

    } else {
      if(drag.fromPalette){
        drag.el.remove();
      } else if (drag.originParent){
        drag.originParent.appendChild(drag.el);
        if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
      }
    }
    cleanup();
  }

  function onCancel(){
    if(!drag) return;
    if(drag.fromPalette){
      drag.el.remove();
    } else if (drag.originParent){
      drag.originParent.appendChild(drag.el);
      if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
    }
    cleanup();
  }
  function cleanup(){
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', onUp);
    document.removeEventListener('pointercancel', onCancel);
    drag = null;
  }

  /* ===== Pics: drop/paste images into the Pictures tray ===== */
  ;['dragenter','dragover'].forEach(ev=>{
    picsTray.addEventListener(ev, e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
  });
  picsTray.addEventListener('drop', async e=>{
    e.preventDefault();
    const files = [...(e.dataTransfer?.files||[])].filter(f=>f.type.startsWith('image/'));
    for(const f of files){
      const url = URL.createObjectURL(f);
      picsTray.appendChild(makeImageTile(url, false));
    }
  });
  window.addEventListener('paste', e=>{
    const items = [...(e.clipboardData?.items||[])];
    items.forEach(it=>{
      if(it.type && it.type.startsWith('image/')){
        const file = it.getAsFile();
        if(file){
          const url = URL.createObjectURL(file);
          picsTray.appendChild(makeImageTile(url, false));
        }
      }
    });
  });

  /* ===== Validate ===== */
  validateBtn.addEventListener('click', ()=>{
    const result = [];
    document.querySelectorAll('.slot').forEach(slot=>{
      let s = '';
      [...slot.querySelectorAll('.tile')].forEach(t=>{
        const k = t.dataset.kind;
        if (k === 'text') s += t.dataset.text ?? '';
        else if (k === 'space') s += ' ';
        else if (k === 'img') s += (s.endsWith(' ') ? '' : ' ') + '[img]' + ' ';
      });
      result.push(s.trim());
    });
    alert('Cajas:\n' + result.map((w,i)=>`#${i+1}: ${w || '‚Äî'}`).join('\n'));
  });

  /* Aplicar: rebuild rows live */
  applyBoxes.addEventListener('click', ()=>{
    const boxesPer = clampInt(boxesInput.value, BOXES_PER_ROW, 1, 12);
    const rows = clampInt(rowsInput.value,  NUM_ROWS, 1, 50);
    buildRows(boxesPer, rows, null);
    relayoutAllSlots();
  });

  /* ===== Boot ===== */
  buildRows(BOXES_PER_ROW, NUM_ROWS, BOX_COUNT);
  fillPalettes();
  relayoutAllSlots();
</script>
</body>
</html>
