<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Construye palabras ‚Äî Letras, S√≠labas, Palabras & Im√°genes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

<style>
  *{box-sizing:border-box}
  :root{
    --bg:#fafbff; --grid:#eef1f7; --ink:#111; --muted:#6b7280; --brand:#2563eb;
    --tile:#fff; --tile-border:#111827; --drop:#ffffff; --drop-border:#111827;
    --trash:#fee2e2; --danger:#ef4444;
    --gap:12px;
    --inner-gap:10px;
    --tile-min-w:48px;
    --tile-h:48px;
    --tile-fs:28px;
    --tray-cols:10;
    --space-w:1.8ch;
  }
  html,body{height:100%}
  body{
    margin:0;
    font:18px/1.35 Andika, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--ink);
    background:
      linear-gradient(0deg, transparent calc(100% - 1px), var(--grid) 1px),
      linear-gradient(90deg, transparent calc(100% - 1px), var(--grid) 1px),
      var(--bg);
    background-size:40px 40px, 40px 40px, auto;
  }

  header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e7eb}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .row{display:flex;gap:12px;align-items:center}
  .spacer{flex:1}
  h1{font-size:20px;margin:0}

  .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{border:1px solid #d1d5db;background:var(--brand);color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.ghost{background:#fff;color:#111}
  input[type=number]{font:inherit;border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;min-width:70px}
  small.note{color:var(--muted)}

  main{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:1.2fr 1fr;gap:16px}
  @media (max-width:1000px){ main{grid-template-columns:1fr} }

  .board{
    background:var(--drop);
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:12px;
  }

  .slots{
    display:flex;
    flex-direction:column;
    gap:var(--gap);
    align-items:stretch;
    justify-content:flex-start;
  }
  .line{
    display:flex;
    gap:var(--gap);
    align-items:flex-start;
    justify-content:flex-start;
    flex-wrap:nowrap;
    width:100%;
  }

  .slot{
    background:#fff;
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:6px 8px;
    display:inline-flex;
    gap:0; /* no automatic gaps; only spaces create gaps */
    align-items:center;
    justify-content:flex-start;
    flex-wrap:nowrap;
    min-width:max(6ch, 80px);
    width:auto;
    position:relative;
    vertical-align:top;
  }
  .slot:empty::before{
    content:"";
    display:block;
    width:8ch;
    height:clamp(40px, 6vh, 64px);
  }

  .row-bottom{margin-top:12px}
  .note-wrap{display:flex;flex-direction:column;align-items:flex-start;gap:6px}
  .trash-row{
    display:flex;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
  }
  .trash{
    display:inline-flex;align-items:center;gap:8px;
    background:var(--trash);border:2px dashed var(--danger);color:#991b1b;
    padding:6px 10px;border-radius:12px;font-size:16px;user-select:none
  }

  .palettes{display:grid;grid-template-columns:1fr;gap:14px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px}
  .card h2{margin:0;font-size:18px}
  .card small{color:var(--muted)}
  .tray{
    display:grid;
    grid-template-columns:repeat(var(--tray-cols), max-content);
    gap:8px;
  }

  .card-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:6px;
    margin-bottom:8px;
  }
  .mini-tools{
    display:flex;
    gap:4px;
  }

  .tile{
    user-select:none; -webkit-user-drag:none; touch-action:none;
    display:inline-flex; align-items:center; justify-content:center;
    min-width:var(--tile-min-w); height:var(--tile-h); padding:0 12px;
    background:var(--tile); border:2px solid var(--tile-border); border-radius:12px;
    font-size:var(--tile-fs); line-height:1; cursor:grab; position:relative;
    transition:transform .05s ease;
  }
  .tile:active{cursor:grabbing; transform:scale(.98)}
  .dragging{opacity:.9; box-shadow:0 8px 24px rgba(0,0,0,.15)}
  .highlight{outline:3px solid #a5b4fc; outline-offset:2px}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#1e3a8a;font-size:12px;margin-left:8px}

  .slot .tile.in-slot{
    flex:0 0 auto; min-width:0;
    height:clamp(40px, 6vh, 64px);
    font-size:clamp(26px, 3.4vw, 56px);
    padding:0;
    background:transparent; border:none; border-radius:0; box-shadow:none;
  }

  .tile.img{ padding:4px 6px; min-width:auto; }
  .tile.img img{ display:block; max-height:var(--tile-h); height:auto; width:auto; max-width:160px; }
  .slot .tile.img.in-slot{ background:transparent; border:none; padding:0 4px; }
  .slot .tile.img.in-slot img{ max-height:clamp(40px, 6vh, 64px); border-radius:6px; }

  .tile.space{
    border-style:dashed;
    background:#f3f4f6;
    min-width:auto;
    padding:0 10px;
    font-size:16px;
  }
  .tile.space::after{ content:"‚ê£"; }
  .slot .tile.space.in-slot{
    width:var(--space-w);
    min-width:var(--space-w);
    padding:0;
    height:clamp(40px, 6vh, 64px);
    font-size:0;
    background:#e5e7eb;
    border:1px dashed #9ca3af;
    border-radius:999px;
    margin:0 var(--inner-gap);
  }

  .tile.punc{
    min-width:auto;
    padding:0 8px;
    font-size:24px;
  }
  .slot .tile.punc.in-slot{
    padding:0;
    margin:0;
  }

  .tile.captool,
  .tile.accenttool{
    min-width:auto;
    height:32px;
    padding:0 10px;
    font-size:18px;
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1>Construye palabras</h1>
      <span class="pill">Arrastra desde los paneles ‚Üí se clona</span>
      <div class="spacer"></div>
      <div class="toolbar">
        <label>Cajas:
          <input id="boxesInput" type="number" min="1" max="12" value="4"/>
        </label>
        <label>Filas:
          <input id="rowsInput" type="number" min="1" max="50" value="1"/>
        </label>
        <button id="applyBoxes" class="btn ghost">Aplicar</button>
        <button id="validateBtn" class="btn">Validar</button>
      </div>
    </div>
  </div>
</header>

<main>
  <section class="board">
    <div id="slots" class="slots"></div>
    <div class="row-bottom">
      <div class="note-wrap">
        <small class="note">Consejo: suelta sobre la papelera para borrar.</small>
        <div class="trash-row">
          <div id="trash" class="trash" aria-label="Papelera">üóëÔ∏è Papelera</div>
          <div id="trashSpace"></div>
        </div>
      </div>
    </div>
  </section>

  <aside class="palettes">
    <div class="card" id="lettersCard">
      <div class="card-header">
        <h2>Letras</h2>
        <div class="mini-tools" id="lettersTools"></div>
      </div>
      <div id="lettersTray" class="tray"></div>
    </div>

    <div class="card" id="syllCard">
      <div class="card-header">
        <h2>S√≠labas</h2>
        <div class="mini-tools" id="syllTools"></div>
      </div>
      <div id="syllTray" class="tray"></div>
    </div>

    <div class="card" id="wordsCard">
      <div class="card-header">
        <h2>Palabras</h2>
        <div class="mini-tools" id="wordsTools"></div>
      </div>
      <div id="wordsTray" class="tray"></div>
    </div>

    <div class="card" id="puncCard">
      <h2>Puntuaci√≥n</h2>
      <div id="puncTray" class="tray"></div>
    </div>

    <div class="card" id="picsCard">
      <h2>Im√°genes</h2>
      <small>Arrastra im√°genes (o p√©galos) aqu√≠. Tambi√©n puedes precargar con <code>?imgs=URL1,URL2</code>.</small>
      <div id="picsTray" class="tray"></div>
    </div>
  </aside>
</main>

<script>
  const qs = new URLSearchParams(location.search);

  function clampInt(val, fallback, min, max){
    const n = parseInt(val, 10);
    if (Number.isFinite(n)) return Math.max(min, Math.min(max, n));
    return fallback;
  }
  function getList(keys, defaults){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaults;
    const raw = (qs.get(key) ?? '').trim();
    const lo = raw.toLowerCase();
    if (raw === '' || lo === 'off' || lo === 'false' || lo === '0' || lo === 'none') return [];
    return raw.split(',').map(s => s.trim()).filter(Boolean);
  }
  function getToggle(keys, defaultOn=true){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaultOn;
    const lo = (qs.get(key) ?? '').trim().toLowerCase();
    return !['0','off','false','none','no'].includes(lo);
  }

  const BOXES_PER_ROW = clampInt(qs.get('boxCols') ?? qs.get('boxes') ?? qs.get('columns'), 4, 1, 12);
  const NUM_ROWS      = clampInt(qs.get('boxRows') ?? qs.get('rows') ?? qs.get('r'), 1, 1, 50);
  const BOX_COUNT     = clampInt(qs.get('boxCount') ?? qs.get('count'), null, 1, 500);

  const perRow = clampInt(qs.get('perRow') ?? qs.get('perrow') ?? qs.get('cols') ?? qs.get('trayCols'), null, 1, 24);
  if (perRow) document.documentElement.style.setProperty('--tray-cols', String(perRow));

  /* ===== Feature toggles (URL) =====
     ?space=off   -> removes space tile next to papelera
     ?caps=off    -> hides ‚Üë ‚Üì tools and disables them
     ?accent=off  -> hides ¬¥ tool and disables it
     ?punc=off    -> hides punctuation palette

     ===== Prefill (URL) =====
     Fill EVERY box with the same text:
       ?prefill=ma        (aliases: ?fill=ma)

     Fill by ROWS (row 1, row 2, row 3...):
       ?prefillRows=ma,me,mi,mo
       (aliases: ?fillRows=ma,me,mi,mo)

     Put MULTIPLE tiles in each box (use +):
       ?prefill=la+ma
       ?prefillRows=bra+vo,va+mos
     Tip: Use %2B for + if your platform mangles plus signs.
  */
  const SPACE_ON   = getToggle('space', true);
  const CAPS_ON    = getToggle(['caps','case','upper'], true);
  const ACCENT_ON  = getToggle(['accent','acento'], true);
  const PUNC_ON    = getToggle(['punc','punct','punctuation'], true);

  const IMAGES_ON = getToggle(['images','imgs','pics','pictures'], true);

  const spaceW = parseFloat(qs.get('spacew'));
  if (!isNaN(spaceW) && spaceW > 0 && spaceW < 5) {
    document.documentElement.style.setProperty('--space-w', `${spaceW}ch`);
  }

  // Prefill params
  const PREFILL = (qs.get('prefill') ?? qs.get('fill') ?? '').trim();
  const PREFILL_ROWS = getList(['prefillRows','fillRows','rowFill'], []);

  const DEFAULT_LETTERS = [
    '√≥','o','m','t','n','g','qu',
    '√°','a','p','d','f','ch','z',
    '√≠','i','s','r','b','√±','h',
    '√∫','u','l','c','j','v','y',
    '√©','e','ll','k','w','x'
  ];
  const DEFAULT_SYLL  = ['ma','me','mi','mo','mu','la','le','li','lo','lu','pa','pe','pi','po','pu','sa','se','si','so','su','bra','bre','bri','bro','bru','cha','che','chi','cho','chu','que','qui'];
  const DEFAULT_WORDS = ['yo','t√∫','mi','la','el','un','una','me','te','va','no','s√≠'];
  const DEFAULT_PUNC  = ['¬ø','?','¬°','!',',','.'];

  const LETTERS  = getList('letters', DEFAULT_LETTERS);
  const SYLL     = getList(['syll','syllables'], DEFAULT_SYLL);
  const WORDS    = getList(['words','word'], DEFAULT_WORDS);
  const PUNC     = getList(['punc','punct','punctuation'], DEFAULT_PUNC);
  const IMG_URLS = getList(['imgs','images','pics','pictures'], []);

  const slotsEl       = document.getElementById('slots');
  const trashEl       = document.getElementById('trash');
  const trashSpaceEl  = document.getElementById('trashSpace');

  const lettersTray = document.getElementById('lettersTray');
  const syllTray    = document.getElementById('syllTray');
  const wordsTray   = document.getElementById('wordsTray');
  const puncTray    = document.getElementById('puncTray');
  const picsTray    = document.getElementById('picsTray');

  const lettersCard = document.getElementById('lettersCard');
  const syllCard    = document.getElementById('syllCard');
  const wordsCard   = document.getElementById('wordsCard');
  const puncCard    = document.getElementById('puncCard');
  const picsCard    = document.getElementById('picsCard');

  const lettersTools = document.getElementById('lettersTools');
  const syllTools    = document.getElementById('syllTools');
  const wordsTools   = document.getElementById('wordsTools');

  const boxesInput = document.getElementById('boxesInput');
  const rowsInput  = document.getElementById('rowsInput');
  const applyBoxes = document.getElementById('applyBoxes');
  const validateBtn= document.getElementById('validateBtn');

  boxesInput.value = BOXES_PER_ROW;
  rowsInput.value  = NUM_ROWS;

  function applyCapToTile(tile, mode){
    if (!tile || tile.dataset.kind !== 'text') return;
    const cur = tile.dataset.text ?? tile.textContent ?? '';
    if (!cur) return;
    const first = cur[0];
    const rest  = cur.slice(1);
    const out = (mode === 'up' ? first.toUpperCase() : first.toLowerCase()) + rest;
    tile.dataset.text = out;
    tile.textContent  = out;
  }

  const plainToAcc = { a:'√°', e:'√©', i:'√≠', o:'√≥', u:'√∫',
                       A:'√Å', E:'√â', I:'√ç', O:'√ì', U:'√ö' };
  const accToPlain = { √°:'a', √©:'e', √≠:'i', √≥:'o', √∫:'u',
                       √Å:'A', √â:'√â', √ç:'√ç', √ì:'√ì', √ö:'√ö' };

  function applyAccentAtPointer(tile, clientX){
    if (!tile || tile.dataset.kind !== 'text') return;

    const cur = tile.dataset.text ?? tile.textContent ?? '';
    const chars = [...cur];
    const len = chars.length;
    if (!len) return;

    const rect = tile.getBoundingClientRect();
    const safeWidth = rect.width || 1;

    let relX = clientX - rect.left;
    if (relX < 0) relX = 0;
    if (relX > safeWidth) relX = safeWidth;

    let approx = Math.floor((relX / safeWidth) * len);
    if (approx < 0) approx = 0;
    if (approx >= len) approx = len - 1;

    const isAccentable = (ch) => !!plainToAcc[ch] || !!accToPlain[ch];

    let idx = approx;
    if (!isAccentable(chars[idx])) {
      let best = -1;
      let bestDist = Infinity;
      for (let i = 0; i < len; i++){
        if (!isAccentable(chars[i])) continue;
        const d = Math.abs(i - approx);
        if (d < bestDist){
          bestDist = d;
          best = i;
        }
      }
      if (best === -1) return;
      idx = best;
    }

    const c = chars[idx];
    if (plainToAcc[c]) chars[idx] = plainToAcc[c];
    else if (accToPlain[c]) {
      // NOTE: if you ever want toggle-off accents reliably for all vowels,
      // keep accToPlain mapping consistent (√°->a, etc). Right now we only need on/toggle.
      const map = { '√°':'a','√©':'e','√≠':'i','√≥':'o','√∫':'u','√Å':'A','√â':'E','√ç':'I','√ì':'O','√ö':'U' };
      chars[idx] = map[c] ?? c;
    } else return;

    const out = chars.join('');
    tile.dataset.text = out;
    tile.textContent  = out;
  }

  function makeTextTile(text, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile' + (isClone ? ' clone' : '');
    div.dataset.kind = 'text';
    div.dataset.text = text;
    div.textContent  = text;
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makePuncTile(ch, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile punc' + (isClone ? ' clone' : '');
    div.dataset.kind = 'punc';
    div.dataset.text = ch;
    div.textContent  = ch;
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeImageTile(url, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile img' + (isClone ? ' clone' : '');
    div.dataset.kind = 'img';
    div.dataset.src = url;
    const im = document.createElement('img');
    im.src = url;
    im.alt = 'img';
    div.appendChild(im);
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeSpaceTile(isClone=false){
    const div = document.createElement('div');
    div.className = 'tile space' + (isClone ? ' clone' : '');
    div.dataset.kind = 'space';
    div.dataset.text = ' ';
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeCapTool(mode){
    const div = document.createElement('div');
    div.className = 'tile captool';
    div.dataset.kind = 'captool';
    div.dataset.mode = mode;
    div.textContent  = mode === 'up' ? '‚Üë' : '‚Üì';
    makeDraggable(div, { cloneOnDrag:true });
    return div;
  }

  function makeAccentTool(){
    const div = document.createElement('div');
    div.className = 'tile accenttool';
    div.dataset.kind = 'accenttool';
    div.textContent  = '¬¥';
    makeDraggable(div, { cloneOnDrag:true });
    return div;
  }

  function buildRows(boxesPerRow, numRows, countOverride){
    let rows = numRows;
    if (Number.isFinite(countOverride)) {
      rows = Math.max(1, Math.ceil(countOverride / boxesPerRow));
    }
    slotsEl.innerHTML = '';
    let index = 0;
    for (let r = 0; r < rows; r++){
      const line = document.createElement('div');
      line.className = 'line';
      const boxesThisRow = Number.isFinite(countOverride)
        ? Math.min(boxesPerRow, Math.max(0, countOverride - r*boxesPerRow))
        : boxesPerRow;
      for (let c = 0; c < boxesThisRow; c++){
        const s = document.createElement('div');
        s.className = 'slot';
        s.dataset.index = index++;
        line.appendChild(s);
      }
      slotsEl.appendChild(line);
    }
  }

  // NEW: prefill boxes (global or by rows)
  function prefillBoxes(){
    const lines = [...slotsEl.querySelectorAll('.line')];
    if (!PREFILL && (!PREFILL_ROWS || PREFILL_ROWS.length === 0)) return;

    const splitParts = (val) => {
      const v = (val ?? '').trim();
      if (!v) return [];
      // Allow + to mean multiple tiles
      return v.split('+').map(s => decodeURIComponent(s.trim())).filter(Boolean);
    };

    lines.forEach((line, rowIdx) => {
      const rowVal = (PREFILL_ROWS[rowIdx] ?? '').trim();
      const parts = splitParts(rowVal || PREFILL);
      if (!parts.length) return;

      const slots = [...line.querySelectorAll('.slot')];
      slots.forEach(slot => {
        // Don‚Äôt overwrite if already has something (in case you later add manual prefill)
        if (slot.querySelector('.tile')) return;

        parts.forEach(p => {
          // Prefill uses "clone" tiles so they MOVE (not clone again when dragged)
          slot.appendChild(makeTextTile(p, true));
        });
      });
    });
  }

  function fillPalettes(){
    lettersTray.innerHTML = '';
    lettersCard.style.display = LETTERS.length ? '' : 'none';
    LETTERS.forEach(t => lettersTray.appendChild(makeTextTile(t, false)));

    syllTray.innerHTML = '';
    syllCard.style.display = SYLL.length ? '' : 'none';
    SYLL.forEach(t => syllTray.appendChild(makeTextTile(t, false)));

    wordsTray.innerHTML = '';
    wordsCard.style.display = WORDS.length ? '' : 'none';
    WORDS.forEach(w => wordsTray.appendChild(makeTextTile(w, false)));

    puncTray.innerHTML = '';
    puncCard.style.display = (PUNC_ON && PUNC.length) ? '' : 'none';
    if (PUNC_ON) {
      PUNC.forEach(ch => puncTray.appendChild(makePuncTile(ch, false)));
    }

    picsTray.innerHTML = '';
    picsCard.style.display = IMAGES_ON ? '' : 'none';
    if (IMAGES_ON) IMG_URLS.forEach(u => picsTray.appendChild(makeImageTile(u, false)));

    // Space tile next to Papelera (toggleable)
    trashSpaceEl.innerHTML = '';
    if (SPACE_ON) {
      trashSpaceEl.appendChild(makeSpaceTile(false));
    }

    function attachTools(container){
      container.innerHTML = '';
      if (CAPS_ON) {
        container.appendChild(makeCapTool('up'));
        container.appendChild(makeCapTool('down'));
      }
      if (ACCENT_ON) {
        container.appendChild(makeAccentTool());
      }
    }
    attachTools(lettersTools);
    attachTools(syllTools);
    attachTools(wordsTools);
  }

  function relayoutSlot(slot){
    const tiles = [...slot.querySelectorAll('.tile')];
    tiles.forEach(t => t.classList.add('in-slot'));
  }
  function relayoutAllSlots(){
    document.querySelectorAll('.slot').forEach(relayoutSlot);
  }

  let drag = null;

  function makeDraggable(el, opts){
    const cloneOnDrag = !!opts?.cloneOnDrag;
    el.style.touchAction = 'none';

    el.addEventListener('pointerdown', (e)=>{
      if(e.button!==0) return;

      const src = e.currentTarget;
      const parent = src.parentElement;
      const isPalette = [
        lettersTray, syllTray, wordsTray, puncTray, picsTray,
        trashSpaceEl, lettersTools, syllTools, wordsTools
      ].includes(parent);

      let dragEl;
      if (cloneOnDrag && isPalette){
        const k = src.dataset.kind;
        if (k === 'img') dragEl = makeImageTile(src.dataset.src, true);
        else if (k === 'space') dragEl = makeSpaceTile(true);
        else if (k === 'punc') dragEl = makePuncTile(src.dataset.text, true);
        else if (k === 'captool') dragEl = makeCapTool(src.dataset.mode);
        else if (k === 'accenttool') dragEl = makeAccentTool();
        else dragEl = makeTextTile(src.dataset.text, true);
      } else {
        dragEl = src;
      }

      if (dragEl !== src && isPalette){
        document.body.appendChild(dragEl);
      }

      drag = {
        el: dragEl,
        pointerId: e.pointerId,
        fromPalette: isPalette,
        originParent: isPalette ? null : src.parentElement
      };
      drag.el.classList.add('dragging');
      Object.assign(drag.el.style, {
        position:'fixed', zIndex:1000, pointerEvents:'none',
        width: dragEl.offsetWidth + 'px',
        height: dragEl.offsetHeight + 'px'
      });
      moveTo(drag.el, e.clientX, e.clientY);

      document.addEventListener('pointermove', onMove, {passive:false});
      document.addEventListener('pointerup', onUp, {passive:false});
      document.addEventListener('pointercancel', onCancel, {passive:false});
    });
  }

  function moveTo(el,x,y){ el.style.left=(x-28)+'px'; el.style.top=(y-28)+'px'; }

  function onMove(e){
    if(!drag || e.pointerId!==drag.pointerId) return;
    moveTo(drag.el, e.clientX, e.clientY);

    document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
    const t = document.elementFromPoint(e.clientX, e.clientY);
    const slot = t?.closest?.('.slot');
    const kind = drag.el.dataset.kind;
    if (slot && kind !== 'captool' && kind !== 'accenttool') slot.classList.add('highlight');

    trashEl.classList.toggle(
      'highlight',
      kind !== 'captool' && kind !== 'accenttool' && !!t?.closest?.('#trash')
    );
  }

  function insertAtPointer(slot, el, clientX){
    const kids = [...slot.querySelectorAll('.tile')].filter(k => k !== el);
    if (kids.length === 0){
      slot.appendChild(el);
      return;
    }
    const before = kids.find(k => {
      const r = k.getBoundingClientRect();
      return (r.left + r.width/2) >= clientX;
    });
    if (before) slot.insertBefore(el, before);
    else slot.appendChild(el);
  }

  function cleanupHighlights(){
    document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
    trashEl.classList.remove('highlight');
  }

  function onUp(e){
    if(!drag || e.pointerId!==drag.pointerId) return;
    const t = document.elementFromPoint(e.clientX, e.clientY);
    const kind = drag.el.dataset.kind;

    if (kind === 'captool'){
      if (!CAPS_ON) { drag.el.remove(); cleanupHighlights(); cleanup(); return; }
      const tile = t?.closest?.('.tile[data-kind="text"]');
      if (tile) applyCapToTile(tile, drag.el.dataset.mode === 'down' ? 'down' : 'up');
      drag.el.remove();
      cleanupHighlights();
      cleanup();
      return;
    }

    if (kind === 'accenttool'){
      if (!ACCENT_ON) { drag.el.remove(); cleanupHighlights(); cleanup(); return; }
      const tile = t?.closest?.('.tile[data-kind="text"]');
      if (tile) {
        const accRect = drag.el.getBoundingClientRect();
        const centerX = accRect.left + accRect.width / 2;
        applyAccentAtPointer(tile, centerX);
      }
      drag.el.remove();
      cleanupHighlights();
      cleanup();
      return;
    }

    const onTrash = !!t?.closest?.('#trash');
    const slot = t?.closest?.('.slot');

    cleanupHighlights();

    drag.el.classList.remove('dragging');
    Object.assign(drag.el.style, {position:'', left:'', top:'', zIndex:'', pointerEvents:'', width:'', height:''});

    if(onTrash){
      const prev = drag.el.parentElement;
      drag.el.remove();
      if(prev?.classList.contains('slot')) relayoutSlot(prev);

    } else if(slot){
      const prev = drag.el.parentElement;
      if(prev?.classList?.contains('slot') && prev !== slot){
        try { prev.removeChild(drag.el); } catch {}
      }
      insertAtPointer(slot, drag.el, e.clientX);
      relayoutSlot(slot);
      if(prev && prev !== slot && prev.classList.contains('slot')) relayoutSlot(prev);

    } else {
      if(drag.fromPalette){
        drag.el.remove();
      } else if (drag.originParent){
        drag.originParent.appendChild(drag.el);
        if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
      }
    }
    cleanup();
  }

  function onCancel(){
    if(!drag) return;
    if(drag.fromPalette ||
       drag.el.dataset.kind === 'captool' ||
       drag.el.dataset.kind === 'accenttool'){
      drag.el.remove();
    } else if (drag.originParent){
      drag.originParent.appendChild(drag.el);
      if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
    }
    cleanup();
  }
  function cleanup(){
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', onUp);
    document.removeEventListener('pointercancel', onCancel);
    drag = null;
  }

  ['dragenter','dragover'].forEach(ev=>{
    picsTray.addEventListener(ev, e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
  });
  picsTray.addEventListener('drop', async e=>{
    e.preventDefault();
    const files = [...(e.dataTransfer?.files||[])].filter(f=>f.type.startsWith('image/'));
    for(const f of files){
      const url = URL.createObjectURL(f);
      picsTray.appendChild(makeImageTile(url, false));
    }
  });
  window.addEventListener('paste', e=>{
    const items = [...(e.clipboardData?.items||[])];
    items.forEach(it=>{
      if(it.type && it.type.startsWith('image/')){
        const file = it.getAsFile();
        if(file){
          const url = URL.createObjectURL(file);
          picsTray.appendChild(makeImageTile(url, false));
        }
      }
    });
  });

  validateBtn.addEventListener('click', ()=>{
    const result = [];
    document.querySelectorAll('.slot').forEach(slot=>{
      let s = '';
      [...slot.querySelectorAll('.tile')].forEach(t=>{
        const k = t.dataset.kind;
        if (k === 'text') {
          s += t.dataset.text ?? t.textContent ?? '';
        } else if (k === 'space') {
          s += ' ';
        } else if (k === 'img') {
          s += (s.endsWith(' ') ? '' : ' ') + '[img]' + ' ';
        } else if (k === 'punc') {
          const ch = t.dataset.text || t.textContent || '';
          if (',.?!'.includes(ch)) {
            s = s.replace(/\s+$/,'');
            s += ch;
          } else if ('¬ø¬°'.includes(ch)) {
            s += ch;
          } else {
            s += ch;
          }
        }
      });
      result.push(s.trim());
    });
    alert('Cajas:\n' + result.map((w,i)=>`#${i+1}: ${w || '‚Äî'}`).join('\n'));
  });

  applyBoxes.addEventListener('click', ()=>{
    const boxesPer = clampInt(boxesInput.value, BOXES_PER_ROW, 1, 12);
    const rows     = clampInt(rowsInput.value,  NUM_ROWS,      1, 50);
    buildRows(boxesPer, rows, null);
    prefillBoxes();       // NEW: apply prefill after rebuilding
    relayoutAllSlots();
  });

  buildRows(BOXES_PER_ROW, NUM_ROWS, BOX_COUNT);
  fillPalettes();
  prefillBoxes();         // NEW: initial prefill
  relayoutAllSlots();
</script>
</body>
</html>
