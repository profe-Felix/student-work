<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Construye palabras ‚Äî Letras, S√≠labas, Palabras & Im√°genes</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">

<style>
  *{box-sizing:border-box}
  :root{
    --bg:#fafbff; --grid:#eef1f7; --ink:#111; --muted:#6b7280; --brand:#2563eb;
    --tile:#fff; --tile-border:#111827; --drop:#ffffff; --drop-border:#111827;
    --trash:#fee2e2; --danger:#ef4444;
    --gap:12px;              /* gap between word boxes / rows */
    --inner-gap:10px;        /* logical gap for space pill */
    --tile-min-w:48px;       /* palette text tile base size */
    --tile-h:48px;
    --tile-fs:28px;
    --tray-cols: 10;         /* items per row in right palettes (URL-overridable) */
    --space-w: 1.8ch;        /* width of space when dropped */
  }
  html,body{height:100%}
  body{
    margin:0; font:18px/1.35 Andika, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--ink); background:
      linear-gradient(0deg, transparent calc(100% - 1px), var(--grid) 1px),
      linear-gradient(90deg, transparent calc(100% - 1px), var(--grid) 1px),
      var(--bg);
    background-size:40px 40px, 40px 40px, auto;
  }

  header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e7eb}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .row{display:flex;gap:12px;align-items:center}
  .spacer{flex:1}
  h1{font-size:20px;margin:0}

  .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{border:1px solid #d1d5db;background:var(--brand);color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.ghost{background:#fff;color:#111}
  input[type=number]{font:inherit;border:1px solid #d1d5db;border-radius:10px;padding:6px 10px;min-width:70px}
  small.note{color:var(--muted)}

  main{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:1.2fr 1fr;gap:16px}
  @media (max-width:1000px){ main{grid-template-columns:1fr} }

  /* Board */
  .board{
    background:var(--drop);
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:12px;
  }

  /* Rows-based board (no CSS grid) */
  .slots{
    display:flex;
    flex-direction:column;
    gap:var(--gap);
    align-items:stretch;
    justify-content:flex-start;
  }
  .line{
    display:flex;
    gap:var(--gap);
    align-items:flex-start;
    justify-content:flex-start;
    flex-wrap:nowrap;
    width:100%;
  }

  .slot{
    background:#fff;
    border:2px solid var(--drop-border);
    border-radius:12px;
    padding:6px 8px;
    display:inline-flex;
    gap:0;                      /* no auto gap between tiles */
    align-items:center;
    justify-content:flex-start;
    flex-wrap:nowrap;
    min-width:max(6ch, 80px);
    width:auto;
    position:relative;
    vertical-align:top;
  }
  .slot:empty::before{
    content:"";
    display:block;
    width:8ch;
    height:clamp(40px, 6vh, 64px);
  }

  /* Bottom: note + trash + tools */
  .row-bottom{margin-top:12px}
  .note-wrap{display:flex;flex-direction:column;align-items:flex-start;gap:6px}
  .trash{
    display:inline-flex;align-items:center;gap:8px;
    background:var(--trash);border:2px dashed var(--danger);color:#991b1b;
    padding:6px 10px;border-radius:12px;font-size:16px;user-select:none
  }
  .trash-tools{
    display:flex;
    align-items:center;
    gap:6px;
    flex-wrap:wrap;
    margin-top:4px;
  }
  #capTools{
    display:flex;
    gap:6px;
  }
  .tile.captool,
  .tile.accenttool{
    min-width:auto;
    height:32px;
    padding:0 10px;
    font-size:18px;
  }

  /* Right palettes */
  .palettes{display:grid;grid-template-columns:1fr;gap:14px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px}
  .card h2{font-size:18px;margin:0}
  .card small{color:var(--muted)}
  .tray{
    display:grid;
    grid-template-columns: repeat(var(--tray-cols), max-content);
    gap:8px;
  }
  .card-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:6px;
    margin-bottom:8px;
  }
  .mini-tools{
    display:flex;
    gap:4px;
  }

  /* Text tiles */
  .tile{
    user-select:none; -webkit-user-drag:none; touch-action:none;
    display:inline-flex; align-items:center; justify-content:center;
    min-width:var(--tile-min-w); height:var(--tile-h); padding:0 12px;
    background:var(--tile); border:2px solid var(--tile-border); border-radius:12px;
    font-size:var(--tile-fs); line-height:1; cursor:grab; position:relative;
    transition:transform .05s ease;
  }
  .tile .label{
    pointer-events:none;
  }
  .char-span{
    /* inline spans for each character */
  }
  .tile:active{cursor:grabbing; transform:scale(.98)}

  .dragging{opacity:.9; box-shadow:0 8px 24px rgba(0,0,0,.15)}
  .highlight{outline:3px solid #a5b4fc; outline-offset:2px}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#1e3a8a;font-size:12px;margin-left:8px}

  /* In-slot compact look (true text run) */
  .slot .tile.in-slot{
    flex:0 0 auto; min-width:0;
    height:clamp(40px, 6vh, 64px);
    font-size:clamp(26px, 3.4vw, 56px);
    padding:0;
    background:transparent; border:none; border-radius:0; box-shadow:none;
  }

  /* Image tiles */
  .tile.img{ padding:4px 6px; min-width:auto; }
  .tile.img img{ display:block; max-height:var(--tile-h); height:auto; width:auto; max-width:160px; }
  .slot .tile.img.in-slot{ background:transparent; border:none; padding:0 4px; }
  .slot .tile.img.in-slot img{ max-height:clamp(40px, 6vh, 64px); border-radius:6px; }

  /* Space tile */
  .tile.space{
    border-style:dashed;
    background:#f3f4f6;
    min-width:auto;
    padding:0 10px;
    font-size:16px;
  }
  .tile.space::after{ content:"‚ê£"; }
  .slot .tile.space.in-slot{
    width:var(--space-w);
    min-width:var(--space-w);
    padding:0;
    height:clamp(40px, 6vh, 64px);
    font-size:0;                /* hide ‚ê£ glyph but keep pill */
    background:#e5e7eb;
    border:1px dashed #9ca3af;
    border-radius:999px;
    margin:0 var(--inner-gap);  /* visible gap only when space is present */
  }

  /* Punctuation tiles */
  .tile.punc{
    min-width:auto;
    padding:0 8px;
    font-size:24px;
  }
  .slot .tile.punc.in-slot{
    padding:0;
    margin:0;
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <h1>Construye palabras</h1>
      <span class="pill">Arrastra desde los paneles ‚Üí se clona</span>
      <div class="spacer"></div>
      <div class="toolbar">
        <label>Cajas:
          <input id="boxesInput" type="number" min="1" max="12" value="4"/>
        </label>
        <label>Filas:
          <input id="rowsInput" type="number" min="1" max="50" value="1"/>
        </label>
        <button id="applyBoxes" class="btn ghost">Aplicar</button>
        <button id="validateBtn" class="btn">Validar</button>
      </div>
    </div>
  </div>
</header>

<main>
  <!-- LEFT: Word building board -->
  <section class="board">
    <div id="slots" class="slots"></div>
    <div class="row-bottom">
      <div class="note-wrap">
        <small class="note">Consejo: suelta sobre la papelera para borrar.</small>
        <div class="trash-tools">
          <div id="trash" class="trash" aria-label="Papelera">üóëÔ∏è Papelera</div>
          <div id="capTools"></div> <!-- only space lives here now -->
        </div>
      </div>
    </div>
  </section>

  <!-- RIGHT: Palettes -->
  <aside class="palettes">
    <div class="card" id="spaceCard">
      <h2>Espacio</h2>
      <div id="spaceTray" class="tray"></div>
    </div>

    <div class="card" id="lettersCard">
      <div class="card-header">
        <h2>Letras</h2>
        <div class="mini-tools" id="lettersCapTools"></div>
      </div>
      <div id="lettersTray" class="tray"></div>
    </div>

    <div class="card" id="syllCard">
      <div class="card-header">
        <h2>S√≠labas</h2>
        <div class="mini-tools" id="syllCapTools"></div>
      </div>
      <div id="syllTray" class="tray"></div>
    </div>

    <div class="card" id="wordsCard">
      <div class="card-header">
        <h2>Palabras</h2>
        <div class="mini-tools" id="wordsCapTools"></div>
      </div>
      <div id="wordsTray" class="tray"></div>
    </div>

    <div class="card" id="puncCard">
      <h2>Puntuaci√≥n</h2>
      <div id="puncTray" class="tray"></div>
    </div>

    <div class="card" id="picsCard">
      <h2>Im√°genes</h2>
      <small>Arrastra im√°genes (o p√©galos) aqu√≠. Tambi√©n puedes precargar con <code>?imgs=URL1,URL2</code>.</small>
      <div id="picsTray" class="tray"></div>
    </div>
  </aside>
</main>

<script>
  /* ===== URL options ===== */
  const qs = new URLSearchParams(location.search);

  /* Helpers */
  function clampInt(val, fallback, min, max){
    const n = parseInt(val, 10);
    if (Number.isFinite(n)) return Math.max(min, Math.min(max, n));
    return fallback;
  }
  function getList(keys, defaults){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaults;
    const raw = (qs.get(key) ?? '').trim();
    const lo = raw.toLowerCase();
    if (raw === '' || lo === 'off' || lo === 'false' || lo === '0' || lo === 'none') return [];
    return raw.split(',').map(s => s.trim()).filter(Boolean);
  }
  function getToggle(keys, defaultOn=true){
    const key = (Array.isArray(keys) ? keys.find(k => qs.has(k)) : keys) ?? null;
    if (!key) return defaultOn;
    const lo = (qs.get(key) ?? '').trim().toLowerCase();
    return !['0','off','false','none','no'].includes(lo);
  }

  const BOXES = clampInt(qs.get('boxes') ?? qs.get('drops'), 4, 1, 12);

  const BOXES_PER_ROW = clampInt(
    qs.get('boxCols') ?? qs.get('boxes') ?? qs.get('columns'),
    4, 1, 12
  );
  const NUM_ROWS = clampInt(
    qs.get('boxRows') ?? qs.get('rows') ?? qs.get('r'),
    1, 1, 50
  );

  const BOX_COUNT = clampInt(qs.get('boxCount') ?? qs.get('count'), null, 1, 500);

  const perRow = clampInt(qs.get('perRow') ?? qs.get('perrow') ?? qs.get('cols') ?? qs.get('trayCols'), null, 1, 24);
  if (perRow) document.documentElement.style.setProperty('--tray-cols', String(perRow));

  const SPACE_ON = getToggle('space', true);
  const IMAGES_ON = getToggle(['images','imgs','pics','pictures'], true);

  const spaceW = parseFloat(qs.get('spacew'));
  if (!isNaN(spaceW) && spaceW > 0 && spaceW < 5) {
    document.documentElement.style.setProperty('--space-w', `${spaceW}ch`);
  }

  /* ===== Data ===== */
  const DEFAULT_LETTERS = [
    '√≥','o','m','t','n','g','qu',
    '√°','a','p','d','f','ch','z',
    '√≠','i','s','r','b','√±','h',
    '√∫','u','l','c','j','v','y',
    '√©','e','ll','k','w','x'
  ];
  const DEFAULT_SYLL = ['ma','me','mi','mo','mu','la','le','li','lo','lu','pa','pe','pi','po','pu','sa','se','si','so','su','bra','bre','bri','bro','bru','cha','che','chi','cho','chu','que','qui'];
  const DEFAULT_WORDS = ['yo','t√∫','mi','la','el','un','una','me','te','va','no','s√≠'];
  const DEFAULT_PUNC = ['¬ø','?','¬°','!',',','.'];

  const LETTERS = getList('letters', DEFAULT_LETTERS);
  const SYLL = getList(['syll','syllables'], DEFAULT_SYLL);
  const WORDS = getList(['words','word'], DEFAULT_WORDS);
  const PUNC = getList(['punc','punct','punctuation'], DEFAULT_PUNC);
  const IMG_URLS = getList(['imgs','images','pics','pictures'], []);

  /* DOM refs */
  const slotsEl = document.getElementById('slots');
  const trashEl = document.getElementById('trash');

  const spaceCard = document.getElementById('spaceCard');
  const spaceTray = document.getElementById('spaceTray');

  const lettersTray = document.getElementById('lettersTray');
  const syllTray = document.getElementById('syllTray');
  const wordsTray = document.getElementById('wordsTray');
  const puncTray = document.getElementById('puncTray');
  const picsTray = document.getElementById('picsTray');

  const lettersCard = document.getElementById('lettersCard');
  const syllCard   = document.getElementById('syllCard');
  const wordsCard  = document.getElementById('wordsCard');
  const puncCard   = document.getElementById('puncCard');
  const picsCard   = document.getElementById('picsCard');

  const boxesInput = document.getElementById('boxesInput');
  const rowsInput  = document.getElementById('rowsInput');
  const applyBoxes = document.getElementById('applyBoxes');
  const validateBtn= document.getElementById('validateBtn');

  const capTools = document.getElementById('capTools'); // bottom strip (space only)

  const lettersCapTools = document.getElementById('lettersCapTools');
  const syllCapTools    = document.getElementById('syllCapTools');
  const wordsCapTools   = document.getElementById('wordsCapTools');

  boxesInput.value = BOXES_PER_ROW;
  rowsInput.value  = NUM_ROWS;

  /* ===== Text rendering (per-letter spans) ===== */
  function renderTextLabel(tile){
    const label = tile.querySelector('.label');
    if (!label) return;
    const text = tile.dataset.text ?? '';
    label.innerHTML = '';
    for (const ch of [...text]){
      const span = document.createElement('span');
      span.className = 'char-span';
      span.textContent = ch;
      label.appendChild(span);
    }
  }

  /* Capitalization via tools (uses current text, keeps accents) */
  function applyCapToTile(tile, mode){
    if (!tile || tile.dataset.kind !== 'text') return;
    const cur = tile.dataset.text ?? '';
    if (!cur) return;
    let display;
    if (mode === 'up'){
      display = cur[0].toUpperCase() + cur.slice(1);
    } else { // down
      display = cur[0].toLowerCase() + cur.slice(1);
    }
    tile.dataset.text = display;
    renderTextLabel(tile);
  }

  /* Accent toggle on specific character index */
  const plainToAcc = { a:'√°', e:'√©', i:'√≠', o:'√≥', u:'√∫',
                       A:'√Å', E:'√â', I:'√ç', O:'√ì', U:'√ö' };
  const accToPlain = { √°:'a', √©:'e', √≠:'i', √≥:'o', √∫:'u',
                       √Å:'A', √â:'E', √ç:'I', √ì:'O', √ö:'U' };

  function applyAccentAt(tile, index){
    if (!tile || tile.dataset.kind !== 'text') return;
    const cur = tile.dataset.text ?? '';
    const chars = [...cur];
    if (index < 0 || index >= chars.length) return;
    const c = chars[index];

    if (plainToAcc[c]) {
      chars[index] = plainToAcc[c];       // add accent
    } else if (accToPlain[c]) {
      chars[index] = accToPlain[c];       // remove accent
    } else {
      return; // not a vowel we handle
    }

    const next = chars.join('');
    tile.dataset.text = next;
    renderTextLabel(tile);
  }

  /* Tile makers */
  function makeTextTile(text, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile' + (isClone ? ' clone' : '');
    div.dataset.kind = 'text';
    div.dataset.text = text;

    const label = document.createElement('span');
    label.className = 'label';
    div.appendChild(label);
    renderTextLabel(div);

    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makePuncTile(ch, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile punc' + (isClone ? ' clone' : '');
    div.dataset.kind = 'punc';
    div.dataset.text = ch;
    div.dataset.puncPos = (ch === '¬ø' || ch === '¬°') ? 'pre' : 'post';

    const label = document.createElement('span');
    label.className = 'label';
    label.textContent = ch;
    div.appendChild(label);

    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeImageTile(url, isClone=false){
    const div = document.createElement('div');
    div.className = 'tile img' + (isClone ? ' clone' : '');
    div.dataset.kind = 'img';
    div.dataset.src = url;

    const im = document.createElement('img');
    im.src = url; im.alt = 'img';
    div.appendChild(im);

    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeSpaceTile(isClone=false){
    const div = document.createElement('div');
    div.className = 'tile space' + (isClone ? ' clone' : '');
    div.dataset.kind = 'space';
    div.dataset.text = ' ';
    makeDraggable(div, { cloneOnDrag: !isClone });
    return div;
  }

  function makeCapTool(mode){
    const div = document.createElement('div');
    div.className = 'tile captool';
    div.dataset.kind = 'captool';
    div.dataset.tool = mode;
    const label = document.createElement('span');
    label.className = 'label';
    label.textContent = mode === 'up' ? '‚Üë' : '‚Üì';
    div.appendChild(label);
    makeDraggable(div, { cloneOnDrag:true });
    return div;
  }

  function makeAccentTool(){
    const div = document.createElement('div');
    div.className = 'tile accenttool';
    div.dataset.kind = 'accenttool';
    const label = document.createElement('span');
    label.className = 'label';
    label.textContent = '¬¥';
    div.appendChild(label);
    makeDraggable(div, { cloneOnDrag:true });
    return div;
  }

  /* Board & palettes */
  function buildRows(boxesPerRow, numRows, countOverride){
    let rows = numRows;
    if (Number.isFinite(countOverride)) {
      rows = Math.max(1, Math.ceil(countOverride / boxesPerRow));
    }

    slotsEl.innerHTML = '';
    let index = 0;
    for (let r = 0; r < rows; r++){
      const line = document.createElement('div');
      line.className = 'line';
      const boxesThisRow = Number.isFinite(countOverride)
        ? Math.min(boxesPerRow, Math.max(0, countOverride - r*boxesPerRow))
        : boxesPerRow;

      for (let c = 0; c < boxesThisRow; c++){
        const s = document.createElement('div');
        s.className = 'slot';
        s.dataset.index = index++;
        line.appendChild(s);
      }
      slotsEl.appendChild(line);
    }
  }

  function fillPalettes(){
    spaceTray.innerHTML = '';
    spaceCard.style.display = SPACE_ON ? '' : 'none';
    if (SPACE_ON) spaceTray.appendChild(makeSpaceTile(false));

    lettersTray.innerHTML = '';
    lettersCard.style.display = LETTERS.length ? '' : 'none';
    LETTERS.forEach(t => lettersTray.appendChild(makeTextTile(t, false)));

    syllTray.innerHTML = '';
    syllCard.style.display = SYLL.length ? '' : 'none';
    SYLL.forEach(t => syllTray.appendChild(makeTextTile(t, false)));

    wordsTray.innerHTML = '';
    wordsCard.style.display = WORDS.length ? '' : 'none';
    WORDS.forEach(w => wordsTray.appendChild(makeTextTile(w, false)));

    puncTray.innerHTML = '';
    puncCard.style.display = PUNC.length ? '' : 'none';
    PUNC.forEach(ch => puncTray.appendChild(makePuncTile(ch, false)));

    picsTray.innerHTML = '';
    picsCard.style.display = IMAGES_ON ? '' : 'none';
    if (IMAGES_ON) {
      IMG_URLS.forEach(u => picsTray.appendChild(makeImageTile(u, false)));
    }

    /* bottom strip: just a handy space tool */
    capTools.innerHTML = '';
    capTools.appendChild(makeSpaceTile(false));

    /* header tools: caps + accent next to Letras / S√≠labas / Palabras */
    lettersCapTools.innerHTML = '';
    lettersCapTools.appendChild(makeCapTool('up'));
    lettersCapTools.appendChild(makeCapTool('down'));
    lettersCapTools.appendChild(makeAccentTool());

    syllCapTools.innerHTML = '';
    syllCapTools.appendChild(makeCapTool('up'));
    syllCapTools.appendChild(makeCapTool('down'));
    syllCapTools.appendChild(makeAccentTool());

    wordsCapTools.innerHTML = '';
    wordsCapTools.appendChild(makeCapTool('up'));
    wordsCapTools.appendChild(makeCapTool('down'));
    wordsCapTools.appendChild(makeAccentTool());
  }

  function relayoutSlot(slot){
    const tiles = [...slot.querySelectorAll('.tile')];
    tiles.forEach(t => t.classList.add('in-slot'));
  }
  function relayoutAllSlots(){
    document.querySelectorAll('.slot').forEach(relayoutSlot);
  }

  /* Drag & drop */
  let drag = null;

  function makeDraggable(el, opts){
    const cloneOnDrag = !!opts?.cloneOnDrag;
    el.style.touchAction = 'none';

    el.addEventListener('pointerdown', (e)=>{
      if(e.button!==0) return;

      const src = e.currentTarget;
      const isPalette = [
        spaceTray, lettersTray, syllTray, wordsTray, puncTray, picsTray,
        capTools, lettersCapTools, syllCapTools, wordsCapTools
      ].includes(src.parentElement);
      let dragEl;
      if (cloneOnDrag && isPalette){
        if (src.dataset.kind === 'img') dragEl = makeImageTile(src.dataset.src, true);
        else if (src.dataset.kind === 'space') dragEl = makeSpaceTile(true);
        else if (src.dataset.kind === 'punc') dragEl = makePuncTile(src.dataset.text, true);
        else if (src.dataset.kind === 'captool') dragEl = makeCapTool(src.dataset.tool);
        else if (src.dataset.kind === 'accenttool') dragEl = makeAccentTool();
        else dragEl = makeTextTile(src.dataset.text, true);
      } else {
        dragEl = src;
      }

      if(dragEl !== src && isPalette){
        document.body.appendChild(dragEl);
      }

      drag = {
        el: dragEl,
        pointerId: e.pointerId,
        fromPalette: isPalette,
        originParent: isPalette ? null : src.parentElement
      };
      drag.el.classList.add('dragging');
      Object.assign(drag.el.style, {
        position:'fixed', zIndex:1000, pointerEvents:'none',
        width: dragEl.offsetWidth + 'px',
        height: dragEl.offsetHeight + 'px'
      });
      moveTo(drag.el, e.clientX, e.clientY);

      document.addEventListener('pointermove', onMove, {passive:false});
      document.addEventListener('pointerup', onUp, {passive:false});
      document.addEventListener('pointercancel', onCancel, {passive:false});
    });
  }

  function moveTo(el,x,y){ el.style.left=(x-28)+'px'; el.style.top=(y-28)+'px'; }

  function onMove(e){
    if(!drag || e.pointerId!==drag.pointerId) return;
    moveTo(drag.el, e.clientX, e.clientY);

    document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
    const t = document.elementFromPoint(e.clientX, e.clientY);
    const slot = t?.closest?.('.slot');
    const kind = drag.el.dataset.kind;
    if(slot && kind !== 'captool' && kind !== 'accenttool') slot.classList.add('highlight');

    trashEl.classList.toggle('highlight',
      kind !== 'captool' && kind !== 'accenttool' && !!t?.closest?.('#trash')
    );
  }

  function insertAtPointer(slot, el, clientX){
    const kids = [...slot.querySelectorAll('.tile')].filter(k => k !== el);
    if (kids.length === 0){
      slot.appendChild(el);
      return;
    }
    const before = kids.find(k => {
      const r = k.getBoundingClientRect();
      return (r.left + r.width/2) >= clientX;
    });
    if (before) slot.insertBefore(el, before);
    else slot.appendChild(el);
  }

  function onUp(e){
    if(!drag || e.pointerId!==drag.pointerId) return;

    const t = document.elementFromPoint(e.clientX, e.clientY);
    const kind = drag.el.dataset.kind;

    /* Cap tools: drop on any word tile */
    if (kind === 'captool'){
      const wordTile = t?.closest?.('.tile[data-kind="text"]');
      if (wordTile){
        const mode = drag.el.dataset.tool === 'down' ? 'down' : 'up';
        applyCapToTile(wordTile, mode);
      }
      drag.el.remove();
      document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
      trashEl.classList.remove('highlight');
      cleanup();
      return;
    }

    /* Accent tool: drop on a specific letter span */
    if (kind === 'accenttool'){
      const charSpan = t?.closest?.('.char-span');
      if (charSpan){
        const label = charSpan.parentElement;
        const tile = label?.closest?.('.tile[data-kind="text"]');
        if (tile){
          const spans = [...label.querySelectorAll('.char-span')];
          const index = spans.indexOf(charSpan);
          if (index !== -1){
            applyAccentAt(tile, index);
          }
        }
      }
      drag.el.remove();
      document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
      trashEl.classList.remove('highlight');
      cleanup();
      return;
    }

    const onTrash = !!t?.closest?.('#trash');
    const slot = t?.closest?.('.slot');

    document.querySelectorAll('.slot').forEach(s => s.classList.remove('highlight'));
    trashEl.classList.remove('highlight');

    drag.el.classList.remove('dragging');
    Object.assign(drag.el.style, {position:'', left:'', top:'', zIndex:'', pointerEvents:'', width:'', height:''});

    if(onTrash){
      const prev = drag.el.parentElement;
      drag.el.remove();
      if(prev?.classList.contains('slot')) relayoutSlot(prev);

    } else if(slot){
      const prev = drag.el.parentElement;
      if(prev?.classList?.contains('slot') && prev !== slot){
        try { prev.removeChild(drag.el); } catch {}
      }
      insertAtPointer(slot, drag.el, e.clientX);
      relayoutSlot(slot);
      if(prev && prev !== slot && prev.classList.contains('slot')) relayoutSlot(prev);

    } else {
      if(drag.fromPalette){
        drag.el.remove();
      } else if (drag.originParent){
        drag.originParent.appendChild(drag.el);
        if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
      }
    }
    cleanup();
  }

  function onCancel(){
    if(!drag) return;
    if(drag.fromPalette ||
       drag.el.dataset.kind === 'captool' ||
       drag.el.dataset.kind === 'accenttool'){
      drag.el.remove();
    } else if (drag.originParent){
      drag.originParent.appendChild(drag.el);
      if(drag.originParent.classList.contains('slot')) relayoutSlot(drag.originParent);
    }
    cleanup();
  }
  function cleanup(){
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', onUp);
    document.removeEventListener('pointercancel', onCancel);
    drag = null;
  }

  /* Pics: drop/paste */
  ;['dragenter','dragover'].forEach(ev=>{
    picsTray.addEventListener(ev, e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
  });
  picsTray.addEventListener('drop', async e=>{
    e.preventDefault();
    const files = [...(e.dataTransfer?.files||[])].filter(f=>f.type.startsWith('image/'));
    for(const f of files){
      const url = URL.createObjectURL(f);
      picsTray.appendChild(makeImageTile(url, false));
    }
  });
  window.addEventListener('paste', e=>{
    const items = [...(e.clipboardData?.items||[])];
    items.forEach(it=>{
      if(it.type && it.type.startsWith('image/')){
        const file = it.getAsFile();
        if(file){
          const url = URL.createObjectURL(file);
          picsTray.appendChild(makeImageTile(url, false));
        }
      }
    });
  });

  /* Validate */
  validateBtn.addEventListener('click', ()=>{
    const result = [];
    document.querySelectorAll('.slot').forEach(slot=>{
      let s = '';
      [...slot.querySelectorAll('.tile')].forEach(t=>{
        const k = t.dataset.kind;
        if (k === 'text') {
          s += t.dataset.text ?? '';
        } else if (k === 'space') {
          s += ' ';
        } else if (k === 'img') {
          s += (s.endsWith(' ') ? '' : ' ') + '[img]' + ' ';
        } else if (k === 'punc') {
          const ch = t.dataset.text || '';
          if (',.?!'.includes(ch)) {
            s = s.replace(/\s+$/,'');
            s += ch;
          } else if ('¬ø¬°'.includes(ch)) {
            s += ch;
          } else {
            s += ch;
          }
        }
      });
      result.push(s.trim());
    });
    alert('Cajas:\n' + result.map((w,i)=>`#${i+1}: ${w || '‚Äî'}`).join('\n'));
  });

  /* Apply */
  applyBoxes.addEventListener('click', ()=>{
    const boxesPer = clampInt(boxesInput.value, BOXES_PER_ROW, 1, 12);
    const rows = clampInt(rowsInput.value,  NUM_ROWS, 1, 50);
    buildRows(boxesPer, rows, null);
    relayoutAllSlots();
  });

  /* Boot */
  buildRows(BOXES_PER_ROW, NUM_ROWS, BOX_COUNT);
  fillPalettes();
  relayoutAllSlots();
</script>
</body>
</html>
